name: msf-lime-mosul-staging
description: |
  staging project for main MSF workflows

collections: null
credentials:
  aisha@openfn.org-MSF-OMRS-admin:
    name: MSF OMRS admin
    owner: aisha@openfn.org
  mtuchi@openfn.org-MSF-DHIS2-UAT:
    name: MSF DHIS2 UAT
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenFnSharepoint:
    name: OpenFnSharepoint
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenMRS-Demo:
    name: OpenMRS Demo
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-dhis2-with-collections:
    name: dhis2-with-collections
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-collections-config:
    name: mtuchi-collections-config
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-github-token:
    name: mtuchi-github-token
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-omrs-with-collections:
    name: omrs-with-collections
    owner: mtuchi@openfn.org
workflows:
  get-metadata-collections:
    name: get-metadata-collections
    jobs:
      Get-and-set-metadata-collections:
        name: Get and set metadata collections
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body: |
          // Check out the Job Writing Guide for help getting started:
          // https://docs.openfn.org/documentation/jobs/job-writing-guide

          // collections.remove("metadata-mappings", "mappings-*")

          //  collections.remove("metadata-mappings", "mapping*")

           collections.get("metadata_mappings", "mappingSets") // getting collections from metadata project

           collections.set("mosul-metadata-mappings", "mappingSets", state => {
            return state.data
           })

          collections.get("mosul-metadata-mappings", "mappingSets") 

    triggers:
      webhook:
        type: webhook
        enabled: false
    edges:
      webhook->Get-and-set-metadata-collections:
        source_trigger: webhook
        target_job: Get-and-set-metadata-collections
        condition_type: always
        enabled: true
  wf1-dhis2-omrs-migration:
    name: wf1-dhis2-omrs-migration
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/fetch-metadata.js

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/get-teis-and-locations.js

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: aisha@openfn.org-MSF-OMRS-admin
        body:
          path: workflows/wf1/create-patients.js

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/update-teis.js

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/alert-admin.js

      Validate-TEIs-with-OMRS-Id:
        name: Validate TEIs with OMRS Id
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          fn((state) => {
            state.patientUuids = state.teisWithOMRSID.map((patient) => {
              return patient.attributes.find(
                (attr) => attr.displayName === "OpenMRS patient UID"
              )?.value;
            });
            state.notFound ??= [];
            return state;
          });

          each(
            $.patientUuids,
            get(`patient/${$.data}`).catch((error, state) => {
              if (error) {
                const tei = state.teisWithOMRSID.find(
                  (tei) =>
                    tei.attributes.find(
                      (attr) => attr.displayName === "OpenMRS patient UID"
                    )?.value === state.data
                );
                state.notFound.push({ patient: state.data, tei: tei.trackedEntity });
              }
              return state;
            })
          );

          fnIf($.notFound.length > 0, (state) => {
            const details = state.notFound
              .map(
                ({ patient, tei }) =>
                  `Patient not found in OMRS for TEI:${tei} with OMRS ID: ${patient}.`
              )
              .join("\n");
            const e = new Error(details);
            throw e;
          });

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: true
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
      Get-Teis-and-Locations->Validate-TEIs-with-OMRS-Id:
        source_job: Get-Teis-and-Locations
        target_job: Validate-TEIs-with-OMRS-Id
        condition_type: js_expression
        condition_label: has-teisWithOMRSID
        condition_expression: |
          !state.errors && state. teisWithOMRSID.length > 0

        enabled: true
  wf1-dhis2-omrs-migration-155:
    name: wf1-dhis2-omrs-migration-155
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-http@6.5.1'
        credential: null
        body: |
          cursor($.manualCursor || $.lastRunDateTime).then((state) => {
            console.log("Date cursor to filter TEI extract ::", state.cursor);
            return state;
          });

          cursor("now", {
            key: "lastRunDateTime",
            format: (c) => {
              const offset = 2; // GMT+2 (Geneva time)
              c.setHours(c.getHours() + offset);
              return c.toISOString().replace("Z", "");
            },
          }).then((state) => {
            console.log("Next sync start date:", state.lastRunDateTime);
            return state;
          });

          // get(
          //   'https://raw.githubusercontent.com/OpenFn/openfn-lime-pilot/refs/heads/collections/metadata/collections.json',
          //   { parseAs: 'json' },
          //   state => {
          //     const { cursor, lastRunDateTime, data } = state;

          //     return { ...data, cursor, lastRunDateTime };
          //   }
          // );

          fn((state) => {
            const { cursor, lastRunDateTime } = state;

            const data = {
              lastSync: "2025-09-30T10:18:54.979Z",
              statusMap: {
                no: "a5c5563e-df0e-4742-a335-b24fb63664ee",
                idp: "099856ce-d8ed-46dc-b541-0379858fb93d",
                yes: "681cf0bc-5213-492a-8470-0a0b3cc324dd",
                other: "790b41ce-e1e7-11e8-b02f-0242ac130002",
                single: "20b8524e-4c26-4fa0-81f0-fa23ebacc54d",
                married: "e64097ff-8069-42d5-8670-69f43b2838c5",
                refugee: "c4f005fd-949f-4a15-8f3f-8bc84533274d",
                student: "69c3d769-c1da-4e48-940a-45b5a4ba395a",
                unknown: "ccb4c50d-13e0-46a2-bd5e-51c86d042ad8",
                widowed: "278cf4fc-50e9-45a7-b633-9a3838eb88cf",
                negative: "a3699fc8-1781-48af-aded-2d9e8e233fde",
                positive: "ad30cb86-fe71-4dc5-a5e3-cd6c3f6545c8",
                returnee: "fc49acaa-ece2-4365-9dfb-70c2105de8b1",
                housewife: "9b14b4d4-b749-4acf-acfe-79c480f3c4b3",
                no_status: "2bacead2-f280-457c-9d28-e80e106f7d25",
                unemployed: "743d174f-f9c7-42a2-80cd-9930e4c52787",
                partner_left: "783a300d-5624-4202-90c6-91660a779cab",
                asylum_seeker: "f921ffdd-72ca-4d58-a89b-1fa2e959d110",
                non_displaced: "bbdb287c-4ba1-4944-bd87-eb126c5f9d92",
                fixed_employee: "5a69bbf4-d4f2-455a-a32e-6179cec3f0cd",
                not_applicable: "8fb2f830-52b3-4593-8e8f-5db8e2be7668",
                divorced_separated: "cbd0c027-1101-4fbe-ae90-4551695f1771",
                occasional_employee: "2cb73bee-7f94-4695-89c7-c81187dbc90c",
                internationally_displaced: "515c5abe-4172-4d0c-a991-0de2888228d7",
              },
              syncedAt: "2025-09-30T10:18:54.963Z",
              formMaps: {
                patient: {
                  formName: "F00-Registration",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    FpuGAOu6itZ: "3884dc76-c271-4bcb-8df8-81c6fb897f53",
                    Jt9BhFZkvP2: "38ef5485-e67f-4a10-bf36-08304fe63877",
                    Qq6xQ2s6LO8: "a9b2c642-097f-43f8-b96b-4d2f50ffd9b1",
                    SVoT2cVLd5O: "e363161a-9d5c-4331-8463-238938f018ed",
                    WDp4nVor9Z7: "c020e465-d495-4f6b-97fa-6d4c0009fcd2",
                    Xvzc9e0JJmp: "24d1fa23-9778-4a8e-9f7b-93f694fc25e2",
                    YUIQIA2ClN6: "e0b6ed99-72c4-4847-a442-e9929eac4a0f",
                    fa7uwpCKIwa: "c404d489-dcb9-44d9-9c30-c5a64ea0df25",
                    mVbzW9TVo7r: "bc851ec1-9fb7-49da-acd7-1a61168002fe",
                    qptKDiv9uPl: "ec42d68d-3e23-43de-b8c5-a03bb538e7c7",
                    v7k4OcXrWR8: "dd1f7f0f-ccea-4228-9aa8-a8c3b0ea4c3e",
                  },
                  optionSetMap: [
                    { DNOavthBRGL: "ec42d68d-3e23-43de-b8c5-a03bb538e7c7" },
                    { qr9jBtm9uvm: "24d1fa23-9778-4a8e-9f7b-93f694fc25e2" },
                    { FTbwlOo7CpG: "e0b6ed99-72c4-4847-a442-e9929eac4a0f" },
                    { y38Qm3uiuuV: "a9b2c642-097f-43f8-b96b-4d2f50ffd9b1" },
                    { G69FtaNkBgp: "3884dc76-c271-4bcb-8df8-81c6fb897f53" },
                    { RpW3aZrlHDi: "dd1f7f0f-ccea-4228-9aa8-a8c3b0ea4c3e" },
                  ],
                  programStage: "MdTtRixaC1B",
                },
                "47ccf9ca-d1a6-3ec1-b474-880a5ab29fee": {
                  formName: "F34-mhGAP Closure",
                  syncType: "latest",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    D9Fd8ZJygPd:
                      "08cd4b4a-4b0b-4391-987b-b5b3d770d30f-rfe-forms-specifyMobileClinic",
                    Di6tE3HKIuz:
                      "1bf47398-7786-4f3e-8cae-b84a21f53eba-rfe-forms-totalNumberOfSessions",
                    KgBg7yNmBfv: "6545b874-f44d-4d18-9ab1-7a8bb21c0a15-rfe-forms-phq9",
                    Sof9AZ6UrV2:
                      "0a0c70d2-2ba5-4cb3-941f-b4a9a4a7ec6d-rfe-forms-specifyHealthFacility",
                    UYgvmfBTHmJ:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    aIEDqQJxdlR:
                      "e08d532b-e56c-43dc-b831-af705654d2dc-rfe-forms-mainLocationOfIntervention_ifOtherSpecify",
                    bduR8KPNSeV:
                      "8a9d2ace-372f-4413-a1c4-8999f55e2de2-rfe-forms-closureDate",
                    c4TiPRUQ56A: "77f1a782-24af-40ba-bac1-b97d9a080f40-rfe-forms-cgiS",
                    e9wcjUxG8mD:
                      "41e68dee-a2a3-4e6c-9d96-53def5caff52-rfe-forms-specifyMsfHealthFacility",
                    gCgVclE0oZf:
                      "cce4fc0b-9d64-4918-8583-2449a59aef60-rfe-forms-wasAMentalHealthCertificateProvided",
                    hDcpO0zG7Gi:
                      "b87a93ff-a4a1-4601-b35d-1e42bfa7e194-rfe-forms-totalNumberOfBeneficiariesInFamilyConsultation",
                    iEdamWl0wzQ: "c64dfacd-2fb5-464d-83a9-ebb9eb8d3ab3-rfe-forms-cgiI",
                    iHyhvpeywlU:
                      "401b2df0-e26f-4f49-9165-6e20a1b8865a-rfe-forms-mainTypeOfConsultation",
                    kuVhB0o09ow:
                      "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-mainLocationOfIntervention",
                    lvCcX90Ud3h:
                      "9e861ef1-e07c-4955-9650-2ebac3138fc3-rfe-forms-typeOfClosure",
                    pQG72ee2lkl: "90b3d09c-d296-44d2-8292-8e04377fe027-rfe-forms-mhos",
                    unHaNHLF5ef:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    yf7WT2UkK7B: "22b16c12-4487-42f4-956c-1890d1f81ac8-rfe-forms-gad7",
                  },
                  optionSetMap: [
                    {
                      mimbbLDaZyZ:
                        "401b2df0-e26f-4f49-9165-6e20a1b8865a-rfe-forms-mainTypeOfConsultation",
                    },
                    {
                      zdJEZvP5dVf:
                        "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-mainLocationOfIntervention",
                    },
                    {
                      ovpSADYY35a:
                        "9e861ef1-e07c-4955-9650-2ebac3138fc3-rfe-forms-typeOfClosure",
                    },
                    {
                      HlTA658wGdn:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                    {
                      kcV89u3gFad: "77f1a782-24af-40ba-bac1-b97d9a080f40-rfe-forms-cgiS",
                    },
                    {
                      kcV89u3gFad: "c64dfacd-2fb5-464d-83a9-ebb9eb8d3ab3-rfe-forms-cgiI",
                    },
                  ],
                  programStage: "wuRtvl5ZXHw",
                },
                "64d35920-6c05-398e-bdf0-a8a671855491": {
                  formName: "F30-MHPSS Follow-up",
                  syncType: "all",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    AZUFlZzPN6V:
                      "278d3d1e-c02a-4db1-8ab3-8db3b82eb9b5-rfe-forms-patientRescheduled",
                    Aj7RmRcG7A4:
                      "3dceead1-70d5-4030-b8f3-bda3938af08d-rfe-forms-doesThePatientHaveACurrentSuicidalRisk",
                    C5XtlggtVmd: "f94de17e-9771-4711-aabb-c5bb0c022be2-rfe-forms-cgiI",
                    CcA8pc2YqWz:
                      "d9454e9c-6e3c-45ab-8a9a-834a9353ae11-rfe-forms-sessionNumber",
                    DdAY5siLKOY:
                      "3b5aa1dd-2d05-4fbd-b8ca-8a7d4ccbf856-rfe-forms-didThePatientSufferNewCriticalEventsSinceTheLastConsultation",
                    E7MVMTTdvPi:
                      "b87a93ff-a4a1-4601-b35d-1e42bfa7e194-rfe-forms-totalNumberOfBeneficiariesInFamilyConsultation",
                    G0hLyxqgcO7:
                      "54e8c1b6-6397-4822-89a4-cf81fbc68ce9-rfe-forms-didThePatientMissTheSession",
                    GVTXoz0VrAd:
                      "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    HNZHetAtowR:
                      "d34d5e93-03d6-494e-8f4c-2d7221227162-rfe-forms-reasonForMissedAppointment",
                    K14cCmpYP26:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    L6Jj7Tppr5q:
                      "e08d532b-e56c-43dc-b831-af705654d2dc-rfe-forms-locationOfIntervention_ifOtherSpecify",
                    LCdm2xe86ln:
                      "41e68dee-a2a3-4e6c-9d96-53def5caff52-rfe-forms-specifyMsfHealthFacility",
                    LllEEDbbhzz:
                      "e0d4e006-85b5-41cb-8a21-e013b1978b8b-rfe-forms-mainNewPrecipitatingEvents3",
                    N6GYmCjAhfh:
                      "6d3876be-0a27-466d-ad58-92edcc8c31fb-rfe-forms-referralDone",
                    UlSJrSD78HS:
                      "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-locationOfIntervention",
                    VcUVLwrZAco:
                      "54a9b20e-bce5-4d4a-8c9c-e0248a182586-rfe-forms-mainNewPrecipitatingEvents2",
                    XjPbncUyYOH:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-pastOrPrecipitatingEvents_ifOtherSpecify",
                    d8Dok4D8Fl4:
                      "1a8bf24f-4f36-4971-aad9-ae77f3525738-rfe-forms-typeOfConsultation",
                    g99rxDRwLht:
                      "5f3d618e-5c89-43bd-8c79-07e4e98c2f23-rfe-forms-phq9Score",
                    hprcEVS6ojr:
                      "c1a3ed2d-6d9a-453d-9d93-749164a76413-rfe-forms-mainCategoryOfPrecipitatingEvent",
                    j8IYwKvxK4q:
                      "ccc4f06c-b76a-440d-9b7e-c48ba2c4a0ab-rfe-forms-doesThePatientPresentARiskOfHarmingOthers",
                    kkG7XvFkZNs:
                      "89e1b4f8-d4c6-491b-bc32-4d4f79a8df9d-rfe-forms-gad7Score",
                    mqiPJsWZljN:
                      "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608-rfe-forms-mainNewPrecipitatingEvents1",
                    rDOPHD77P6d:
                      "edc6f30c-4ff2-4a4f-8b90-ca4502bb97a1-rfe-forms-nextSessionDate",
                    rGS6S4jyKu3:
                      "08cd4b4a-4b0b-4391-987b-b5b3d770d30f-rfe-forms-specifyMobileClinic",
                    sGEOde9q9p9:
                      "0a0c70d2-2ba5-4cb3-941f-b4a9a4a7ec6d-rfe-forms-specifyHealthFacility",
                    t4HoHWCYdvm:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-reasonForMissedAppointment_ifOtherSpecify",
                    tXMgjzusbbt:
                      "b2c5b6e0-66f0-4b9d-8576-b6f48e0a06df-rfe-forms-mhosScore",
                    tloy0Bd9qDf:
                      "d7410cd3-29be-4f8b-93d6-eb4de005db29-rfe-forms-numberOfAppointmentsMissed",
                    vWWl7izQpqd:
                      "82d1fcad-d1be-4ea2-a66c-c872fb4825b4-rfe-forms-typeOfIntervention",
                    wvVn2LfmNDO:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    yTFUtaFJ1QU: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    yUT7HyjWurN: "encounter-date",
                    yb8WWTuSXWa:
                      "8ef009b1-396c-4dda-a816-b688ed66e450-rfe-forms-timeFromTheMainEvent",
                  },
                  optionSetMap: [
                    {
                      FYHuq8p4TYP:
                        "1a8bf24f-4f36-4971-aad9-ae77f3525738-rfe-forms-typeOfConsultation",
                    },
                    {
                      zdJEZvP5dVf:
                        "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-locationOfIntervention",
                    },
                    {
                      F350PsrQw3Z:
                        "82d1fcad-d1be-4ea2-a66c-c872fb4825b4-rfe-forms-typeOfIntervention",
                    },
                    {
                      WlbDv2LELNz:
                        "d34d5e93-03d6-494e-8f4c-2d7221227162-rfe-forms-reasonForMissedAppointment",
                    },
                    {
                      yHYkho3rRNV:
                        "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608-rfe-forms-mainNewPrecipitatingEvents1",
                    },
                    {
                      yHYkho3rRNV:
                        "54a9b20e-bce5-4d4a-8c9c-e0248a182586-rfe-forms-mainNewPrecipitatingEvents2",
                    },
                    {
                      yHYkho3rRNV:
                        "e0d4e006-85b5-41cb-8a21-e013b1978b8b-rfe-forms-mainNewPrecipitatingEvents3",
                    },
                    {
                      kjuVu7bQnEj:
                        "c1a3ed2d-6d9a-453d-9d93-749164a76413-rfe-forms-mainCategoryOfPrecipitatingEvent",
                    },
                    {
                      PrY9ZXhHbhd:
                        "8ef009b1-396c-4dda-a816-b688ed66e450-rfe-forms-timeFromTheMainEvent",
                    },
                    {
                      kcV89u3gFad: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    },
                    {
                      kcV89u3gFad: "f94de17e-9771-4711-aabb-c5bb0c022be2-rfe-forms-cgiI",
                    },
                    {
                      Zu6s2NWggMt:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                  ],
                  programStage: "eUCtSH80vMe",
                },
                "91f52388-7066-3263-b964-5e63b4f4e51d": {
                  formName: "F33-MHPSS Closure",
                  syncType: "latest",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    ELQvFZjc8dL:
                      "0a0c70d2-2ba5-4cb3-941f-b4a9a4a7ec6d-rfe-forms-specifyHealthFacility",
                    F3wIwerMIML:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    KgBg7yNmBfv: "6545b874-f44d-4d18-9ab1-7a8bb21c0a15-rfe-forms-phq9",
                    Lht8GKTAHu8:
                      "9e861ef1-e07c-4955-9650-2ebac3138fc3-rfe-forms-typeOfClosure",
                    QJxbUPjoIoo:
                      "1bf47398-7786-4f3e-8cae-b84a21f53eba-rfe-forms-totalNumberOfSessions",
                    RoBHeg55Mle:
                      "8a9d2ace-372f-4413-a1c4-8999f55e2de2-rfe-forms-closureDate",
                    Sk1nVubpSFa:
                      "e08d532b-e56c-43dc-b831-af705654d2dc-rfe-forms-mainLocationOfIntervention_ifOtherSpecify",
                    TqjvJA0GUOA:
                      "401b2df0-e26f-4f49-9165-6e20a1b8865a-rfe-forms-mainTypeOfConsultation",
                    XhtEvGwiYDK:
                      "08cd4b4a-4b0b-4391-987b-b5b3d770d30f-rfe-forms-specifyMobileClinic",
                    Xk59Xw9eyzS:
                      "b87a93ff-a4a1-4601-b35d-1e42bfa7e194-rfe-forms-totalNumberOfBeneficiariesInFamilyConsultation",
                    c4TiPRUQ56A: "77f1a782-24af-40ba-bac1-b97d9a080f40-rfe-forms-cgiS",
                    iEdamWl0wzQ: "c64dfacd-2fb5-464d-83a9-ebb9eb8d3ab3-rfe-forms-cgiI",
                    pQG72ee2lkl: "90b3d09c-d296-44d2-8292-8e04377fe027-rfe-forms-mhos",
                    pjVuvx8Xq6m:
                      "41e68dee-a2a3-4e6c-9d96-53def5caff52-rfe-forms-specifyMsfHealthFacility",
                    taSJ2FDYTP2:
                      "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-mainLocationOfIntervention",
                    treBZpHPfYk:
                      "cce4fc0b-9d64-4918-8583-2449a59aef60-rfe-forms-wasAMentalHealthCertificateProvided",
                    vmRaiCPePwY:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    yf7WT2UkK7B: "22b16c12-4487-42f4-956c-1890d1f81ac8-rfe-forms-gad7",
                  },
                  optionSetMap: [
                    {
                      mimbbLDaZyZ:
                        "401b2df0-e26f-4f49-9165-6e20a1b8865a-rfe-forms-mainTypeOfConsultation",
                    },
                    {
                      zdJEZvP5dVf:
                        "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-mainLocationOfIntervention",
                    },
                    {
                      ovpSADYY35a:
                        "9e861ef1-e07c-4955-9650-2ebac3138fc3-rfe-forms-typeOfClosure",
                    },
                    {
                      Zu6s2NWggMt:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                    {
                      kcV89u3gFad: "77f1a782-24af-40ba-bac1-b97d9a080f40-rfe-forms-cgiS",
                    },
                    {
                      kcV89u3gFad: "c64dfacd-2fb5-464d-83a9-ebb9eb8d3ab3-rfe-forms-cgiI",
                    },
                  ],
                  programStage: "xrCTheIzyDV",
                },
                "ae41c62a-da26-3a4b-ac75-e7df52f77ec3": {
                  formName: "F32-mhGAP Follow-up",
                  syncType: "all",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    AZUFlZzPN6V:
                      "278d3d1e-c02a-4db1-8ab3-8db3b82eb9b5-rfe-forms-patientRescheduled",
                    AiUr0KZgS9e:
                      "dbf35880-d18e-4f15-ad9c-97b5b053e14a-rfe-forms-isThePatientTakingTheMedicationAsPrescribed",
                    C5XtlggtVmd: "f94de17e-9771-4711-aabb-c5bb0c022be2-rfe-forms-cgiI",
                    CcA8pc2YqWz:
                      "d9454e9c-6e3c-45ab-8a9a-834a9353ae11-rfe-forms-sessionNumber",
                    EOFi7nk2vNM: "encounter-date",
                    G0hLyxqgcO7:
                      "54e8c1b6-6397-4822-89a4-cf81fbc68ce9-rfe-forms-didThePatientMissTheSession",
                    HNZHetAtowR:
                      "d34d5e93-03d6-494e-8f4c-2d7221227162-rfe-forms-reasonForMissedAppointment",
                    M3rgdQLmO05:
                      "edc6f30c-4ff2-4a4f-8b90-ca4502bb97a1-rfe-forms-nextSessionDate",
                    MDbDqs5Mwow:
                      "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-changeInDiagnosis",
                    OBAHc3Rljln:
                      "dc072a1a-20d8-4512-9e57-3585a07cb074-rfe-forms-detailsIfNeeded",
                    TQoTxyjJFQ7:
                      "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    TXI3rYzJhwI:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    alPaUDxtrdg:
                      "5f3d618e-5c89-43bd-8c79-07e4e98c2f23-rfe-forms-phq9Score",
                    frNSzbtH78y:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    kkG7XvFkZNs:
                      "89e1b4f8-d4c6-491b-bc32-4d4f79a8df9d-rfe-forms-gad7Score",
                    t4HoHWCYdvm:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-reasonForMissedAppointment_ifOtherSpecify",
                    tXMgjzusbbt:
                      "b2c5b6e0-66f0-4b9d-8576-b6f48e0a06df-rfe-forms-mhosScore",
                    tloy0Bd9qDf:
                      "d7410cd3-29be-4f8b-93d6-eb4de005db29-rfe-forms-numberOfAppointmentsMissed",
                    yTFUtaFJ1QU: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    z3dmWfX5OSX:
                      "6d3876be-0a27-466d-ad58-92edcc8c31fb-rfe-forms-referralDone",
                  },
                  optionSetMap: [
                    {
                      WlbDv2LELNz:
                        "d34d5e93-03d6-494e-8f4c-2d7221227162-rfe-forms-reasonForMissedAppointment",
                    },
                    {
                      kcV89u3gFad: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    },
                    {
                      kcV89u3gFad: "f94de17e-9771-4711-aabb-c5bb0c022be2-rfe-forms-cgiI",
                    },
                    {
                      flvpQl6fVkp:
                        "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-changeInDiagnosis",
                    },
                    {
                      YMqd6cittuS:
                        "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    },
                    {
                      HlTA658wGdn:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                  ],
                  programStage: "hjHwYnSfJnX",
                },
                "d94898ae-6414-3ec5-8225-febf06eb1833": {
                  formName: "F29-MHPSS Baseline",
                  syncType: "latest",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    Aggyv8LqQbn:
                      "8ef009b1-396c-4dda-a816-b688ed66e450-rfe-forms-timeFromTheMainEvent",
                    AuDPJg6gZE7:
                      "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-locationOfIntervention",
                    CLGnlnFqqnk:
                      "0a0c70d2-2ba5-4cb3-941f-b4a9a4a7ec6d-rfe-forms-specifyHealthFacility",
                    CUdI1BJ5W8G:
                      "92a92f62-3ff6-4944-9ea9-a7af23949bad-rfe-forms-currentSymptomsOrComplaints3",
                    CXS4qAJH2qD: "encounter-date",
                    DMaLm9u4GCq:
                      "b87a93ff-a4a1-4601-b35d-1e42bfa7e194-rfe-forms-totalNumberOfBeneficiariesInFamilyConsultation",
                    DlqJSA5VApl:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    EJwuSLCkYrh:
                      "edc6f30c-4ff2-4a4f-8b90-ca4502bb97a1-rfe-forms-nextSessionDate",
                    EkZqB9eL0W5:
                      "3dceead1-70d5-4030-b8f3-bda3938af08d-rfe-forms-doesThePatientHaveACurrentSuicidalRisk",
                    FLIlRjAwn4G:
                      "e0d4e006-85b5-41cb-8a21-e013b1978b8b-rfe-forms-mainPastOrPrecipitatingEvents3",
                    JUabDHhT1wJ:
                      "c1a3ed2d-6d9a-453d-9d93-749164a76413-rfe-forms-mainCategoryOfPrecipitatingEvent",
                    KSBMR1BDGwx:
                      "1a8bf24f-4f36-4971-aad9-ae77f3525738-rfe-forms-typeOfConsultation",
                    KeyiEPc4pII:
                      "82d1fcad-d1be-4ea2-a66c-c872fb4825b4-rfe-forms-typeOfIntervention",
                    KjgDauY9v4J:
                      "e08d532b-e56c-43dc-b831-af705654d2dc-rfe-forms-locationOfIntervention_ifOtherSpecify",
                    LVtCRRo22k3:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-specificReferralSource_ifOtherSpecify",
                    METV1exWuZg:
                      "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-concomitantDiagnosis",
                    MF3RML0HLbP:
                      "b2c5b6e0-66f0-4b9d-8576-b6f48e0a06df-rfe-forms-mhosScore",
                    PCGI7EnvCQS:
                      "45b39cbf-0fb2-4682-8544-8aaf3e07a744-rfe-forms-currentSymptomsOrComplaints1",
                    QpSVAp9m5uC:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-concomitantDiagnosis_ifOtherSpecify",
                    RiiH9A53rvG:
                      "6d3876be-0a27-466d-ad58-92edcc8c31fb-rfe-forms-referralDone",
                    RnbiVrrSFdm:
                      "ee1b7973-e931-494e-a9cb-22b814b4d8ed-rfe-forms-currentSymptomsOrComplaints2",
                    RqsvaPH9vHt:
                      "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-mainDiagnosis",
                    SsQqwDBGxjh:
                      "54a9b20e-bce5-4d4a-8c9c-e0248a182586-rfe-forms-mainPastOrPrecipitatingEvents2",
                    TWuCY5r2wx7:
                      "ccc4f06c-b76a-440d-9b7e-c48ba2c4a0ab-rfe-forms-doesThePatientPresentARiskOfHarmingOthers",
                    W7cPAi8iXLZ:
                      "819f79e7-b9af-4afd-85d4-2ab677223113-rfe-forms-mainDiagnosisIfOtherSpecify",
                    WpRshJ2dmPl:
                      "89e1b4f8-d4c6-491b-bc32-4d4f79a8df9d-rfe-forms-gad7Score",
                    YeaUNruqmca:
                      "08cd4b4a-4b0b-4391-987b-b5b3d770d30f-rfe-forms-specifyMobileClinic",
                    YfcNA5bvkxT:
                      "9a8204ca-d908-4157-9285-7c970dbb5287-rfe-forms-mainSyndrome",
                    f64XCwzJW02:
                      "41e68dee-a2a3-4e6c-9d96-53def5caff52-rfe-forms-specifyMsfHealthFacility",
                    iistu8GbCdC:
                      "fb359236-733b-42e0-bec3-e7bb0785985f-rfe-forms-knowledgeOfTheService",
                    kdGseg7UE9M:
                      "25ab1831-52a1-46ea-b4f5-a82b50efb396-rfe-forms-dateOfTheMainDiagnosis",
                    m8qis4iUOTo:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-pastOrPrecipitatingEvents_ifOtherSpecify",
                    mDbXCwybfxo:
                      "6d722abd-9bd8-4c32-88d3-5a0b5f0d4aa0-rfe-forms-mainReferralSource",
                    pj5hIE6iyAR:
                      "e08d532b-e56c-43dc-b831-af705654d2dc-rfe-forms-currentSymptomsOrComplaints_ifOtherSpecify",
                    qacGXlyyQOS:
                      "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiSScoreHowMentallyIllIsThePatientAtThisTime",
                    qfYPXP76j8g:
                      "c3c86c1b-07be-4506-ab25-8f35f4389b19-rfe-forms-specificReferralSource",
                    rSIazMFEBjD:
                      "4dae5b12-070f-4153-b1ca-fbec906106e1-rfe-forms-admissionType",
                    u4OFYTJ81rP:
                      "5f3d618e-5c89-43bd-8c79-07e4e98c2f23-rfe-forms-phq9Score",
                    v0qFX0qv1tX:
                      "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608-rfe-forms-mainPastOrPrecipitatingEvents1",
                    vC3bg9NwJ78:
                      "3edcfddb-7988-4ce5-97a0-d4c46b267a04-rfe-forms-durationOfTheMainSymptom",
                    xz4g0Dc9iQi:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    yCwuZ0htrlH:
                      "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    ztw3FbScyEK:
                      "ce98fb42-1576-4168-892f-6d316ae22495-rfe-forms-permissionToBeContactedInCaseOfNeed",
                  },
                  optionSetMap: [
                    {
                      wTGMuMQQwmQ:
                        "4dae5b12-070f-4153-b1ca-fbec906106e1-rfe-forms-admissionType",
                    },
                    {
                      F350PsrQw3Z:
                        "82d1fcad-d1be-4ea2-a66c-c872fb4825b4-rfe-forms-typeOfIntervention",
                    },
                    {
                      O72UnPJGuKC:
                        "1a8bf24f-4f36-4971-aad9-ae77f3525738-rfe-forms-typeOfConsultation",
                    },
                    {
                      zdJEZvP5dVf:
                        "82978311-bef9-46f9-9a9a-cc62254b00a6-rfe-forms-locationOfIntervention",
                    },
                    {
                      R2urD1F9b7J:
                        "ce98fb42-1576-4168-892f-6d316ae22495-rfe-forms-permissionToBeContactedInCaseOfNeed",
                    },
                    {
                      uev9jdVIPiA:
                        "fb359236-733b-42e0-bec3-e7bb0785985f-rfe-forms-knowledgeOfTheService",
                    },
                    {
                      ecwWFbc3j1s:
                        "6d722abd-9bd8-4c32-88d3-5a0b5f0d4aa0-rfe-forms-mainReferralSource",
                    },
                    {
                      xZNOeqJ7DuL:
                        "c3c86c1b-07be-4506-ab25-8f35f4389b19-rfe-forms-specificReferralSource",
                    },
                    {
                      MRNqXzrPl0H:
                        "45b39cbf-0fb2-4682-8544-8aaf3e07a744-rfe-forms-currentSymptomsOrComplaints1",
                    },
                    {
                      MRNqXzrPl0H:
                        "ee1b7973-e931-494e-a9cb-22b814b4d8ed-rfe-forms-currentSymptomsOrComplaints2",
                    },
                    {
                      MRNqXzrPl0H:
                        "92a92f62-3ff6-4944-9ea9-a7af23949bad-rfe-forms-currentSymptomsOrComplaints3",
                    },
                    {
                      ErGIyIc33Sw:
                        "9a8204ca-d908-4157-9285-7c970dbb5287-rfe-forms-mainSyndrome",
                    },
                    {
                      CzXDqkzN6Nq:
                        "3edcfddb-7988-4ce5-97a0-d4c46b267a04-rfe-forms-durationOfTheMainSymptom",
                    },
                    {
                      kcV89u3gFad:
                        "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiSScoreHowMentallyIllIsThePatientAtThisTime",
                    },
                    {
                      flvpQl6fVkp:
                        "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-mainDiagnosis",
                    },
                    {
                      flvpQl6fVkp:
                        "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-concomitantDiagnosis",
                    },
                    {
                      yHYkho3rRNV:
                        "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608-rfe-forms-mainPastOrPrecipitatingEvents1",
                    },
                    {
                      yHYkho3rRNV:
                        "54a9b20e-bce5-4d4a-8c9c-e0248a182586-rfe-forms-mainPastOrPrecipitatingEvents2",
                    },
                    {
                      yHYkho3rRNV:
                        "e0d4e006-85b5-41cb-8a21-e013b1978b8b-rfe-forms-mainPastOrPrecipitatingEvents3",
                    },
                    {
                      kjuVu7bQnEj:
                        "c1a3ed2d-6d9a-453d-9d93-749164a76413-rfe-forms-mainCategoryOfPrecipitatingEvent",
                    },
                    {
                      PrY9ZXhHbhd:
                        "8ef009b1-396c-4dda-a816-b688ed66e450-rfe-forms-timeFromTheMainEvent",
                    },
                    {
                      Zu6s2NWggMt:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                  ],
                  programStage: "MdTtRixaC1B",
                },
                "d9a26c5d-8517-39ac-a14c-dbd1a54d14f6": {
                  formName: "F31-mhGAP Baseline",
                  syncType: "latest",
                  programId: "w9MSPn5oSqp",
                  dataValueMap: {
                    Ajaeo8ZkDur:
                      "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    BNG4w26EI2s:
                      "6d3876be-0a27-466d-ad58-92edcc8c31fb-rfe-forms-referralDone",
                    DCEJHFQvPWa:
                      "5f3d618e-5c89-43bd-8c79-07e4e98c2f23-rfe-forms-phq9Score",
                    G8mgHN9Jm2c:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-patientReferredTo_ifOtherSpecify",
                    I7phgLmRWQq: "encounter-date",
                    METV1exWuZg:
                      "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-concomitantDiagnosis",
                    MF3RML0HLbP:
                      "b2c5b6e0-66f0-4b9d-8576-b6f48e0a06df-rfe-forms-mhosScore",
                    QpSVAp9m5uC:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-concomitantDiagnosis_ifOtherSpecify",
                    R3g94vJ2yFR:
                      "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-mainDiagnosis",
                    SOR54p6CGTx:
                      "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    VnXwFYqHNqM:
                      "15748787-7372-4022-b5d4-81ff8d6887ca-rfe-forms-olderAdult",
                    WpRshJ2dmPl:
                      "89e1b4f8-d4c6-491b-bc32-4d4f79a8df9d-rfe-forms-gad7Score",
                    Yt4NhxZU5Vo:
                      "790b41ce-e1e7-11e8-b02f-0242ac130002-rfe-forms-mainDiagnosis_ifOtherSpecify",
                    hMcCdEkhhjZ:
                      "f6cefc80-506a-44b0-ab5f-d6f5908cf7a5-rfe-forms-childOrAdolescent",
                    kdGseg7UE9M:
                      "25ab1831-52a1-46ea-b4f5-a82b50efb396-rfe-forms-dateOfTheMainDiagnosis",
                    pHoZYTrR7N0:
                      "2be92591-da1b-4418-ba49-43b3fc0e4ce5-rfe-forms-pregnantOrBreastfeeding",
                    pPy6lKptm1T:
                      "3dceead1-70d5-4030-b8f3-bda3938af08d-rfe-forms-doesThePatientHaveACurrentSuicidalRisk",
                    qCRNMAevGF9:
                      "edc6f30c-4ff2-4a4f-8b90-ca4502bb97a1-rfe-forms-nextSessionDate",
                    qacGXlyyQOS: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    rSIazMFEBjD:
                      "4dae5b12-070f-4153-b1ca-fbec906106e1-rfe-forms-admissionType",
                    vLfsElaDxZf:
                      "af23b916-3e95-4bd4-8804-a4b1649ff365-rfe-forms-historyOfSelfHarmOrSuicide",
                    zwMoLjEgFC3:
                      "c3c86c1b-07be-4506-ab25-8f35f4389b19-rfe-forms-referralSource",
                  },
                  optionSetMap: [
                    {
                      pNEmG0RefTw:
                        "c3c86c1b-07be-4506-ab25-8f35f4389b19-rfe-forms-referralSource",
                    },
                    {
                      wTGMuMQQwmQ:
                        "4dae5b12-070f-4153-b1ca-fbec906106e1-rfe-forms-admissionType",
                    },
                    {
                      kcV89u3gFad: "a1a75011-0fef-460a-b666-dda2d171f39b-rfe-forms-cgiS",
                    },
                    {
                      flvpQl6fVkp:
                        "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-mainDiagnosis",
                    },
                    {
                      flvpQl6fVkp:
                        "22809b19-54ca-4d88-8d26-9577637c184e-rfe-forms-concomitantDiagnosis",
                    },
                    {
                      YMqd6cittuS:
                        "5f6e245c-83fc-421b-8d46-061ac773ae71-rfe-forms-followUpSessionRequired",
                    },
                    {
                      HlTA658wGdn:
                        "8fb3bb7d-c935-4b57-8444-1b953470e109-rfe-forms-patientReferredTo",
                    },
                  ],
                  programStage: "EZJ9FsNau7Q",
                },
              },
              sourceFile: "LIME EMR - Iraq Metadata - Release 1 -v2025-09-25.xlsx",
              identifiers: [
                {
                  type: "DHIS2_PATIENT_NUMBER",
                  description: "DHIS2 Patient Number",
                  "example value": "ER-IQ2024-1234",
                  "dhis2 attribute id": "P4wdYGkldeG",
                  "omrs identifierType": "8d79403a-c2cc-11de-8d13-0010c6dffd0f",
                },
                {
                  type: "OPENMRS_AUTO_ID",
                  description: "OpenMRS Patient Number",
                  "example value": "IQ146-24-000-027",
                  "dhis2 attribute id": "ZBoxuExmxcZ",
                  "omrs identifierType": "05a29f94-c0ed-11e2-94be-8c13b969e334",
                },
                { type: "ORG_UNIT", "dhis2 attribute id": "OPjuJMZFLop" },
                { type: "PROGRAM", "dhis2 attribute id": "w9MSPn5oSqp" },
              ],
              fileDateModified: "2025-09-30T10:16:38Z",
              nationalityMap: {
                chad: "9e41e71c-f5d5-456c-a6f9-2129b8055bfc",
                cuba: "147c2434-5d7e-420c-8053-ba623301f3f5",
                guam: "51fa502b-98a3-4c42-b5fd-7b4d64489bb9",
                iran: "b422270e-d8af-4a32-b523-742545a17a3f",
                iraq: "03aa7d6e-7656-48e4-8dc0-5e27706722c0",
                laos: "dfb01b39-c224-459e-b045-dd9461b9a1e5",
                mali: "3e844a47-526a-46f9-afea-1af9ff8690aa",
                oman: "9b0af037-99d1-43b8-ac06-82137ec4b06d",
                peru: "e74fa87f-8469-46b0-975f-6cb37c394564",
                togo: "6a583e64-869d-477d-a1c1-746320d45fc4",
                aruba: "f3f1cba1-7c1e-4234-86a2-f27bb5964fee",
                benin: "cf863e31-bb38-48ed-90dd-f3dedcac304c",
                chile: "05333883-44e9-4f57-836a-041391803007",
                china: "15016874-3e20-484a-baa8-9b94e1a3d358",
                egypt: "cc7343f8-9243-4d09-b378-58363850d624",
                gabon: "9f46ae06-114a-47fa-8f8d-e9749f04da25",
                ghana: "2eb4ff46-d908-4148-9b0d-40ccfc1a655a",
                haiti: "f76f7dcb-f82e-4257-a627-1685ff3f3586",
                india: "378d0107-eb43-485d-930c-0704b4e5aa11",
                kenya: "ad351a33-8846-4cad-8195-b07b6041d4a5",
                libya: "600c6af4-b767-423c-b942-7f06ca467258",
                nauru: "3386fe63-2158-4040-a502-9f65fd2079d3",
                nepal: "fb01b01a-6775-423c-8012-7d43f587cb6c",
                niger: "7561db90-a866-4443-93f4-95cac1d47e9c",
                other: "790b41ce-e1e7-11e8-b02f-0242ac130002",
                samoa: "e03b381b-a7f4-40eb-964f-51571dc3c48c",
                sudan: "2f03a932-2b75-4e8b-9f44-0fcd83c75dc4",
                syria: "1e34ee55-ef9f-4386-bae6-6995555ded75",
                tonga: "d381f06d-2365-4f40-948b-cfe90d8cb532",
                yemen: "6a3214e0-f94b-414c-8148-968e24386671",
                angola: "8a2e5a03-8a74-41ae-9a98-2310f9ce400d",
                bhutan: "d45a57c9-994f-4deb-8845-9b785860a2ec",
                brazil: "353ff388-64e6-434c-b78f-ca9636390389",
                gambia: "5ec7ddd7-14a5-48ec-9e7c-8896d1010655",
                greece: "b75d6bcc-fadf-4141-8d0f-2463154b89f7",
                guinea: "eeaff39c-8afd-43f7-b9a0-53729f5df1d8",
                guyana: "ba4dfa7e-f3cd-4e94-8ca7-6b96a93378a8",
                jordan: "842f963c-f84d-4076-a8db-337295fd9b91",
                kuwait: "4aee7a88-cda9-454e-9f25-4a6420270417",
                malawi: "e8b5f188-6a5c-43ae-b4a5-200abb13153e",
                mexico: "8381208f-01ca-4ed3-8f2c-f73ed1c316e3",
                panama: "1ef5a828-9d0d-4336-91ab-880d5dc0151c",
                rwanda: "6bc925a1-7699-496a-85b0-c290699381db",
                serbia: "d2e69cef-3bff-4220-ba91-a6a678fb606b",
                turkey: "7429c779-1d3a-4aec-8256-d0b1637e1bd1",
                uganda: "be3d11d3-446d-440c-a582-d01c7cbb0eda",
                zambia: "3ec0432d-ea37-4159-a658-29d6f07fe21a",
                albania: "db21f4f9-faf2-4358-8297-0ae76627b3b8",
                algeria: "5f6c017f-074c-46b3-92d0-d055e2094366",
                armenia: "39f1652a-f2b7-4b65-a7e1-7097ac6cdef0",
                belarus: "664baba4-c552-47b9-97c0-ff67dafd27d6",
                bolivia: "d8800d10-862b-42f1-8e22-cac1ce1bbcae",
                burundi: "8a2ed0db-eaad-44bc-bf06-5cb1b2a3db0b",
                comoros: "9d8738c8-40c2-4c66-aabb-ef176a20ffe8",
                ecuador: "f9810f9a-78a7-42a2-99e6-19c629642386",
                eritrea: "c61f03c2-0d1f-444f-a974-0a61063aff71",
                georgia: "bc71788f-db69-4b6f-8d1c-57a74395bdd2",
                lebanon: "7de78f22-f53e-48d2-923f-ae1e4d814f46",
                lesotho: "b35b29c5-9bb7-4b40-ad33-29eecd28a9e6",
                liberia: "a5fd61b4-fd27-433d-8428-7e88a7f27921",
                mayotte: "1af148fe-2698-4b89-bf7f-87e5c48b6848",
                moldova: "f0e9c8b5-69b5-48df-8cb9-2d089ba04e46",
                morocco: "ef467a17-91e8-4124-a136-7ed8ff7c7d15",
                myanmar: "e81ba700-f9fc-4ed0-b248-578a25717cdb",
                namibia: "0cb123dc-8810-4840-b6ab-6a527c5a79ef",
                nigeria: "4134651a-7f53-45fb-8bc6-7fed9cf36f51",
                reunion: "1dae4b2d-50c9-4bf1-b25a-7063600a5e74",
                romania: "457e745e-ae97-463d-95a9-8d5689d3ca2b",
                senegal: "ad948f1b-0733-4f8d-b049-d64289b43a10",
                somalia: "99c8dccc-4dfa-4d30-86be-42a309ab431f",
                tunisia: "56be7864-fde6-4db3-8fa5-b9dd42cd9c53",
                ukraine: "38c99c8d-2b93-4848-a537-b1865a260bb2",
                unknown: "ccb4c50d-13e0-46a2-bd5e-51c86d042ad8",
                uruguay: "c2e45baf-748b-4d7b-a391-ed6b802b6f94",
                vietnam: "49509c5f-e533-48a8-bf06-86935e3376b2",
                anguilla: "c911af8a-171c-4ee9-b1ff-934373e8a819",
                botswana: "1304a0de-5b70-4d36-a873-e72a82963316",
                bulgaria: "91c85a62-2b02-483a-aefd-e29d368565fe",
                cambodia: "4fd14df8-8279-4dfa-bdd3-e1ab26bc0264",
                cameroon: "873552ac-9850-4cc1-ae09-17eb0fccf405",
                colombia: "a008dff8-ce96-4662-bf8a-372e43d424f0",
                djibouti: "cf5b334f-1c0f-41fc-ab54-53ff1e942830",
                dominica: "f70e51e5-b76c-4c38-9bf2-ef8e1f308ce1",
                ethiopia: "7478d375-014e-410e-a355-090143e88f5b",
                honduras: "cdd1336e-495b-4868-aace-57a84442d6fd",
                malaysia: "3facca11-fbaa-4c40-8fac-4751d45c3f1b",
                mongolia: "9f341cb1-dcb5-4f6c-bd21-b57db01b4193",
                pakistan: "f45d93c3-c9b0-4333-a5e6-299b7c425812",
                paraguay: "d8412016-82f5-4801-a026-1bdc429850b7",
                suriname: "c65d3329-98d4-4dd7-89d3-141b70d00eb2",
                tanzania: "050a8eb1-0d77-4f65-a2da-776a13bcd2a4",
                thailand: "289ac5bd-6434-4837-86bf-b54d22970ac8",
                zimbabwe: "ce1b0d8d-0a2d-4f93-a6ed-64aca2fd0f45",
                argentina: "b83d24e8-34d8-4920-83c0-8ba014467ff4",
                drc_congo: "8f6d3d2a-e09f-473b-99c9-e539f97ceab6",
                guatemala: "3725a4d2-b28f-466b-905a-bafeaeb75855",
                indonesia: "1cbe17e6-adc2-4680-bee0-54d94af75ebf",
                macedonia: "5837cc40-9ab5-4088-91c8-ca6e4b57e903",
                mauritius: "17ced083-eb2a-4046-a713-26cabc7af95d",
                nicaragua: "f6a9521c-596b-49f9-b914-67138e8c17e6",
                palestina: "e2a19948-49aa-44c0-98ef-67ae1160ef43",
                sri_lanka: "b0031c01-d242-4410-b98b-cc1511590b85",
                swaziland: "06a2703b-af17-4e44-83f5-6cc9a8a75320",
                venezuela: "557cea4a-0049-4b7a-b373-ed63f294a2a0",
                azerbaijan: "29750013-0e35-47ca-8f77-9192a923fb07",
                bangladesh: "a99de53c-ce76-4b1e-91b2-461094baf79e",
                cape_verde: "cfbc220a-1d6c-4469-bb6d-a8e3deb4f7e7",
                costa_rica: "fb52f8c9-40ec-4dc4-92a4-d465612de2ff",
                east_timor: "854f2f66-40e1-4a6a-9dee-09c832a52289",
                kazakhstan: "6f6d0e78-2c81-411d-8d13-367e250dc110",
                kyrgyzstan: "ace3b851-042b-46a6-8fea-68aae042d614",
                madagascar: "3782bf3c-380e-4b60-b21a-38199073f112",
                martinique: "051ce04e-05e8-4430-8b75-3e499bbffbc8",
                mauritania: "8acb006b-8596-4a98-8177-acb4cb575956",
                mozambique: "0916133b-4d93-4d60-9c20-e7ee3936f391",
                tajikistan: "34836c60-5449-48d6-b3c9-c0b3361b9f2c",
                uzbekistan: "60512350-d79b-41aa-aff0-1b28ca4aa5f1",
                afghanistan: "84066564-253e-43d8-b141-76730cffa878",
                el_salvador: "9a34935e-5a8a-45be-8ccd-cb23192e420f",
                north_korea: "4d3079e4-8568-48e6-9342-665896875a38",
                philippines: "bdbd5c9f-1f28-4f4d-a254-4a84f8bb2c8f",
                puerto_rico: "39fca1d0-d2e7-4b13-82bd-626fbec71252",
                south_korea: "0603d6b9-334f-4443-ab60-7c5d457b95fc",
                south_sudan: "f113e24e-2ea9-49a2-9b28-59241b9adb21",
                switzerland: "dcdcdc70-a006-4b0a-bac2-7de89b022b65",
                burkina_faso: "6c90c1ae-17a4-4e94-a267-4fba4c94efd8",
                cote_divoire: "513cb36a-3f67-46ea-a789-fcdaca0e26f5",
                saudi_arabia: "fdf495a4-e60c-46f7-a8a2-61a216849086",
                sierra_leone: "ffba9caf-b6aa-4078-845e-578f7a7fd566",
                south_africa: "75882d62-1c55-480d-b411-8ca40c3307df",
                turkmenistan: "3ef17df5-299b-4385-9ea6-572df4b6f9ca",
                guinea_bissau: "14e90203-9197-42ea-9222-acafd2fd6984",
                new_caledonia: "e67c072b-7707-491f-8c2e-13c914216b61",
                western_sahara: "4086dfd2-f4f5-4107-93e8-07bee235af8f",
                papua_new_guinea: "e1e6b451-d7fe-4954-b225-99b2de82a4c0",
                equatorial_guinea: "7e591605-d723-4398-982a-8737af63a2dc",
                republic_of_congo: "5db9afa5-b57e-4f45-8b1c-af766f14fc58",
                dominican_republic: "ce72fc9b-619b-4c32-b865-600e888ad814",
                sao_tome_and_principe: "f66bbb42-684f-42d7-bfcd-95d586eb7dc9",
                bosnia_and_herzegovina: "05d8f4ef-45eb-463d-b2f3-8a5a613ee6b9",
                british_virgin_islands: "b02c6d20-83a2-4947-8a7d-91d1f9c4d8a2",
                central_african_republic: "61a4c4a4-25c2-4459-a874-ec1d24f8323a",
              },
            };

            return {
              ...data,
              cursor,
              lastRunDateTime,
            };
          });
          fn(({ identifiers, formMaps, ...state }) => {
            state.genderOptions = {
              male: "M",
              female: "F",
              unknown: "U",
              transgender_female: "O",
              transgender_male: "O",
              prefer_not_to_answer: "O",
              gender_variant_non_conforming: "O",
            };
            state.orgUnit = identifiers.find((i) => i.type === "ORG_UNIT")?.[
              "dhis2 attribute id"
            ];
            state.program = identifiers.find((i) => i.type === "PROGRAM")?.[
              "dhis2 attribute id"
            ];

            state.patientAttributes = Object.entries(formMaps.patient.dataValueMap)
              .filter(
                ([key]) =>
                  !["qptKDiv9uPl", "fa7uwpCKIwa", "Jt9BhFZkvP2", "WDp4nVor9Z7"].includes(
                    key
                  )
              )
              .reduce((acc, [key, value]) => {
                acc[key] = value;
                return acc;
              }, {});

            state.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            state.dhis2PatientNumberAttributeId = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["dhis2 attribute id"]; //DHIS2 ID or DHIS2 Patient Number

            state.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            state.openmrsAutoIdAttributeId = identifiers.find(
              (i) => i.type === "OPENMRS_AUTO_ID"
            )?.["dhis2 attribute id"]; //MSF ID or OpenMRS Patient Number

            return state;
          });

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const findDuplicatePatient = (teis) => {
            const seen = new Map();
            const duplicates = new Set();

            teis.forEach((tei) => {
              const patientNumber = tei.attributes.find(
                (attr) => attr.code === "patient_number"
              )?.value;

              if (seen.get(patientNumber)) {
                duplicates.add(patientNumber);
              } else {
                seen.set(patientNumber, tei);
              }
            });

            return duplicates;
          };
          // Get teis that are "active" in the target program
          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit, //'OPjuJMZFLop',
            program: $.program, //'w9MSPn5oSqp',
            programStatus: "ACTIVE",
            updatedAfter: $.cursor,
            skipPaging: true,
          });

          fn((state) => {
            console.log("# of TEIs found before filter ::", state.data.instances.length);
            const uniqueTeis = [];
            const duplicatePatients = [];
            const missingPatientNumber = [];

            const filteredTeis = state.data.instances.filter(
              (tei) => tei.updatedAt >= state.cursor
            );

            console.log("Filtered TEIs ::", filteredTeis.length);
            const duplicateIds = findDuplicatePatient(filteredTeis);

            filteredTeis.forEach((tei) => {
              const patientNumber = tei.attributes.find(
                (attr) => attr.code === "patient_number"
              )?.value;

              const patientUid = tei.attributes.find(
                (attr) => attr.attribute === "AYbfTPYMNJH" //filtering patients that have OMRS-id
              )?.value;
              if (patientUid) {
                console.log(
                  `Skipping TEI:: ${tei.trackedEntity}. Found existing patient uid.`
                );
                return;
              }
              if (!patientNumber) {
                missingPatientNumber.push(tei);
              } else if (duplicateIds.has(patientNumber)) {
                duplicatePatients.push(tei);
              } else {
                uniqueTeis.push(tei);
              }
            });

            console.log("# of Unique TEIs to migrate to OMRS ::", uniqueTeis.length);
            console.log("# Duplicate Patients found::", duplicatePatients.length);

            // return { uniqueTeis, duplicatePatients, filteredTeis, missingPatientNumber };
            return {
              ...state,
              data: {},
              references: [],
              uniqueTeis,
              duplicatePatients,
              missingPatientNumber,
            };
          });

          get("optionGroups/kdef7pUey9f", {
            fields: "id,displayName,options[id,displayName,code]",
          });

          fn(({ data, ...state }) => {
            state.locations = data;
            return state;
          });

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          //Define gender options and prepare newPatientUuid and identifiers
          fn((state) => {
            const { uniqueTeis } = state;
            console.log("# of TEIs to send to OpenMRS: ", uniqueTeis.length);
            return state;
          });

          //First we generate a unique OpenMRS ID for each patient
          each(
            $.uniqueTeis,
            post(
              "idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier"
            ).then((state) => {
              state.identifiers ??= [];
              state.identifiers.push(state.data.identifier);
              return state;
            })
          );

          // Then we map uniqueTeis to openMRS data model
          fn((state) => {
            const {
              uniqueTeis,
              nationalityMap,
              genderOptions,
              identifiers,
              statusMap,
              locations,
            } = state;

            const getValueForCode = (attributes, code) => {
              const result = attributes.find((attribute) => attribute.code === code);
              return result ? result.value : undefined;
            };

            const calculateDOB = (age) => {
              if (!age) return age;
              const currentDate = new Date();
              const currentYear = currentDate.getFullYear();
              const birthYear = currentYear - age;

              const birthday = new Date(
                birthYear,
                currentDate.getMonth(),
                currentDate.getDay()
              );

              return birthday.toISOString().replace(/\.\d+Z$/, "+0000");
            };

            state.patients = uniqueTeis.map((d, i) => {
              const patientNumber =
                getValueForCode(d.attributes, "patient_number") || d.trackedEntity; // Add random number for testing + Math.random()

              const lonlat = d.attributes.find(
                (a) => a.attribute === "rBtrjV1Mqkz"
              )?.value;
              const location = lonlat
                ? locations.options.find((o) => o.code === lonlat)?.displayName
                : undefined;

              let countyDistrict, cityVillage;

              if (location) {
                const match = location.match(/^(.*?)\s*\((.*?)\)/);
                if (match) {
                  [, countyDistrict, cityVillage] = match;
                  cityVillage = cityVillage.split("-")[0].trim(); // Remove country code and trim
                }
              }

              const attributes = d.attributes
                .filter((a) => a.attribute in state.patientAttributes)
                .map((a) => {
                  const attributeType = state.patientAttributes[a.attribute];

                  if (a.displayName === "Nationality") {
                    return {
                      attributeType,
                      value: nationalityMap[a.value],
                    };
                  }
                  if (a.displayName.includes(" status")) {
                    return {
                      attributeType,
                      value: statusMap[a.value],
                    };
                  }

                  return {
                    attributeType,
                    value: a.value,
                  };
                })
                .filter(Boolean);

              return {
                patientNumber,
                person: {
                  age: getValueForCode(d.attributes, "age"),
                  gender: genderOptions[getValueForCode(d.attributes, "sex")] ?? "U",
                  birthdate:
                    d.attributes.find((a) => a.attribute === "WDp4nVor9Z7")?.value ??
                    calculateDOB(getValueForCode(d.attributes, "age")),
                  // d.attributes.find(a => a.attribute === 'WDp4nVor9Z7')?.value ?
                  // calculateDOB(getValueForCode(d.attributes, 'age')) : '1900-01-01',
                  birthdateEstimated: d.attributes.find(
                    (a) => a.attribute === "WDp4nVor9Z7"
                  )
                    ? true
                    : false,
                  names: [
                    {
                      familyName:
                        d.attributes.find((a) => a.attribute === "fa7uwpCKIwa")?.value ??
                        "unknown",
                      givenName:
                        d.attributes.find((a) => a.attribute === "Jt9BhFZkvP2")?.value ??
                        "unknown",
                    },
                  ],
                  addresses: [
                    {
                      country: "Iraq",
                      stateProvince: "Ninewa",
                      countyDistrict,
                      cityVillage,
                    },
                  ],
                  attributes,
                },
                identifiers: [
                  {
                    identifier: identifiers[i], //OMRS-generated identifier - see above
                    identifierType: "05a29f94-c0ed-11e2-94be-8c13b969e334",
                    location: "cf6fa7d4-1f19-4c85-ac50-ff824805c51c", //default location old:44c3efb0-2583-4c80-a79e-1f756a03c0a1
                    preferred: true,
                  },
                  {
                    uuid: d.trackedEntity,
                    identifier: patientNumber, //Patient Number from DHIS2
                    identifierType: "8d79403a-c2cc-11de-8d13-0010c6dffd0f", //Old Identification number
                    location: "cf6fa7d4-1f19-4c85-ac50-ff824805c51c", //default location
                    preferred: false, //default value for this identifiertype
                  },
                ],
              };
            });

            return state;
          });

          // Creating patients in openMRS
          each(
            $.patients,
            upsert(
              "patient",
              { q: $.data.patientNumber, limit: 1, startIndex: 0 },
              (state) => {
                const { patientNumber, ...patient } = state.data;
                console.log(
                  "Upserting patient record...",
                  JSON.stringify(patient, null, 2)
                );
                return patient;
              },
              (state) => {
                state.newPatientUuid ??= [];
                //console.log('state.references ::', state.references)
                state.newPatientUuid.push({
                  patient_number: state.references.at(-1)?.patientNumber,
                  omrs_patient_number: state.references
                    .at(-1)
                    ?.identifiers.find(
                      (i) => (i.identifierType = `${state.openmrsAutoId}`)
                    ),
                  uuid: state.data.uuid,
                });
                return state;
              }
            )
          );

          // Clean up state
          fn(({ data, references, ...state }) => state);

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          fn(state => {
            if (state.newPatientUuid.length === 0) {
              console.log('No data fetched in step prior to sync.');
            }

            console.log(
              'newPatientUuid ::',
              JSON.stringify(state.newPatientUuid, null, 2)
            );
            return state;
          });

          // Update TEI on DHIS2
          each(
            $.newPatientUuid,
            upsert(
              'trackedEntityInstances',
              {
                ou: $.orgUnit,
                program: $.program,
                filter: [`${$.dhis2PatientNumberAttributeId}:Eq:${$.data.patient_number}`],
              },
              state => {
                const payload = {
                  orgUnit: state.orgUnit,
                  program: state.program,
                  trackedEntityType: 'cHlzCA2MuEF',
                  attributes: [
                    {
                      attribute: `${state.dhis2PatientNumberAttributeId}`,
                      value: `${state.data.patient_number}`,
                    }, //DHIS2 patient number to use as lookup key
                    { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
                    {
                      attribute: `${state.openmrsAutoIdAttributeId}`,
                      value: `${state.data.omrs_patient_number.identifier}`,
                    }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
                  ],
                }

                console.log('final payload to send to dhis2:', payload)
                return payload; 
              }
            )
              // {
              //   orgUnit: $.orgUnit,
              //   program: $.program,
              //   trackedEntityType: 'cHlzCA2MuEF',
              //   attributes: [
              //     {
              //       attribute: `${$.dhis2PatientNumberAttributeId}`,
              //       value: `${state.data.patient_number}`,
              //     }, //DHIS2 patient number to use as lookup key
              //     { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
              //     {
              //       attribute: `${state.openmrsAutoIdAttributeId}`,
              //       value: `${state.data.omrs_patient_number.identifier}`,
              //     }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
              //   ],
              // },
          );

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          fn(state => {
            const code = 'DUPLICATE_PATIENT_NUMBERS';
            const description = `Found ${state.duplicatePatients.length} TIEs with duplicate patient numbers`;
            const message = `${code}: ${description}`;
            const patientNumbers = state.duplicatePatients.map(
              patient =>
                patient.attributes.find(attr => attr.code === 'patient_number').value
            );

            const details = {
              code,
              description,
              duplicatePatientNumbers: patientNumbers,
            };
            const e = new Error(message);
            e.details = details;
            console.error(e.details);
            throw e;
          });

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
  wf2-omrs-dhis2:
    name: wf2-omrs-dhis2
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/1-get-patients.js

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body:
          path: workflows/wf2/2-mappings.js

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/3-upsert-teis.js

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/4-get-encounters.js

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/5-get-teis.js

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/6-create-events.js

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/7-update-teis.js

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf2/events-mapping.js

      Create-TEIs-Relationship:
        name: Create TEIs Relationship
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Check if relationship exist
          each($.relationshipsMapping, get('tracker/relationships', { trackedEntity: $.data.from.trackedEntityInstance.trackedEntityInstance }).then(state => {
            const relationship = state.references.at(-1)
            const toTei = relationship.to.trackedEntityInstance.trackedEntityInstance
            const hasRelationship = state.data.instances.find(r => r.to.trackedEntity.trackedEntity === toTei)
            state.relationshipsToCreate ??= []
            if (!hasRelationship) {
              state.relationshipsToCreate.push(relationship)
            }
            return state
          }))

          // Creating relationship between parent and child tei
          each($.relationshipsToCreate, create('relationships', $.data))

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters.length > 0

        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
      Mappings->Upsert-TEIs:
        source_job: Mappings
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors

        enabled: true
      Get-TEIs-and-Map-Answers->Create-TEIs-Relationship:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Create-TEIs-Relationship
        condition_type: js_expression
        condition_label: relationship-mapping
        condition_expression: |
          state?.relationshipsMapping?.length > 0

        enabled: true
      Create-TEIs-Relationship->Event-Mappings:
        source_job: Create-TEIs-Relationship
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-child-teis
        condition_expression: |
          state.childTeis && !state.errors

        enabled: true
  wf2-omrs-dhis2-137:
    name: wf2-omrs-dhis2-137
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }

          cursor($.lastRunDateTime || "2025-03-20T06:01:24.000Z");

          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({ q: "IQ146-25-012-292", v: "full", limit: "100" });
          fn((state) => {
            const { cursor, data } = state;
            console.log("Filtering patients since cursor:", cursor);
            console.log("Patient fetched", data.results.length);

            state.patients = data.results
              .filter(({ auditInfo }) => {
                const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
                return lastModified > cursor;
              })
              .map((p) => {
                const { uuid, auditInfo, identifiers, person } = removeLinks(
                  removeNulls(p)
                );
                const { dateCreated } = auditInfo;
                const { age, birthdate, gender, names, addresses, attributes } = person;

                return {
                  uuid,
                  person: {
                    age,
                    birthdate,
                    gender,
                    names,
                    addresses: [addresses.find((a) => a.cityVillage)],
                    attributes,
                  },
                  identifiers,
                  auditInfo: { dateCreated },
                };
              });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });

          // Fetch all encounters
          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );

          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });

          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [...new Set(searchPatientUuids, encounterPatientUuids)];

            console.log("inbothResults", inbothResults.length);
            console.log("patient-search-array", onlyInSearchPatient.length);
            console.log("r4-encounter-array", onlyInR4Encounter.length);
            console.log("combined uuids", patientUuids.length);

            return { cursor, lastRunDateTime, patients, patientUuids };
          });

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body: |
          const isValidUUID = (id) => {
            if (!id || typeof id !== "string") return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);
            state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
            state.formMetadata = state.data.find((i) => i.key === "formMetadata")?.value;
            state.placeOflivingMap = state.data.find(
              (i) => i.key === "placeOflivingMap"
            )?.value;
            state.sourceFile = state.data.filter(
              (i) => i.key === "sourceFile"
            )?.[0]?.value;
            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;
            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            // TODO: Remove state.optionSetKey, when needed
            // Build from state.formMaps
            state.optionSetKey = state.data.filter(
              (i) => i.key === "optionSetKey"
            )?.[0]?.value;

            delete state.data;
            delete state.references;
            return state;
          });

          fn((state) => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) &&
                  form["OMRS Form Version"] === "v4-2025"
              )
              .map((form) => form["OMRS form.uuid"]);
            rest.formUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF2"
              )
              .map((form) => form["OMRS form.uuid"]);

            rest.patientProgramStage = "vN61drMkGqO";

            rest.orgUnit = "sUpt0j2GmBD";
            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];
            rest.program = "dWdzxMuKa8Z";
            // rest.program = identifiers.find(i => i.type === 'PROGRAM')?.[
            //   'dhis2 attribute id'
            // ];
            // rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
            const genderMap = {
              M: "male",
              O: "unknown",
              F: "female",
              U: "unknown",
            };
            const {
              orgUnit,
              program,
              optsMap,
              formMaps,
              placeOflivingMap,
              patientProgramStage,
              dhis2PatientNumber,
              openmrsAutoId,
            } = mappingConfig;

            const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findOptsUuid = (uuid) =>
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value?.uuid ||
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value;

            const findOptCode = (optUuid) =>
              optsMap.find((o) => o["value.uuid - External ID"] === optUuid)?.[
                "DHIS2 Option Code"
              ];

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: omrsPatient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: omrsPatient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber) ||
                  findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: omrsPatient.uuid,
              },

              {
                attribute: "T1iX2NuPyqS",
                value: omrsPatient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: omrsPatient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

            const payload = {
              program,
              orgUnit,
              attributes: [...filteredAttr, ...filteredStatusAttr],
            };
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (!patientTei) {
              payload.trackedEntityType = "cHlzCA2MuEF";
              const enrollments = [
                {
                  orgUnit,
                  program,
                  enrolledAt,
                  programStage: patientProgramStage, //'MdTtRixaC1B',
                },
              ];
              payload.attributes.push({
                attribute: "qptKDiv9uPl",
                value: genderMap[omrsPatient.person.gender],
              });
              console.log("create enrollment");
              payload.enrollments = enrollments;
            } else {
              payload.trackedEntity = patientTei.trackedEntity;
              payload.trackedEntityType = patientTei.trackedEntityType;
            }

            return payload;
          };

          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${state.patients.map((patient) => patient.uuid).join(";")}`,
            ],
            program: $.program,
          });

          fn((state) => {
            const findTeiByUuid = (patientUuid) => {
              return state.data.instances.find((tei) => {
                return (
                  tei.attributes.find(
                    (attribute) => attribute.attribute === "AYbfTPYMNJH"
                  )?.value === patientUuid
                );
              });
            };

            state.patientsMapping = state.patients.map((patient) => {
              const patientTei = findTeiByUuid(patient.uuid);

              return buildTeiMapping(patient, patientTei, {
                placeOflivingMap: state.placeOflivingMap,
                orgUnit: state.orgUnit,
                program: state.program,
                patientProgramStage: state.patientProgramStage,
                formMaps: state.formMaps,
                optsMap: state.optsMap,
                dhis2PatientNumber: state.dhis2PatientNumber,
                openmrsAutoId: state.openmrsAutoId,
              });
            });

            return state;
          });

          // Bulk upsert
          create(
            "tracker",
            { trackedEntities: $.patientsMapping },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );

          fn((state) => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              identifiers,
              ...next
            } = state;
            next.patientUuids = patients.map((p) => p.uuid);
            return next;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }
          // Fetch patient encounters
          each(
            $.patientUuids,
            get("encounter", { patient: $.data, v: "full" }).then((state) => {
              state.allEncounters ??= [];
              state.allEncounters.push(
                // v2FormsUuids are for mental health forms
                // ...state.data.results.filter(e =>
                //   state.v2FormUuids.includes(e?.form?.uuid)
                // )
                ...state.data.results.filter((e) =>
                  state.formUuids.includes(e?.form?.uuid)
                )
              );

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map((formUuid) =>
                state.data.results
                  .filter(
                    (e) =>
                      e.auditInfo.dateCreated >= state.cursor &&
                      e?.form?.uuid === formUuid
                  )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters
                .map((pe) => {
                  const isLatestForm = pe.find((e) => {
                    return state.formMaps[e?.form?.uuid]?.syncType === "latest";
                  });
                  if (isLatestForm) {
                    return [isLatestForm];
                  } else {
                    const allPatientEncounter = pe.filter(
                      (e) => state.formMaps[e?.form?.uuid]?.syncType === "all"
                    );
                    return allPatientEncounter;
                  }
                })
                .flat();

              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );

              return state;
            })
          );

          fn((state) => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map((encounter) => {
                const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                  removeNulls(encounter)
                );

                return {
                  uuid,
                  patient: {
                    uuid: patient.uuid,
                    display: patient.display,
                  },
                  obs: obs.map((o) => {
                    return {
                      uuid: o.uuid,
                      concept: o.concept,
                      display: o.display,
                      formFieldPath: o.formFieldPath,
                      value: o.value,
                    };
                  }),
                  form: {
                    uuid: form.uuid,
                    display: form.display,
                    description: form.description,
                    name: form.name,
                  },
                  encounterDatetime,
                };
              });
              console.log(next.encounters.length, "# of new encounters to sync to dhis2");
            } else {
              console.log("No encounters found for cursor: ", next.cursor);
            }
            next.allEncounters = next.allEncounters?.map((encounter) => {
              const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                removeNulls(encounter)
              );

              return {
                uuid,
                patient: {
                  uuid: patient.uuid,
                  display: patient.display,
                },
                obs: obs.map((o) => {
                  return {
                    uuid: o.uuid,
                    concept: o.concept,
                    display: o.display,
                    formFieldPath: o.formFieldPath,
                    value: o.value,
                  };
                }),
                form: {
                  uuid: form.uuid,
                  display: form.display,
                  description: form.description,
                  name: form.name,
                },
                encounterDatetime,
              };
            });

            return next;
          });

      Get-Parent-and-Child-TEIs:
        name: Get Parent and Child TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          const teiByPatientUuid = (patientUuid, teis) => {
            return teis.find((tei) => {
              const omrsPatientUuid = tei.attributes.find(
                ({ attribute }) => attribute === "AYbfTPYMNJH"
              )?.value;

              return omrsPatientUuid === patientUuid;
            });
          };

          fn((state) => {
            // Group encounters by patient UUID
            state.encountersByPatient = state.encounters.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return state;
          });

          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            program: $.program,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${Object.keys(state.encountersByPatient).join(";")}`,
            ],
          });

          fn((state) => {
            state.parentTeis ??= {};
            state.missingParentTeis ??= {};

            Object.keys(state.encountersByPatient).forEach((patientUuid) => {
              const parentTei = teiByPatientUuid(patientUuid, state.data.instances);
              if (parentTei?.trackedEntity) {
                console.log("Parent TEI found:", parentTei.trackedEntity);

                state.parentTeis[patientUuid] = {
                  trackedEntity: parentTei.trackedEntity,
                  attributes: parentTei.attributes,
                  trackedEntityType: parentTei.trackedEntityType,
                };
              } else {
                console.log("Parent TEI Not Found for Patient:", patientUuid);
                state.missingParentTeis[patientUuid] =
                  state.encountersByPatient[patientUuid];
              }
            });

            return state;
          });

          fn((state) => {
            state.ouProgramEncounters = state.encounters.reduce((acc, obj) => {
              const formUuid = obj.form.uuid;
              const patientUuid = obj.patient.uuid;
              const orgUnit = state.formMaps[formUuid].orgUnit;
              const program = state.formMaps[formUuid].programId;
              const key = `${orgUnit}-${program}`;
              if (!acc[key]) {
                acc[key] = {
                  orgUnit,
                  program,
                  patientUuids: [patientUuid],
                };
              }
              if (!acc[key].patientUuids.includes(patientUuid)) {
                acc[key].patientUuids.push(patientUuid);
              }
              return acc;
            }, {});

            return state;
          });

          each(
            (state) => Object.values(state.ouProgramEncounters),
            get("tracker/trackedEntities", (state) => {
              const { orgUnit, program, patientUuids } = state.data;
              return {
                orgUnit,
                program,
                filter: [`AYbfTPYMNJH:IN:${patientUuids.join(";")}`],
                fields: "*,enrollments[*],enrollments[events[*]], relationships[*]",
              };
            }).then(async (state) => {
              await delay(2000);
              return state;
            })
          );

          fn((state) => {
            state.childTeis ??= {};
            state.encounters.forEach((encounter) => {
              const patientUuid = encounter.patient.uuid;
              const tei = teiByPatientUuid(patientUuid, state.data.instances);
              console.log({ instances: state.data.instances.length, tei, patientUuid });
              if (tei?.trackedEntity) {
                console.log("Child TEI found:", tei.trackedEntity);

                state.childTeis[patientUuid] = tei;
              }

              if (!tei && !state.childTeis[patientUuid]) {
                console.log("Child TEI not found for patient:", patientUuid);
                const { attributes, trackedEntityType } = state.parentTeis[patientUuid];
                const program = state.formMaps[encounter.form.uuid].programId;
                const orgUnit = state.formMaps[encounter.form.uuid].orgUnit;

                state.childTeis[patientUuid] = {
                  trackedEntityType,
                  enrollments: [
                    {
                      orgUnit,
                      program,
                      enrolledAt: new Date().toISOString().split("T")[0],
                      attributes: attributes.filter((attribute) =>
                        [
                          "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                        ].includes(attribute.attribute)
                      ),
                    },
                  ],
                  attributes,
                  orgUnit,
                  program,
                };
              }
            });

            return state;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter
          create(
            "tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );

          const findlatestAnswer = (encounters, conceptUuid) => {
            const latestAnswer = encounters.reduce((acc, e) => {
              const answer = e.obs.find((o) => o.concept.uuid === conceptUuid);
              if (answer) {
                const personUuid = answer.person.uuid;
                if (
                  !acc[personUuid] ||
                  new Date(answer.obsDatetime) > new Date(acc[personUuid].obsDatetime)
                ) {
                  acc[personUuid] = { ...answer, formUuid: e.form.uuid };
                }
              }
              return acc;
            }, {});

            return Object.values(latestAnswer);
          };

          fn((state) => {
            const {
              encounters,
              childTeis,
              parentTeis,
              program,
              orgUnit,
              optsMap,
              // Lighten state by removing unused properties
              formMaps,
              optionSetKey,
              eventsMapping,
              formUuids,
              references,
              ...next
            } = state;

            const genderMap = optsMap
              .filter((o) => o["DHIS2 DE UID"] === "qptKDiv9uPl")
              .reduce((acc, obj) => {
                acc[obj["value.display - Answers"]] = obj["DHIS2 Option Code"];
                return acc;
              }, {});

            const latestGenderUpdate = findlatestAnswer(
              encounters,
              "ec42d68d-3e23-43de-b8c5-a03bb538e7c7"
            );

            const genderUpdated = latestGenderUpdate
              .map((answer) => {
                const parentTei = parentTeis[answer?.person?.uuid].trackedEntity;
                const childTei = childTeis[answer?.person?.uuid].trackedEntity;

                const mappings = [];
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "qptKDiv9uPl", //gender
                      value: genderMap[answer.value.display],
                    },
                    {
                      attribute: "AYbfTPYMNJH", //OpenMRS Patient UID to use to upsert TEI
                      value: answer.person.uuid,
                    },
                  ],
                };
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }
                if (childTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntity: childTei,
                    program: formMaps[answer.formUuid].programId,
                    orgUnit: formMaps[answer.formUuid].orgUnit,
                  });
                }
                if (parentTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntity: parentTei,
                    program,
                    orgUnit,
                  });
                }
                return mappings;
              })
              .filter(Boolean)
              .flat();

            const latestEducationUpdate = findlatestAnswer(
              encounters,
              "cc3a5a7a-abfe-4630-b0c0-c1275c6cbb54"
            );

            // console.log({ latestEducationUpdate })
            const educationUpdated = latestEducationUpdate
              .map((answer) => {
                const parentTei = parentTeis[answer?.person?.uuid]?.trackedEntity;
                const childTei = childTeis[answer?.person?.uuid]?.trackedEntity;
                console.log({ parentTei, childTei });
                const mappings = [];
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "Dggll4f9Efj", //education
                      value: optsMap.find(
                        (o) => o["value.display - Answers"] === answer.value.display
                      )?.["DHIS2 Option Code"], //map to DHIS2 Option Code in optsMap
                    },
                  ],
                };
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }

                if (parentTei) {
                  mappings.push({
                    trackedEntity: parentTei,
                    program,
                    orgUnit,
                    ...sharedMapping,
                  });
                }
                if (childTei) {
                  mappings.push({
                    trackedEntity: childTei,
                    program: formMaps[answer.formUuid].programId,
                    orgUnit: formMaps[answer.formUuid].orgUnit,
                    ...sharedMapping,
                  });
                }

                return mappings;
              })
              .filter(Boolean)
              .flat();

            return {
              ...next,
              teisToUpdate: [...genderUpdated, ...educationUpdated],
            };
          });

          fnIf(
            (state) => state.teisToUpdate.length === 0,
            ({ lastRunDateTime }) => ({ lastRunDateTime })
          );

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Update TEIs
          create(
            "tracker",
            { trackedEntities: $.teisToUpdate },
            { params: { async: false, importStrategy: "UPDATE" } }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );
            return answer;
          };

          function f11(encounter, optsMap) {
            if (encounter.form.description.includes("F11-Family Planning Assessment")) {
              const answers = encounter.obs.filter(
                (o) => o.concept.uuid === "30b2d692-6a05-401f-8ede-13e027b8a436"
              );

              const mappingConfig = [
                { dataElement: "DYTLOoEKRas", index: 0 },
                { dataElement: "ddTrzQtQUGz", index: 1 },
                { dataElement: "fuNs3Uzspsm", index: 2 },
              ];

              return mappingConfig.map((config) => {
                if (answers[config.index]) {
                  return {
                    dataElement: config.dataElement,
                    value: optsMap.find(
                      (o) =>
                        o["value.display - Answers"] ===
                        answers[config.index]?.value?.display
                    )?.["DHIS2 Option Code"],
                  };
                }
              });
            }
          }
          function f13(encounter, optsMap) {
            if (encounter.form.description.includes("F13-PNC")) {
              const answers = encounter.obs.filter(
                (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
              );

              // Define mapping configurations
              const mappingConfig = [
                { dataElement: "ErtqJsZINyX", index: 0 },
                { dataElement: "wWAMdsjks50", index: 1 },
                { dataElement: "Dh1ocjojOrC", index: 2 },
                { dataElement: "KR03PHkzVw1", index: 3 },
                { dataElement: "kDA55sgLAwY", index: 4 },
              ];

              // Only add mappings for answers that exist
              return mappingConfig.map((config) => {
                if (answers[config.index] !== undefined) {
                  return {
                    dataElement: config.dataElement,
                    value: optsMap.find(
                      (o) =>
                        o["value.display - Answers"] ===
                        answers[config.index]?.value?.display
                    )?.["DHIS2 Option Code"],
                  };
                }
              });
            }
          }

          function f16(encounter) {
            const answers = encounter.obs.filter(
              (o) => o.concept.uuid === "877aa979-c02f-4890-8156-836d52696f09"
            );
            if (encounter.form.description.includes("F16-Operative Report") && answers) {
              const [date, time] = encounter.encounterDatetime.split("T");
              return [
                {
                  dataElement: "ZQgbPvQ7dWC",
                  value: date,
                },
                {
                  dataElement: "onsyxszD8X7",
                  value: time,
                },
              ];
            }
          }

          function f17(encounter) {
            const answers = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            );

            const mappings = [
              // Always fill with the value 'hour' -> code = 'hour', UID = 'vYF6BoRQlXj'
              {
                dataElement: "vYF6BoRQlXj",
                value: "hour",
              },
            ];
            if (
              encounter.form.description.includes("F17-Surgery admission form") &&
              answers
            ) {
              const [date, time] = encounter.encounterDatetime.split("T");
              mappings.push([
                {
                  dataElement: "DEGa7RaIDTo",
                  value: date,
                },
                {
                  dataElement: "aUSp8oQZIWu",
                  value: date,
                },
                {
                  dataElement: "mDOUf2zzwS2",
                  value: time,
                },
              ]);
            }
            return mappings;
          }

          function f18(encounter, encounters) {
            const isDischarge = findObsByConcept(
              encounter,
              "13cea1c8-e426-411f-95b4-33651fc4325d"
            );

            if (
              encounter.form.description.includes("F18-Surgery discharge form") &&
              isDischarge
            ) {
              const lastAdmission = formEncounters(
                "F17-Surgery admission form",
                encounters
              )
                .at(-1)
                ?.encounterDatetime.replace("+0000", "");
              return [
                {
                  dataElement: "zt3Ocipob8I",
                  value: lastAdmission,
                },
              ];
            }
          }

          function f29(encounter, optsMap) {
            const CONCEPTS = {
              OTHER_SPECIFY: "e08d532b-e56c-43dc-b831-af705654d2dc",
              PRECIPITATING_EVENT_OTHER: "790b41ce-e1e7-11e8-b02f-0242ac130002", // Todo: no used anywhere
            };
            const mappings = [];
            if (encounter.form.description.includes("F29-MHPSS Baseline v2")) {
              mappings.push({
                dataElement: "pN4iQH4AEzk",
                value: findAnswerByConcept(
                  encounter,
                  "22809b19-54ca-4d88-8d26-9577637c184e"
                )
                  ? true
                  : false,
              });

              const priority1 = findObsByConcept(
                encounter,
                "45b39cbf-0fb2-4682-8544-8aaf3e07a744"
              );
              if (priority1 && priority1?.value?.display === "Other") {
                mappings.push({
                  dataElement: "pj5hIE6iyAR",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                });
              }

              const priority2 = findObsByConcept(
                encounter,
                "ee1b7973-e931-494e-a9cb-22b814b4d8ed"
              );
              if (priority2 && priority2?.value?.display === "Other") {
                mappings.push({
                  dataElement: "Em5zvpdd5ha",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                });
              }

              const priority3 = findObsByConcept(
                encounter,
                "92a92f62-3ff6-4944-9ea9-a7af23949bad"
              );
              if (priority3 && priority3?.value?.display === "Other") {
                mappings.push({
                  dataElement: "aWsxYkJR8Ua",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                });
              }

              const precipitatingEvent1 = findObsByConcept(
                encounter,
                "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608"
              );
              const otherValue = encounter.obs.find((o) =>
                o.display.includes("Past / Precipitating Events - Other")
              );

              if (
                precipitatingEvent1 &&
                precipitatingEvent1?.value?.uuid === otherValue?.value?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );

                mappings.push({
                  dataElement: "m8qis4iUOTo",
                  value: opt?.["DHIS2 Option Code"],
                });
              }

              const precipitatingEvent2 = findObsByConcept(
                encounter,
                "54a9b20e-bce5-4d4a-8c9c-e0248a182586"
              );

              if (
                precipitatingEvent2 &&
                precipitatingEvent2?.value?.uuid === otherValue?.value?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );
                mappings.push({
                  dataElement: "mNK6CITsdWD",
                  value: opt?.["DHIS2 Option Code"],
                });
              }

              const precipitatingEvent3 = findObsByConcept(
                encounter,
                "e0d4e006-85b5-41cb-8a21-e013b1978b8b"
              );

              if (
                precipitatingEvent3 &&
                precipitatingEvent3?.value?.uuid === otherValue?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );
                mappings.push({
                  dataElement: "jocqmYW394G",
                  value: opt?.["DHIS2 Option Code"],
                });
              }
            }
            return mappings;
          }

          function f30f29(encounter, allEncounters) {
            if (encounter.form.description.includes("F30-MHPSS Follow-up v2")) {
              const missedSession = (encounter) => {
                if (
                  encounter.obs.find(
                    (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                  )?.value?.display === "No"
                ) {
                  return encounter.encounterDatetime.replace("+0000", "");
                }
                const lastFollowupEncounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F30-MHPSS Follow-up v2") &&
                    e.patient.uuid === encounter.patient.uuid &&
                    e.uuid !== encounter.uuid &&
                    e.obs.find(
                      (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                    )?.value?.display === "No"
                );

                if (lastFollowupEncounter) {
                  return lastFollowupEncounter.encounterDatetime.replace("+0000", "");
                }

                const f29Encounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F29-MHPSS Baseline v2") &&
                    e.patient.uuid === encounter.patient.uuid
                );
                if (f29Encounter) {
                  return f29Encounter.encounterDatetime.replace("+0000", "");
                }
                return undefined;
              };
              const mapping = [
                {
                  dataElement: "jtKIoKducvE",
                  value: missedSession(encounter),
                },
              ];
              return mapping;
            }
          }

          function f32f31(encounter, allEncounters) {
            if (encounter.form.description.includes("F32-mhGAP Follow-up v2")) {
              const missedSession = (encounter) => {
                if (
                  encounter.obs.find(
                    (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                  )?.value?.display === "No"
                ) {
                  return encounter.encounterDatetime.replace("+0000", "");
                }
                const lastFollowupEncounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F32-mhGAP Follow-up v2") &&
                    e.patient.uuid === encounter.patient.uuid &&
                    e.uuid !== encounter.uuid &&
                    e.obs.find(
                      (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                    )?.value?.display === "No"
                );

                if (lastFollowupEncounter) {
                  return lastFollowupEncounter.encounterDatetime.replace("+0000", "");
                }

                const f31Encounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F31-mhGAP Baseline v2") &&
                    e.patient.uuid === encounter.patient.uuid
                );

                if (f31Encounter) {
                  return f31Encounter.encounterDatetime.replace("+0000", "");
                }
              };
              const changeInDiagnosis = (encounter) => {
                const patientUuid = encounter.patient.uuid;
                const previousChangeInDiagnosis = allEncounters
                  .find(
                    (e) =>
                      e.patient.uuid === patientUuid &&
                      e.form.description.includes("F32-mhGAP Follow-up v2") &&
                      encounter.uuid !== e.uuid
                  )
                  ?.obs.find(
                    (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
                  )?.value?.display;

                const currentChangeInDiagnosis = encounter.obs.find(
                  (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
                )?.value?.display;

                if (
                  previousChangeInDiagnosis &&
                  previousChangeInDiagnosis !== currentChangeInDiagnosis
                ) {
                  return true;
                }

                return false;
              };
              const mapping = [
                {
                  dataElement: "fMqEZpiRVZV",
                  value: missedSession(encounter),
                },
                {
                  dataElement: "XBVRRpgkEvE",
                  value: changeInDiagnosis(encounter),
                },
              ];
              return mapping;
            }
          }

          function f33f34(encounter, allEncounters) {
            if (
              encounter.form.description.includes("F33-MHPSS Closure v2") ||
              encounter.form.description.includes("F34-mhGAP Closure v2")
            ) {
              const lastScore = encounter.obs.find(
                (o) => o.concept.uuid === "90b3d09c-d296-44d2-8292-8e04377fe027"
              )?.value;

              const filterOutScore = allEncounters.filter((e) => {
                const obs = e.obs.find(
                  (o) => o.concept.display === "Mental Health Outcome Scale"
                );
                return e.uuid !== encounter.uuid && obs && obs?.value !== 0;
              });

              const firstScore = filterOutScore
                .sort((a, b) => {
                  return new Date(a.encounterDatetime) - new Date(b.encounterDatetime);
                })
                .at(0)
                ?.obs.find(
                  (o) => o.concept.display === "Mental Health Outcome Scale"
                )?.value;

              return {
                dataElement: "b8bjS7ah8Qi",
                value: lastScore - firstScore,
              };
            }
          }

          const findDataValue = (encounter, dataElement, metadataMap) => {
            const { optsMap, optionSetKey, form } = metadataMap;
            const [conceptUuid, questionId] =
              form.dataValueMap[dataElement]?.split("-rfe-");
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            const isObjectAnswer = answer && typeof answer.value === "object";
            const isStringAnswer = answer && typeof answer.value === "string";

            if (isStringAnswer) {
              return answer.value;
            }

            if (
              isObjectAnswer &&
              conceptUuid === "722dd83a-c1cf-48ad-ac99-45ac131ccc96" &&
              dataElement === "pN4iQH4AEzk"
            ) {
              console.log("Yes done by psychologist..");
              return "" + answer.value.uuid === "278401ee-3d6f-4c65-9455-f1c16d0a7a98";
            }

            if (
              isObjectAnswer &&
              conceptUuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9" &&
              dataElement === "G0hLyxqgcO7"
            ) {
              console.log("True only question detected..", dataElement);
              return answer.value.uuid === "681cf0bc-5213-492a-8470-0a0b3cc324dd"
                ? "true"
                : undefined;
            }

            if (isObjectAnswer) {
              const optionKey = questionId
                ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
                : `${encounter.form.uuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              if (["FALSE", "No"].includes(matchingOption)) return "false";
              if (["TRUE", "Yes"].includes(matchingOption)) return "true";

              return matchingOption;
            }

            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );

            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }

            return "";
          };

          const formEncounters = (formDescription, encounters) => {
            return encounters.filter((e) => e.form.description.includes(formDescription));
          };

          // Prepare DHIS2 data model for create events
          fn((state) => {
            const handleMissingRecord = (data, state) => {
              const { uuid, display } = data.patient;

              console.log(uuid, "Patient is missing trackedEntity or enrollment");

              state.missingRecords ??= {};
              state.missingRecords[uuid] ??= {
                encounters: [],
                patient: display,
              };

              state.missingRecords[uuid].encounters.push(data.uuid);
            };

            state.eventsMapping = state.encounters
              .map((encounter) => {
                const form = state.formMaps[encounter.form.uuid];
                if (!form?.dataValueMap) {
                  return null;
                }
                const { trackedEntity, enrollment, events } =
                  state.childTeis[encounter.patient.uuid] || {};

                if (!trackedEntity || !enrollment) {
                  handleMissingRecord(encounter, state);
                  return null;
                }
                let formDataValues = Object.keys(form.dataValueMap)
                  .map((dataElement) => {
                    const value = findDataValue(encounter, dataElement, {
                      optsMap: state.optsMap,
                      optionSetKey: state.optionSetKey,
                      form,
                    });

                    return { dataElement, value };
                  })
                  .filter(
                    ({ dataElement, value }) =>
                      value &&
                      !["pj5hIE6iyAR", "KjgDauY9v4J", "DYTLOoEKRas"].includes(dataElement)
                  );

                const f16Mapping = f16(encounter);
                const f17Mapping = f17(encounter);
                const f18Mapping = f18(encounter, state.encounters);
                const f13Mapping = f13(encounter, state.optsMap);
                const f11Mapping = f11(encounter, state.optsMap);
                const f29Mapping = f29(encounter, state.optsMap);
                const f30f29Mapping = f30f29(encounter, state.allEncounters);
                const f32f31Mapping = f32f31(encounter, state.allEncounters);
                const f33f34Mapping = f33f34(encounter, state.allEncounters);

                const customMapping = [
                  f11Mapping,
                  f13Mapping,
                  f18Mapping,
                  f16Mapping,
                  f17Mapping,
                  f29Mapping,
                  f30f29Mapping,
                  f32f31Mapping,
                  f33f34Mapping,
                ]
                  .filter(Boolean) // Only include non-empty mappings
                  .flat(); // flattening the array

                return {
                  event: events?.find((e) => e.programStage === form.programStage)?.event,
                  program: state.formMaps[encounter.form.uuid]?.programId,
                  orgUnit: state.formMaps[encounter.form.uuid]?.orgUnit,
                  trackedEntity,
                  enrollment,
                  occurredAt: encounter.encounterDatetime.replace("+0000", ""),
                  programStage: form.programStage,
                  dataValues: [...formDataValues, ...customMapping],
                };
              })
              .filter(Boolean);

            return state;
          });

      Create-TEIs-Relationship:
        name: Create TEIs Relationship
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          fn((state) => {
            state.relationshipsMapping = Object.keys(state.childTeis)
              .map((uuid) => {
                const childTei = state.childTeis[uuid].trackedEntity;
                const parentTei = state.parentTeis[uuid].trackedEntity;

                if (childTei != parentTei) {
                  return {
                    from: {
                      trackedEntityInstance: {
                        trackedEntityInstance: parentTei,
                      },
                    },
                    to: {
                      trackedEntityInstance: {
                        trackedEntityInstance: childTei,
                      },
                    },
                    relationshipType: "cJJTZ51EK24", //TODO: Need to change this hardcoded id, because it will be different for d/t programs
                  };
                }
              })
              .filter(Boolean);
            return state;
          });
          // Check if relationship exist
          each(
            $.relationshipsMapping,
            get("tracker/relationships", {
              trackedEntity: $.data.from.trackedEntityInstance.trackedEntityInstance,
            }).then((state) => {
              const relationship = state.references.at(-1);
              const toTei = relationship.to.trackedEntityInstance.trackedEntityInstance;
              const hasRelationship = state.data.instances.find(
                (r) => r.to.trackedEntity.trackedEntity === toTei
              );
              state.relationshipsToCreate ??= [];
              if (!hasRelationship) {
                state.relationshipsToCreate.push(relationship);
              }
              return state;
            })
          );

          // Creating relationship between parent and child tei
          each($.relationshipsToCreate, create("relationships", $.data));

      Upsert-Child-TEIs:
        name: Upsert Child TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          create(
            "tracker",
            { trackedEntities: (state) => Object.values(state.childTeis) },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );

          fn((state) => {
            state.upsertedTeis =
              state.data.bundleReport.typeReportMap.TRACKED_ENTITY.objectReports.map(
                (report) => report.uid
              );
            return state;
          });

          each($.upsertedTeis, get(`tracker/trackedEntities/${$.data}`).then(state => {
            const { trackedEntity, enrollments, attributes } = state.data || {};

            const patientUuid = attributes.find(a => a.attribute === 'AYbfTPYMNJH').value

            state.childTeis ??= {};
            state.childTeis[patientUuid] = {
              trackedEntity,
              events: enrollments?.[0]?.events,
              enrollment: enrollments?.[0]?.enrollment,
            };

            return state;
          }))
    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Mappings->Upsert-TEIs:
        source_job: Mappings
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Get-Encounters->Get-Parent-and-Child-TEIs:
        source_job: Get-Encounters
        target_job: Get-Parent-and-Child-TEIs
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters.length > 0

        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors

        enabled: true
      Get-Parent-and-Child-TEIs->Upsert-Child-TEIs:
        source_job: Get-Parent-and-Child-TEIs
        target_job: Upsert-Child-TEIs
        condition_type: js_expression
        condition_label: has-child-parent-teis
        condition_expression: |
          Object.keys(state?.childTeis)?.length > 0 && Object.keys(state?.parentTeis)?.length > 0

        enabled: true
      Upsert-Child-TEIs->Create-TEIs-Relationship:
        source_job: Upsert-Child-TEIs
        target_job: Create-TEIs-Relationship
        condition_type: on_job_success
        enabled: true
      Create-TEIs-Relationship->Event-Mappings:
        source_job: Create-TEIs-Relationship
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-child-teis
        condition_expression: |
          state.childTeis && !state.errors

        enabled: true
  wf3-omrs-dhis2:
    name: wf3-omrs-dhis2
    jobs:
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.3.0'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body: |
          const isValidUUID = id => {
            if (!id || typeof id !== 'string') return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get('mosul-metadata-mappings-staging').then(state => {
            state.optsMap = state.data
              .filter(i => i.key.includes('optsMap-value-'))
              .map(i => i.value);

            state.identifiers = state.data
              .filter(i => i.key.includes('identifiers-value-'))
              .map(i => i.value);
            state.syncedAt = state.data.find(i => i.key === 'syncedAt')?.value;
            state.formMetadata = state.data.find(i => i.key === 'formMetadata')?.value; // filter form maps where formmap.workflow == "WF3"
            state.placeOflivingMap = state.data.find(i => i.key === 'placeOflivingMap')?.value;
            state.sourceFile = state.data.filter(i => i.key === 'sourceFile')?.[0]?.value;
            state.fileDateModified = state.data.filter(
              i => i.key === 'fileDateModified'
            )?.[0]?.value;
            state.optionSetKey = state.data.filter(
              i => i.key === 'optionSetKey'
            )?.[0]?.value;
            state.formMaps = state.data.find(i => i.key === 'formMaps')?.value;
            delete state.data
            delete state.references
            return state;
          });


          fn(state => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                form =>
                  isValidUUID(form['OMRS form.uuid']) &&
                  form['OMRS Form Version'] === 'v4-2025'
              )
              .map(form => form['OMRS form.uuid']);
            rest.formUuids = formMetadata
              .filter(form => isValidUUID(form['OMRS form.uuid']) &&
                form['Workflow'] === 'WF3')
              .map(form => form['OMRS form.uuid']);

            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];

            rest.orgUnit = "sUpt0j2GmBD"


            rest.program = "dWdzxMuKa8Z"

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              i => i.type === 'DHIS2_PATIENT_NUMBER'
            )?.['omrs identifierType']; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find(i => i.type === 'OPENMRS_AUTO_ID')?.[
              'omrs identifierType'
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });


          fn(state => {
            state.genderOptions = state.optsMap
              .filter(o => o['OptionSet name'] === 'Sex - Patient')
              .reduce((acc, value) => {
                acc[value['value.uuid - External ID']] = value['DHIS2 Option Code'];
                return acc;
              }, {});

            return state;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Fetch all encounters
          http
            .get('/ws/fhir2/R4/Encounter', {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then(state => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find(l => l.relation === 'next')
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split('/openmrs')[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then(state => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );



          fn(state => {
            console.log(
              'Total # of encounters fetched: ',
              state.allResponse?.entry?.length
            );

            state.patientUuids = [
              ...new Set(
                state.allResponse?.entry?.map(p =>
                  p.resource.subject.reference.replace('Patient/', '')
                )
              ),
            ];

            return state;
          });

          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          // Fetch patient encounters
          each(
            $.patientUuids,
            get('encounter', { patient: $.data, v: 'full' }).then(state => {

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map(formUuid =>
                state?.data?.results.filter(
                  e =>
                    e.auditInfo.dateCreated >= state.cursor &&
                    e?.form?.uuid === formUuid
                )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters.map(e => e[0]).filter(e => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500)

              return state;
            })
          );

          fn(state => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map(
                ({ uuid, patient, obs, form, encounterDatetime }) => ({
                  uuid,
                  patient,
                  obs,
                  form,
                  encounterDatetime,
                })
              );
              console.log(next.encounters.length, '# of new encounters to sync to dhis2');
            } else {
              console.log('No encounters found for cursor: ', next.cursor);
            }


            // Group encounters by patient UUID
            next.encountersByPatient = next.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return next;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter create(
          create("tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );
          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";

          const processAnswer = (
            answer,
            conceptUuid,
            dataElement,
            optsMap,
            optionSetKey
          ) => {
            if (typeof answer.value === "object") {
              const optionKey = `${answer.formUuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              // console.log(`matchingOption value: "${matchingOption}" for`);
              // console.log({
              //   optionKey,
              //   conceptUid: answer.concept.uuid,
              //   'answer.value.uid': answer.value.uuid,
              //   'answer.value.display': answer.value.display,
              //   matchingOption,
              //   matchingOptionSet,
              // });

              if (matchingOption === "FALSE" || matchingOption === "No") {
                return "false";
              }
              if (matchingOption === "TRUE" || matchingOption === "Yes") {
                return "true";
              }

              return matchingOption || "";
            }

            return answer.value;
          };

          const processNoAnswer = (encounter, conceptUuid, dataElement) => {
            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );
            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2

            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }
            return "";
          };

          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) =>
            encounter.obs.find((o) => o.concept.uuid === conceptUuid);

          // Helper function to process dataValues from an encounter
          function processEncounterDataValues(encounter, form, state) {
            return Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const conceptUuid = form.dataValueMap[dataElement];
                const obsAnswer = encounter.obs.find(
                  (o) => o.concept.uuid === conceptUuid
                );

                const answer = {
                  ...obsAnswer,
                  formUuid: encounter.form.uuid,
                };
                const value = answer
                  ? processAnswer(
                    answer,
                    conceptUuid,
                    dataElement,
                    state.optsMap,
                    state.optionSetKey
                  )
                  : processNoAnswer(encounter, conceptUuid, dataElement);

                return { dataElement, value };
              })
              .filter((d) => d);
          }

          fn((state) => {
            state.eventsMapping = Object.entries(state.encountersByPatient)
              .map(([patientUuid, encounters]) => {
                // Skip if we don't have exactly 2 encounters
                if (encounters.length !== 2) return null;


                // Get the forms for both encounters
                const form1 = state.formMaps[encounters[0].form.uuid];
                const form2 = state.formMaps[encounters[1].form.uuid];

                // Skip if either form doesn't have dataValueMap
                if (!form1?.dataValueMap || !form2?.dataValueMap) return null;
                const f8Encounter = encounters.find(e => e.form.uuid === f08Form)
                const obsDatetime = findObsByConcept(f8Encounter, '7f00c65d-de60-467a-8964-fe80c7a85ef0')?.obsDatetime

                const datePart = obsDatetime.substring(0, 10);
                const timePart = obsDatetime.substring(11, 19);
                const f8Mapping = [
                  {
                    dataElement: "yprMS34o8s3",
                    value: f8Encounter.encounterDatetime
                  },
                  {
                    dataElement: "iQio7NYSA3m",
                    value: datePart
                  },
                  {
                    dataElement: "yprMS34o8s3",
                    value: timePart
                  }
                ]


                const tei = state.TEIs[patientUuid];
                console.log({ tei, patientUuid })

                const attributeMap = {
                  "Lg1LrNf9LQR": "qptKDiv9uPl",
                  "OVo3FxLURtH": "k26cdlS78i9",
                  "f3n6kIB9IbI": "Rv8WM2mTuS5",
                  "oc9zlhOoWmP": "YUIQIA2ClN6",
                  "DbyD9bbGIvE": "Qq6xQ2s6LO8",
                  "fiPFww1viBB": "rBtrjV1Mqkz",
                  "FsL5BjQocuo": "Xvzc9e0JJmp"
                };

                const f9Mapping = Object.entries(attributeMap)
                  .map(([dataElement, attributeId]) => {
                    const value = tei?.attributes?.find(attr => attr.attribute === attributeId)?.value;

                    return { dataElement, value };
                  })
                  .filter(Boolean);

                // Combine dataValues from both encounters
                const formDataValues = [
                  ...f8Mapping,
                  ...f9Mapping,
                  ...processEncounterDataValues(encounters[0], form1, state),
                  ...processEncounterDataValues(encounters[1], form2, state),
                ].filter(d => d.value)

                // Use properties from the first encounter for the event metadata
                // (or choose which encounter to use for each field)
                return {
                  program: form1.programId,
                  orgUnit: form1.orgUnit,
                  occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                  programStage: form1.programStage,
                  dataValues: formDataValues,
                  trackedEntityInstance: patientUuid,
                };
              })
              .filter(Boolean);

            return state;
          });

      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Enable test mode
          const testMode = false

          cursor($.lastRunDateTime || $.manualCursor || '2025-03-20T06:01:24.000Z');

          cursor('today', {
            key: 'lastRunDateTime',
            format: c => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({ q: 'IQ', v: 'full', includeVoide: true, limit: '100' });

          fn(state => {
            const { cursor, data, lastRunDateTime } = state;
            console.log('Filtering patients since cursor:', cursor);

            const patients = data.results.filter(({ auditInfo }) => {
              const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
              return lastModified > cursor;
            });
            console.log('# of patients to sync to dhis2 ::', patients.length);
            console.log(
              'uuids of patients to sync to dhis2 ::',
              patients.map(p => p.uuid)
            );

            return { cursor, lastRunDateTime, patients, testMode };
          });

          // get patient - log number of patient that are fetched

          // get collections neccessary for patient mapping

          // map patient here - this will be passed down to next step

          // delete the initial patient object and only pass on the mapped one

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildPatientsUpsert = (state, patient, isNewPatient) => {
            const { placeOflivingMap, genderOptions } = state;
            const dateCreated = patient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find(i => i.identifierType.uuid === targetUuid)?.identifier;

            const enrollments = [
              {
                orgUnit: state.orgUnit,
                program: state.program, // searching by MH program but change this EMR
                programStage: state.patientProgramStage, //'MdTtRixaC1B',
                enrollmentDate: dateCreated,
              },
            ];

            const findOptsUuid = uuid =>
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value
                ?.uuid ||
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value;

            const findOptCode = optUuid =>
              state.optsMap.find(o => o['value.uuid - External ID'] === optUuid)?.[
                'DHIS2 Option Code'
              ];

            const patientMap = state.formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map(d => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: 'fa7uwpCKIwa',
                value: patient.person?.names[0]?.givenName,
              },
              {
                attribute: 'Jt9BhFZkvP2',
                value: patient.person?.names[0]?.familyName,
              },
              {
                attribute: 'P4wdYGkldeG', //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(patient.identifiers, state.dhis2PatientNumber) ||
                  findIdentifierByUuid(patient.identifiers, state.openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: 'ZBoxuExmxcZ', //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(patient.identifiers, state.openmrsAutoId),
              },
              {
                attribute: 'AYbfTPYMNJH', //"OpenMRS Patient UID"
                value: patient.uuid,
              },
              {
                attribute: 'qptKDiv9uPl',
                value: genderOptions[patient.person.gender],
              },
              {
                attribute: 'T1iX2NuPyqS',
                value: patient.person.age,
              },
              {
                attribute: 'WDp4nVor9Z7',
                value: patient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: 'rBtrjV1Mqkz', //Place of living
                value: placeOflivingMap[patient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter(a => a.value);
            const filteredStatusAttr = statusAttrMaps.filter(a => a.value);
            //console.log('standardAttr ::', JSON.stringify(standardAttr, null,2))
            //console.log('filteredAttr ::', JSON.stringify(filteredAttr, null,2))

            const payload = {
              query: {
                ou: state.orgUnit,
                program: state.program,
                filter: [`AYbfTPYMNJH:Eq:${patient.uuid}`], //upsert on omrs.patient.uid
              },
              data: {
                program: state.program,
                orgUnit: state.orgUnit,
                trackedEntityType: 'cHlzCA2MuEF',
                attributes: [...filteredAttr, ...filteredStatusAttr],
              },
            };

            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (isNewPatient) {
              console.log('create enrollment');
              payload.data.enrollments = enrollments;
            }

            return payload;
          };

          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          each(
            $.patients,
            get(
              'tracker/trackedEntities',
              {
                orgUnit: $.orgUnit,
                filter: [`AYbfTPYMNJH:Eq:${$.data?.uuid}`],
                program: $.program,
              },
              {},
              async state => {
                const patient = state.references.at(-1);
                console.log(patient.uuid, 'patient uuid');

                const isNewPatient = state.data.instances.length === 0;

                state.patientsUpsert ??= [];
                state.patientsUpsert.push(
                  buildPatientsUpsert(state, patient, isNewPatient)
                );
                await delay(2000);
                return state;
              }
            )
          );

          // Upsert TEIs to DHIS2
          each(
            $.patientsUpsert,
            upsert('trackedEntityInstances', $.data.query, $.data.data)
          );
          fn(state => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              genderOptions,
              identifiers,
              ...next
            } = state;

            next.patientUuids = patients.map(p => p.uuid);
            return next;
          });

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          //TODO: Group the encounters by patient and then get the TEI for each patient
          each(
            $.encounters,
            get('tracker/trackedEntities', state => ({
              orgUnit: $.orgUnit,
              program: $.program,
              // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
            })).then(async state => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, 'Encounter patient uuid');

              const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
              if (trackedEntity && enrollments) {
                state.TEIs ??= {};
                state.TEIs[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments[0]?.events,
                  enrollment: enrollments[0]?.enrollment,
                  attributes
                };
              }

              await delay(2000);
              return state;
            })
          );

      Get-Tie:
        name: Get Tie
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"
          //TODO: Group the encounters by patient and then get the TEI for each patient
          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');

            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }

            await delay(2000);
            return state;
          })

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Get-Patients->Get-Mappings-from-Collection:
        source_job: Get-Patients
        target_job: Get-Mappings-from-Collection
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state?.encounters?.length > 0

        enabled: true
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Mappings-from-Collection->Upsert-TEIs:
        source_job: Get-Mappings-from-Collection
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Get-Tie->Custom-Logic-for-Events:
        source_job: Get-Tie
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: test-mode
        condition_expression: |
          state.testMode

        enabled: true
  wf3-omrs-dhis2-138:
    name: wf3-omrs-dhis2-138
    jobs:
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.3.0'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body: |
          const isValidUUID = (id) => {
            if (!id || typeof id !== "string") return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);
            state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
            state.formMetadata = state.data.find((i) => i.key === "formMetadata")?.value;
            state.placeOflivingMap = state.data.find(
              (i) => i.key === "placeOflivingMap"
            )?.value;
            state.sourceFile = state.data.filter(
              (i) => i.key === "sourceFile"
            )?.[0]?.value;
            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;
            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            // TODO: Remove state.optionSetKey, when needed
            // Build from state.formMaps
            state.optionSetKey = state.data.filter(
              (i) => i.key === "optionSetKey"
            )?.[0]?.value;

            delete state.data;
            delete state.references;
            return state;
          });

          fn((state) => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) &&
                  form["OMRS Form Version"] === "v4-2025"
              )
              .map((form) => form["OMRS form.uuid"]);
            rest.formUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF3"
              )
              .map((form) => form["OMRS form.uuid"]);

            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];

            rest.orgUnit = "sUpt0j2GmBD";

            rest.program = "dWdzxMuKa8Z";

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
          // Fetch patient encounters
          each(
            $.patientUuids,
            get("encounter", { patient: $.data, v: "full" }).then((state) => {
              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map((formUuid) =>
                state?.data?.results
                  .filter(
                    (e) =>
                      e.auditInfo.dateCreated >= state.cursor &&
                      e?.form?.uuid === formUuid
                  )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              // Why we only keep the latest one form encounter?
              const encounters = filteredEncounters.map((e) => e[0]).filter((e) => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500);

              return state;
            })
          );

          fn((state) => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map((encounter) => {
                const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                  removeNulls(encounter)
                );

                return {
                  uuid,
                  patient: {
                    uuid: patient.uuid,
                    display: patient.display,
                  },
                  obs: obs.map((o) => {
                    return {
                      uuid: o.uuid,
                      concept: o.concept,
                      display: o.display,
                      formFieldPath: o.formFieldPath,
                      value: o.value,
                    };
                  }),
                  form: {
                    uuid: form.uuid,
                    display: form.display,
                    description: form.description,
                    name: form.name,
                  },
                  encounterDatetime,
                };
              });
              console.log(next.encounters.length, "# of new encounters to sync to dhis2");
            } else {
              console.log("No encounters found for cursor: ", next.cursor);
            }

            return next;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter create(
          create(
            "tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";
          const f23Form = "1b14d9e6-0569-304e-9d4e-f9df40762dff";
          const f24Form = "399cf41a-ea2a-39e3-8758-508e79729656";
          const f25Form = "c4db716a-f9d0-35df-a589-d5caf2dfb106";
          const f26Form = "afcf2993-233e-385b-8030-74a8b475eccd";
          const f27Form = "ac97ec76-5647-3153-b4e1-2eceae121e50";
          const f28Form = "893ef4b7-5ad1-39e7-8515-eab308ccd636";

          const encountersFormPairs = (encounters, formsUuids) => {
            const { f08Form, f09Form, f23Form, f27Form, f28Form, f25Form, f26Form } =
              formsUuids;
            const f8f9Encounters = encounters.filter(
              (e) => e.form.uuid === f08Form || e.form.uuid === f09Form
            );
            const f23f24Encounters = encounters.filter(
              (e) => e.form.uuid === f23Form || e.form.uuid === f24Form
            );
            const f25f26Encounters = encounters.filter(
              (e) => e.form.uuid === f25Form || e.form.uuid === f26Form
            );
            const f27f28Encounters = encounters.filter(
              (e) => e.form.uuid === f27Form || e.form.uuid === f28Form
            );

            return {
              f8f9Encounters,
              f23f24Encounters,
              f27f28Encounters,
              f25f26Encounters,
            };
          };

          const MILLISECONDS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;
          const calculateAge = (dob) =>
            Math.floor((new Date() - new Date(dob)) / MILLISECONDS_PER_YEAR);

          const teiAge = (tei) => {
            let age = tei?.attributes?.find(
              (attr) => attr.attribute === "T1iX2NuPyqS"
            )?.value;

            if (!age) {
              const birthdate = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;
              age = calculateAge(birthdate);
            }
            return age;
          };

          function f8(encounter) {
            const obsDatetime = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            )?.obsDatetime;

            const datePart = obsDatetime.substring(0, 10);
            const timePart = obsDatetime.substring(11, 19);
            return [
              {
                dataElement: "yprMS34o8s3",
                value: encounter.encounterDatetime,
              },
              {
                dataElement: "iQio7NYSA3m",
                value: datePart,
              },
              {
                dataElement: "yprMS34o8s3",
                value: timePart,
              },
            ];
          }

          function f27(encounter) {
            const admissionDate = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            )?.value;

            return [
              {
                dataElement: "eYvDzr2m8f5",
                value: admissionDate,
              },
            ];
          }
          function f23(encounter) {
            // Define concept mappings object for cleaner reference
            const CONCEPT_ID = "f587c6a3-6a71-48ae-83b2-5e2417580b6f";

            const conditions = [
              {
                // 'Neonatal infection in previous pregnancy' is selected in OMRS
                dataElement: "H9noxo3e7ox",
                valueId: "09d6bb71-b061-4cae-85f3-2ff020a10c92",
              },
              {
                // 'Mother got antibiotics during delivery/post-partum ' is selected in OMRS
                dataElement: "GfN1TtpqDoJ",
                valueId: "3764bd79-9ae2-478a-88e7-51adc0a8a2e3",
              },
              {
                //'Infection in other baby if multiple pregnancy' is selected in OMRS
                dataElement: "WS1p4xgbZqU",
                valueId: "95d55453-060b-43a2-b4a0-11848dd9ac72",
              },
              {
                //'Maternal fever during labour' is selected in OMRS
                dataElement: "WX19iDuB4Dj",
                valueId: "890f4bdb-91bc-484c-a9cf-17f5068b0507",
              },
              {
                // 'Rupture of membranes ≥18h' is selected in OMRS
                dataElement: "eLKs6GUHJdS",
                valueId: "28d10ce0-7f72-4654-834d-64fa37ad8e85",
              },
              {
                // 'Pre-labour rupture of membranes <18h' is selected in OMRS
                dataElement: "hCfngwimBjX",
                valueId: "cf48d000-a741-44e0-81cb-a51f88595e41",
              },
              {
                // 'Smelling/cloudy amniotic fluid' is selected in OMRS
                dataElement: "qc7ubAwULxs",
                valueId: "49829d18-22c9-404c-a79a-49ed6b21d2be",
              },
            ];

            // Map through conditions and create final mapping
            return conditions.map((condition) => ({
              dataElement: condition.dataElement,
              value: findByConceptAndValue(encounter, CONCEPT_ID, condition.valueId)
                ? true
                : false,
            }));
          }

          function teiAttributeMapping(tei, attributeMap) {
            const attrMapping = Object.entries(attributeMap)
              .map(([dataElement, attributeId]) => {
                const value = tei?.attributes?.find(
                  (attr) => attr.attribute === attributeId
                )?.value;

                return { dataElement, value };
              })
              .filter(Boolean);

            return attrMapping;
          }

          const findObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );
            return answer;
          };

          const findByConceptAndValue = (encounter, conceptUuid, value) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true) &&
                o.value.uuid === value
            );
            return answer;
          };

          const findDataValue = (encounter, dataElement, metadataMap) => {
            const { optsMap, optionSetKey, form } = metadataMap;
            const [conceptUuid, questionId] =
              form.dataValueMap[dataElement]?.split("-rfe-");
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            const isObjectAnswer = answer && typeof answer.value === "object";
            const isStringAnswer = answer && typeof answer.value === "string";

            if (isStringAnswer) {
              return answer.value;
            }

            if (isObjectAnswer) {
              const optionKey = questionId
                ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
                : `${encounter.form.uuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              if (["FALSE", "No"].includes(matchingOption)) return "false";
              if (["TRUE", "Yes"].includes(matchingOption)) return "true";

              return matchingOption;
            }

            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );

            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }

            return "";
          };

          const buildDataValues = (encounter, form, mappingConfig) => {
            const { optsMap, optionSetKey, tei } = mappingConfig;
            let formMapping = [];
            // F08 Form Encounter Mapping
            if (encounter.form.uuid === f08Form) {
              const f8Mapping = f8(encounter);
              formMapping.push(...f8Mapping);
            }

            // F09 Form Encounter Mapping
            if (encounter.form.uuid === f09Form) {
              const attributeMap = {
                Lg1LrNf9LQR: "qptKDiv9uPl",
                OVo3FxLURtH: "k26cdlS78i9",
                f3n6kIB9IbI: "Rv8WM2mTuS5",
                oc9zlhOoWmP: "YUIQIA2ClN6",
                DbyD9bbGIvE: "Qq6xQ2s6LO8",
                fiPFww1viBB: "rBtrjV1Mqkz",
                FsL5BjQocuo: "Xvzc9e0JJmp",
              };
              const f09Mapping = teiAttributeMapping(tei, attributeMap);
              formMapping.push(...f09Mapping);
            }

            // F23 Form Encounter Mapping
            if (encounter.form.uuid === f23Form) {
              const f23Mapping = f23(encounter);
              formMapping.push(...f23Mapping);
            }

            // F24 Form Encounter Mapping
            if (encounter.form.uuid === f24Form) {
              const attributeMap = {
                Hww0CNYYt3E: "qptKDiv9uPl",
                // Z7vMFdnQxpE: "WDp4nVor9Z7",
                // L97SmAK11DN: "T1iX2NuPyqS",
                yE0dIWW0TXP: "rBtrjV1Mqkz",
              };
              const attributeMapping = teiAttributeMapping(tei, attributeMap);

              const dob = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;

              if (dob) {
                let ageInDays = calculateAge(dob) * 365;
                attributeMapping.push({
                  dataElement: "Z7vMFdnQxpE",
                  value: ageInDays,
                });
              }
              if (!dob) {
                const age = tei?.attributes?.find(
                  (attr) => attr.attribute === "T1iX2NuPyqS"
                )?.value;

                const ageInMonths = age * 12;

                attributeMapping.push({
                  dataElement: "L97SmAK11DN",
                  value: ageInMonths,
                });
              }

              formMapping.push(...attributeMapping);
            }

            if (encounter.form.uuid === f26Form) {
              const attributeMap = {
                eDuqRYx3wLx: "qptKDiv9uPl",
                d7wOfzPBbQD: "T1iX2NuPyqS",
                y9pK9sVcbU9: "k26cdlS78i9",
                // b7z6xIpzkim: "",
                CDuiRuOcfzj: "YUIQIA2ClN6",
                JMhFzB97fcS: "Qq6xQ2s6LO8",
                Nd43pz1Oo62: "rBtrjV1Mqkz",
              };
              const attributeMapping = teiAttributeMapping(tei, attributeMap);

              const dob = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;

              if (dob) {
                let ageInDays = calculateAge(dob) * 365;
                attributeMapping.push({
                  dataElement: "b7z6xIpzkim",
                  value: ageInDays,
                });
              }

              formMapping.push(...attributeMapping);
            }

            // F27 Form Encounter Mapping
            if (encounter.form.uuid === f27Form) {
              const f27Mapping = f27(encounter);
              formMapping.push(...f27Mapping);
            }

            // F28 Form Encounter Mapping
            if (encounter.form.uuid === f28Form) {
              const attributeMap = {
                WP5vr8KB2lH: "qptKDiv9uPl",
                Y7qzoa4Qaiz: "YUIQIA2ClN6",
                XCUd9xOGXkn: "Qq6xQ2s6LO8",
                onKT21rxH6Z: "rBtrjV1Mqkz",
                sCKCNreiqEA: "Xvzc9e0JJmp",
              };
              const attributeMapping = teiAttributeMapping(tei, attributeMap);

              const f28Mapping = [
                {
                  dataElement: "NWOnMq8h4w1",
                  value: teiAge(tei),
                },
              ];
              formMapping.push(...attributeMapping, ...f28Mapping);
            }

            const dataValuesMapping = Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const value = findDataValue(encounter, dataElement, {
                  optsMap,
                  optionSetKey,
                  form,
                });

                return { dataElement, value };
              })
              .filter((d) => d.value);

            const combinedMapping = [...dataValuesMapping, ...formMapping].filter(
              Boolean
            );

            return combinedMapping;
          };

          fn((state) => {
            // Group encounters by patient UUID
            const encountersByPatient = state.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            state.eventsMapping = Object.entries(encountersByPatient)
              .map(([patientUuid, patientEncounters]) => {
                const pairedEncounters = Object.values(
                  encountersFormPairs(patientEncounters, {
                    f08Form,
                    f09Form,
                    f23Form,
                    f27Form,
                    f28Form,
                    f25Form,
                    f26Form,
                  })
                );

                return pairedEncounters
                  .filter((encounters) => encounters.length === 2)
                  .map((encounters) => {
                    // Get the forms for both encounters
                    const form1 = state.formMaps[encounters[0].form.uuid];
                    const form2 = state.formMaps[encounters[1].form.uuid];

                    // Skip if either form doesn't have dataValueMap
                    if (!form1?.dataValueMap || !form2?.dataValueMap) {
                      return null;
                    }

                    const tei = state.TEIs[patientUuid];

                    const dataValues = encounters
                      .map((encounter) => {
                        const form = state.formMaps[encounter.form.uuid];
                        if (!form?.dataValueMap) {
                          return null;
                        }

                        return buildDataValues(encounter, form, {
                          optsMap: state.optsMap,
                          optionSetKey: state.optionSetKey,
                          tei,
                        });
                      })
                      .flat()
                      .filter((d) => d.value);

                    return {
                      program: form1.programId,
                      orgUnit: form1.orgUnit,
                      occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                      programStage: form1.programStage,
                      dataValues,
                      trackedEntityInstance: patientUuid,
                    };
                  })
                  .filter(Boolean);
              })
              .flat()
              .filter(Boolean);

            return state;
          });

          fn((state) => {
            return {
              eventsMapping: state.eventsMapping,
            };
          });

      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }
          cursor($.lastRunDateTime || $.manualCursor || "2025-03-20T06:01:24.000Z");

          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({
            q: "IQ146-25-012-291",
            v: "full",
            limit: "100",
          });

          fn((state) => {
            const { cursor, data, lastRunDateTime } = state;
            console.log("Filtering patients since cursor:", cursor);

            state.patients = data.results
              .filter(({ auditInfo }) => {
                const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
                return lastModified > cursor;
              })
              .map((p) => {
                const { uuid, auditInfo, identifiers, person } = removeLinks(
                  removeNulls(p)
                );
                const { dateCreated } = auditInfo;
                const { age, birthdate, gender, names, addresses, attributes } = person;

                return {
                  uuid,
                  person: {
                    age,
                    birthdate,
                    gender,
                    names,
                    addresses: [addresses.find((a) => a.cityVillage)],
                    attributes,
                  },
                  identifiers,
                  auditInfo: { dateCreated },
                };
              });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });

          // Fetch all encounters
          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );

          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });

          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [...new Set(searchPatientUuids, encounterPatientUuids)];

            console.log("inbothResults", inbothResults.length);
            console.log("patient-search-array", onlyInSearchPatient.length);
            console.log("r4-encounter-array", onlyInR4Encounter.length);
            console.log("combined uuids", patientUuids.length);

            return { cursor, lastRunDateTime, patients, patientUuids };
          });

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
            const genderMap = {
              M: "male",
              O: "unknown",
              F: "female",
              U: "unknown",
            };
            const {
              orgUnit,
              program,
              optsMap,
              formMaps,
              placeOflivingMap,
              patientProgramStage,
              dhis2PatientNumber,
              openmrsAutoId,
            } = mappingConfig;

            const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findOptsUuid = (uuid) =>
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value?.uuid ||
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value;

            const findOptCode = (optUuid) =>
              optsMap.find((o) => o["value.uuid - External ID"] === optUuid)?.[
                "DHIS2 Option Code"
              ];

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: omrsPatient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: omrsPatient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber) ||
                  findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: omrsPatient.uuid,
              },

              {
                attribute: "T1iX2NuPyqS",
                value: omrsPatient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: omrsPatient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

            const payload = {
              program,
              orgUnit,
              attributes: [...filteredAttr, ...filteredStatusAttr],
            };
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (!patientTei) {
              payload.trackedEntityType = "cHlzCA2MuEF";
              const enrollments = [
                {
                  orgUnit,
                  program,
                  enrolledAt,
                  programStage: patientProgramStage, //'MdTtRixaC1B',
                },
              ];
              payload.attributes.push({
                attribute: "qptKDiv9uPl",
                value: genderMap[omrsPatient.person.gender],
              });
              console.log("create enrollment");
              payload.enrollments = enrollments;
            } else {
              payload.trackedEntity = patientTei.trackedEntity;
              payload.trackedEntityType = patientTei.trackedEntityType;
            }

            return payload;
          };

          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${state.patients.map((patient) => patient.uuid).join(";")}`,
            ],
            program: $.program,
          });

          fn((state) => {
            const findTeiByUuid = (patientUuid) => {
              return state.data.instances.find((tei) => {
                return (
                  tei.attributes.find(
                    (attribute) => attribute.attribute === "AYbfTPYMNJH"
                  )?.value === patientUuid
                );
              });
            };

            state.patientsMapping = state.patients.map((patient) => {
              const patientTei = findTeiByUuid(patient.uuid);

              return buildTeiMapping(patient, patientTei, {
                placeOflivingMap: state.placeOflivingMap,
                orgUnit: state.orgUnit,
                program: state.program,
                patientProgramStage: state.patientProgramStage,
                formMaps: state.formMaps,
                optsMap: state.optsMap,
                dhis2PatientNumber: state.dhis2PatientNumber,
                openmrsAutoId: state.openmrsAutoId,
              });
            });

            return state;
          });

          // Bulk upsert
          create(
            "tracker",
            { trackedEntities: $.patientsMapping },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );

          fn((state) => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              identifiers,
              ...next
            } = state;
            next.patientUuids = patients.map((p) => p.uuid);
            return next;
          });

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          //TODO: Group the encounters by patient and then get the TEI for each patient
          each(
            $.encounters,
            get("tracker/trackedEntities", (state) => ({
              orgUnit: $.orgUnit,
              program: $.program,
              // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: "*,enrollments[*],enrollments[events[*]], attributes[*]",
            })).then(async (state) => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, "Encounter patient uuid");

              const { trackedEntity, enrollments, attributes } =
                state.data?.instances?.[0] || {};
              if (trackedEntity && enrollments) {
                state.TEIs ??= {};
                state.TEIs[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments[0]?.events,
                  enrollment: enrollments[0]?.enrollment,
                  attributes,
                };
              }

              await delay(2000);
              return state;
            })
          );

      Get-Tie:
        name: Get Tie
        adaptor: '@openfn/language-dhis2@7.1.3'
        credential: null
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"
          //TODO: Group the encounters by patient and then get the TEI for each patient
          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');

            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }

            await delay(2000);
            return state;
          })

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Get-Patients->Get-Mappings-from-Collection:
        source_job: Get-Patients
        target_job: Get-Mappings-from-Collection
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state?.encounters?.length > 0

        enabled: true
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Mappings-from-Collection->Upsert-TEIs:
        source_job: Get-Mappings-from-Collection
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Get-Tie->Custom-Logic-for-Events:
        source_job: Get-Tie
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: test-mode
        condition_expression: |
          state.testMode

        enabled: true
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
  wf3-omrs-dhis2-143:
    name: wf3-omrs-dhis2-143
    jobs:
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.3.0'
        credential: mtuchi@openfn.org-mtuchi-collections-config
        body: |
          const isValidUUID = (id) => {
            if (!id || typeof id !== "string") return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);
            state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
            state.formMetadata = state.data.find((i) => i.key === "formMetadata")?.value;
            state.placeOflivingMap = state.data.find(
              (i) => i.key === "placeOflivingMap"
            )?.value;
            state.sourceFile = state.data.filter(
              (i) => i.key === "sourceFile"
            )?.[0]?.value;
            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;
            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            // TODO: Remove state.optionSetKey, when needed
            // Build from state.formMaps
            state.optionSetKey = state.data.filter(
              (i) => i.key === "optionSetKey"
            )?.[0]?.value;

            delete state.data;
            delete state.references;
            return state;
          });

          fn((state) => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) &&
                  form["OMRS Form Version"] === "v4-2025"
              )
              .map((form) => form["OMRS form.uuid"]);
            rest.formUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF3"
              )
              .map((form) => form["OMRS form.uuid"]);

            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];

            rest.orgUnit = "sUpt0j2GmBD";

            rest.program = "dWdzxMuKa8Z";

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
          // Fetch patient encounters
          each(
            $.patientUuids,
            get("encounter", { patient: $.data, v: "full" }).then((state) => {
              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map((formUuid) =>
                state?.data?.results
                  .filter(
                    (e) =>
                      e.auditInfo.dateCreated >= state.cursor &&
                      e?.form?.uuid === formUuid
                  )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              // Why we only keep the latest one form encounter?
              const encounters = filteredEncounters.map((e) => e[0]).filter((e) => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500);

              return state;
            })
          );

          fn((state) => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map((encounter) => {
                const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                  removeNulls(encounter)
                );

                return {
                  uuid,
                  patient: {
                    uuid: patient.uuid,
                    display: patient.display,
                  },
                  obs: obs.map((o) => {
                    return {
                      uuid: o.uuid,
                      concept: o.concept,
                      display: o.display,
                      formFieldPath: o.formFieldPath,
                      value: o.value,
                    };
                  }),
                  form: {
                    uuid: form.uuid,
                    display: form.display,
                    description: form.description,
                    name: form.name,
                  },
                  encounterDatetime,
                };
              });
              console.log(next.encounters.length, "# of new encounters to sync to dhis2");
            } else {
              console.log("No encounters found for cursor: ", next.cursor);
            }

            return next;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter create(
          create(
            "tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";
          const f27Form = "ac97ec76-5647-3153-b4e1-2eceae121e50";
          const f28Form = "893ef4b7-5ad1-39e7-8515-eab308ccd636";

          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );
            return answer;
          };

          const findDataValue = (encounter, dataElement, metadataMap) => {
            const { optsMap, optionSetKey, form } = metadataMap;
            const [conceptUuid, questionId] =
              form.dataValueMap[dataElement]?.split("-rfe-");
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            const isObjectAnswer = answer && typeof answer.value === "object";
            const isStringAnswer = answer && typeof answer.value === "string";

            if (isStringAnswer) {
              return answer.value;
            }

            if (isObjectAnswer) {
              const optionKey = questionId
                ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
                : `${encounter.form.uuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              if (["FALSE", "No"].includes(matchingOption)) return "false";
              if (["TRUE", "Yes"].includes(matchingOption)) return "true";

              return matchingOption;
            }

            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );

            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }

            return "";
          };
          // Helper function to process dataValues from an encounter
          function processEncounterDataValues(encounter, form, state) {
            return Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const value = findDataValue(encounter, dataElement, {
                  optsMap: state.optsMap,
                  optionSetKey: state.optionSetKey,
                  form,
                });

                return { dataElement, value };
              })
              .filter((d) => d);
          }

          const MILLISECONDS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;
          const calculateAge = (dob) =>
            Math.floor((new Date() - new Date(dob)) / MILLISECONDS_PER_YEAR);

          fn((state) => {
            // Group encounters by patient UUID
            const encountersByPatient = state.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            state.eventsMapping = Object.entries(encountersByPatient)
              .map(([patientUuid, encounters]) => {
                // Skip if we don't have exactly 2 encounters
                if (encounters.length !== 2) return null;

                // Get the forms for both encounters
                const form1 = state.formMaps[encounters[0].form.uuid];
                const form2 = state.formMaps[encounters[1].form.uuid];

                // Skip if either form doesn't have dataValueMap

                if (!form1?.dataValueMap || !form2?.dataValueMap) {
                  return null;
                }
                let encountersMapping = [];
                const f8Encounter = encounters.find((e) => e.form.uuid === f08Form);

                if (f8Encounter) {
                  const obsDatetime = findObsByConcept(
                    f8Encounter,
                    "7f00c65d-de60-467a-8964-fe80c7a85ef0"
                  )?.obsDatetime;

                  const datePart = obsDatetime.substring(0, 10);
                  const timePart = obsDatetime.substring(11, 19);
                  const f8Mapping = [
                    {
                      dataElement: "yprMS34o8s3",
                      value: f8Encounter.encounterDatetime,
                    },
                    {
                      dataElement: "iQio7NYSA3m",
                      value: datePart,
                    },
                    {
                      dataElement: "yprMS34o8s3",
                      value: timePart,
                    },
                  ];
                  encountersMapping.push(...f8Mapping);
                }

                const f27Encounter = encounters.find((e) => e.form.uuid === f27Form);

                if (f27Encounter) {
                  const admissionDate = findObsByConcept(
                    f27Encounter,
                    "7f00c65d-de60-467a-8964-fe80c7a85ef0"
                  )?.value;

                  const f27Mapping = [
                    {
                      dataElement: "eYvDzr2m8f5",
                      value: admissionDate,
                    },
                  ];
                  encountersMapping.push(...f27Mapping);
                }

                const tei = state.TEIs[patientUuid];
                if (tei) {
                  const attributeMap = {
                    Lg1LrNf9LQR: "qptKDiv9uPl",
                    OVo3FxLURtH: "k26cdlS78i9",
                    f3n6kIB9IbI: "Rv8WM2mTuS5",
                    oc9zlhOoWmP: "YUIQIA2ClN6",
                    DbyD9bbGIvE: "Qq6xQ2s6LO8",
                    fiPFww1viBB: "rBtrjV1Mqkz",
                    FsL5BjQocuo: "Xvzc9e0JJmp",
                    //F28 DSHI2 UID
                    WP5vr8KB2lH: "qptKDiv9uPl",
                    Y7qzoa4Qaiz: "YUIQIA2ClN6",
                    XCUd9xOGXkn: "Qq6xQ2s6LO8",
                    onKT21rxH6Z: "rBtrjV1Mqkz",
                    sCKCNreiqEA: "Xvzc9e0JJmp",
                  };

                  const attributeMapping = Object.entries(attributeMap)
                    .map(([dataElement, attributeId]) => {
                      const value = tei?.attributes?.find(
                        (attr) => attr.attribute === attributeId
                      )?.value;

                      return { dataElement, value };
                    })
                    .filter(Boolean);

                  let age = tei?.attributes?.find(
                    (attr) => attr.attribute === "T1iX2NuPyqS"
                  )?.value;

                  if (!age) {
                    const birthdate = tei?.attributes?.find(
                      (attr) => attr.attribute === "WDp4nVor9Z7"
                    )?.value;
                    age = calculateAge(birthdate);
                  }

                  const f28Mapping = [
                    {
                      dataElement: "NWOnMq8h4w1",
                      value: age,
                    },
                  ];
                  encountersMapping.push(...attributeMapping, ...f28Mapping);
                }

                // Combine dataValues from both encounters
                const formDataValues = [
                  ...encountersMapping,
                  ...processEncounterDataValues(encounters[0], form1, state),
                  ...processEncounterDataValues(encounters[1], form2, state),
                ].filter((d) => d.value);

                // Use properties from the first encounter for the event metadata
                // (or choose which encounter to use for each field)
                return {
                  program: form1.programId,
                  orgUnit: form1.orgUnit,
                  occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                  programStage: form1.programStage,
                  dataValues: formDataValues,
                  trackedEntityInstance: patientUuid,
                };
              })
              .filter(Boolean);

            return state;
          });

          fn((state) => {
            return {
              eventsMapping: state.eventsMapping,
            };
          });

      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }

          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }
          cursor($.lastRunDateTime || $.manualCursor || "2025-03-20T06:01:24.000Z");

          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({
            q: "IQ146-25-012-289",
            v: "full",
            includeVoide: true,
            limit: "100",
          });

          fn((state) => {
            const { cursor, data, lastRunDateTime } = state;
            console.log("Filtering patients since cursor:", cursor);

            state.patients = data.results
              .filter(({ auditInfo }) => {
                const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
                return lastModified > cursor;
              })
              .map((p) => {
                const { uuid, auditInfo, identifiers, person } = removeLinks(
                  removeNulls(p)
                );
                const { dateCreated } = auditInfo;
                const { age, birthdate, gender, names, addresses, attributes } = person;

                return {
                  uuid,
                  person: {
                    age,
                    birthdate,
                    gender,
                    names,
                    addresses: [addresses.find((a) => a.cityVillage)],
                    attributes,
                  },
                  identifiers,
                  auditInfo: { dateCreated },
                };
              });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });

          // Fetch all encounters
          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );

          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });

          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [...new Set(searchPatientUuids, encounterPatientUuids)];

            console.log("inbothResults", inbothResults.length);
            console.log("patient-search-array", onlyInSearchPatient.length);
            console.log("r4-encounter-array", onlyInR4Encounter.length);
            console.log("combined uuids", patientUuids.length);

            return { cursor, lastRunDateTime, patients, patientUuids };
          });

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
            const genderMap = {
              M: "male",
              O: "unknown",
              F: "female",
              U: "unknown",
            };
            const {
              orgUnit,
              program,
              optsMap,
              formMaps,
              placeOflivingMap,
              patientProgramStage,
              dhis2PatientNumber,
              openmrsAutoId,
            } = mappingConfig;

            const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findOptsUuid = (uuid) =>
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value?.uuid ||
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value;

            const findOptCode = (optUuid) =>
              optsMap.find((o) => o["value.uuid - External ID"] === optUuid)?.[
                "DHIS2 Option Code"
              ];

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: omrsPatient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: omrsPatient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber) ||
                  findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: omrsPatient.uuid,
              },

              {
                attribute: "T1iX2NuPyqS",
                value: omrsPatient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: omrsPatient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

            const payload = {
              program,
              orgUnit,
              attributes: [...filteredAttr, ...filteredStatusAttr],
            };
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (!patientTei) {
              payload.trackedEntityType = "cHlzCA2MuEF";
              const enrollments = [
                {
                  orgUnit,
                  program,
                  enrolledAt,
                  programStage: patientProgramStage, //'MdTtRixaC1B',
                },
              ];
              payload.attributes.push({
                attribute: "qptKDiv9uPl",
                value: genderMap[omrsPatient.person.gender],
              });
              console.log("create enrollment");
              payload.enrollments = enrollments;
            } else {
              payload.trackedEntity = patientTei.trackedEntity;
              payload.trackedEntityType = patientTei.trackedEntityType;
            }

            return payload;
          };

          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${state.patients.map((patient) => patient.uuid).join(";")}`,
            ],
            program: $.program,
          });

          fn((state) => {
            const findTeiByUuid = (patientUuid) => {
              return state.data.instances.find((tei) => {
                return (
                  tei.attributes.find(
                    (attribute) => attribute.attribute === "AYbfTPYMNJH"
                  )?.value === patientUuid
                );
              });
            };

            state.patientsMapping = state.patients.map((patient) => {
              const patientTei = findTeiByUuid(patient.uuid);

              return buildTeiMapping(patient, patientTei, {
                placeOflivingMap: state.placeOflivingMap,
                orgUnit: state.orgUnit,
                program: state.program,
                patientProgramStage: state.patientProgramStage,
                formMaps: state.formMaps,
                optsMap: state.optsMap,
                dhis2PatientNumber: state.dhis2PatientNumber,
                openmrsAutoId: state.openmrsAutoId,
              });
            });

            return state;
          });

          // Bulk upsert
          create(
            "tracker",
            { trackedEntities: $.patientsMapping },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );

          fn((state) => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              identifiers,
              ...next
            } = state;
            next.patientUuids = patients.map((p) => p.uuid);
            return next;
          });

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          //TODO: Group the encounters by patient and then get the TEI for each patient
          each(
            $.encounters,
            get("tracker/trackedEntities", (state) => ({
              orgUnit: $.orgUnit,
              program: $.program,
              // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: "*,enrollments[*],enrollments[events[*]], attributes[*]",
            })).then(async (state) => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, "Encounter patient uuid");

              const { trackedEntity, enrollments, attributes } =
                state.data?.instances?.[0] || {};
              if (trackedEntity && enrollments) {
                state.TEIs ??= {};
                state.TEIs[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments[0]?.events,
                  enrollment: enrollments[0]?.enrollment,
                  attributes,
                };
              }

              await delay(2000);
              return state;
            })
          );

      Get-Tie:
        name: Get Tie
        adaptor: '@openfn/language-dhis2@7.1.3'
        credential: null
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"
          //TODO: Group the encounters by patient and then get the TEI for each patient
          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');

            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }

            await delay(2000);
            return state;
          })

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Get-Patients->Get-Mappings-from-Collection:
        source_job: Get-Patients
        target_job: Get-Mappings-from-Collection
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state?.encounters?.length > 0

        enabled: true
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Mappings-from-Collection->Upsert-TEIs:
        source_job: Get-Mappings-from-Collection
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Get-Tie->Custom-Logic-for-Events:
        source_job: Get-Tie
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: test-mode
        condition_expression: |
          state.testMode

        enabled: true
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
