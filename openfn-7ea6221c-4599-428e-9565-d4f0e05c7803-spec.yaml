name: msf-lime-mosul-staging
description: |
  staging project for main MSF workflows

collections: null
credentials:
  aisha@openfn.org-MSF-OMRS-admin:
    name: MSF OMRS admin
    owner: aisha@openfn.org
  "mtuchi@openfn.org-Collections-Config[Mtuchi]":
    name: 'Collections Config[Mtuchi]'
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-MSF-DHIS2-UAT:
    name: MSF DHIS2 UAT
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenFnSharepoint:
    name: OpenFnSharepoint
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenMRS-Demo:
    name: OpenMRS Demo
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-api-token:
    name: mtuchi-api-token
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-github-token:
    name: mtuchi-github-token
    owner: mtuchi@openfn.org
workflows:
  get-metadata-collections:
    name: get-metadata-collections
    jobs:
      Get-and-set-metadata-collections:
        name: Get and set metadata collections
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          // Check out the Job Writing Guide for help getting started:
          // https://docs.openfn.org/documentation/jobs/job-writing-guide

          // collections.remove("metadata-mappings", "mappings-*")

          //  collections.remove("metadata-mappings", "mapping*")

           collections.get("metadata_mappings", "mappingSets") // getting collections from metadata project

           collections.set("mosul-metadata-mappings", "mappingSets", state => {
            return state.data
           })

          collections.get("mosul-metadata-mappings", "mappingSets") 

    triggers:
      webhook:
        type: webhook
        enabled: false
    edges:
      webhook->Get-and-set-metadata-collections:
        source_trigger: webhook
        target_job: Get-and-set-metadata-collections
        condition_type: always
        enabled: true
  wf1-dhis2-omrs-migration:
    name: wf1-dhis2-omrs-migration
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/fetch-metadata.js

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/get-teis-and-locations.js

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: aisha@openfn.org-MSF-OMRS-admin
        body:
          path: workflows/wf1/create-patients.js

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/update-teis.js

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/alert-admin.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: true
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
  wf2-omrs-dhis2:
    name: wf2-omrs-dhis2
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/1-get-patients.js

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-api-token
        body:
          path: workflows/wf2/2-mappings.js

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/3-upsert-teis.js

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/4-get-encounters.js

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/5-get-teis.js

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/6-create-events.js

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/7-update-teis.js

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@latest'
        credential: null
        body:
          path: workflows/wf2/events-mapping.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Mappings->Upsert-TEIs:
        source_job: Mappings
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Event-Mappings:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
  wf3-omrs-dhis2:
    name: wf3-omrs-dhis2
    jobs:
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          const isValidUUID = id => {
            if (!id || typeof id !== 'string') return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          cursor($.lastRunDateTime || $.manualCursor || '2025-06-30T06:01:24.000Z');

          cursor('today', {
            key: 'lastRunDateTime',
            format: c => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          collections.get('mosul-metadata-mappings-staging').then(state => {
            state.optsMap = state.data
              .filter(i => i.key.includes('optsMap-value-'))
              .map(i => i.value);

            state.identifiers = state.data
              .filter(i => i.key.includes('identifiers-value-'))
              .map(i => i.value);
            state.syncedAt = state.data.find(i => i.key === 'syncedAt')?.value;
            state.formMetadata = state.data.find(i => i.key === 'formMetadata')?.value; // filter form maps where formmap.workflow == "WF3"
            state.placeOflivingMap = state.data.find(i => i.key === 'placeOflivingMap')?.value;
            state.sourceFile = state.data.filter(i => i.key === 'sourceFile')?.[0]?.value;
            state.fileDateModified = state.data.filter(
              i => i.key === 'fileDateModified'
            )?.[0]?.value;
            state.optionSetKey = state.data.filter(
              i => i.key === 'optionSetKey'
            )?.[0]?.value;
            state.formMaps = state.data.find(i => i.key === 'formMaps')?.value;
            delete state.data
            delete state.references
            return state;
          });

          fn(state => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                form =>
                  isValidUUID(form['OMRS form.uuid']) &&
                  form['OMRS Form Version'] === 'v4-2025'
              )
              .map(form => form['OMRS form.uuid']);
            rest.formUuids = formMetadata
              .filter(form => isValidUUID(form['OMRS form.uuid']) && 
                      form['Workflow'] === 'WF3')
              .map(form => form['OMRS form.uuid']);

            rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
              'dhis2 attribute id'
            ];

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              i => i.type === 'DHIS2_PATIENT_NUMBER'
            )?.['omrs identifierType']; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find(i => i.type === 'OPENMRS_AUTO_ID')?.[
              'omrs identifierType'
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });

          fn(state => {
            state.genderOptions = state.optsMap
              .filter(o => o['OptionSet name'] === 'Sex - Patient')
              .reduce((acc, value) => {
                acc[value['value.uuid - External ID']] = value['DHIS2 Option Code'];
                return acc;
              }, {});

            return state;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Fetch all encounters
          http
            .get('/ws/fhir2/R4/Encounter', {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then(state => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find(l => l.relation === 'next')
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split('/openmrs')[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then(state => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );



          fn(state => {
            console.log(
              'Total # of encounters fetched: ',
              state.allResponse?.entry?.length
            );
            
            state.patientUuids = [
              ...new Set(
                state.allResponse?.entry?.map(p =>
                  p.resource.subject.reference.replace('Patient/', '')
                )
              ),
            ];

            return state;
          });

          // Fetch patient encounters
          each(
            $.patientUuids,
            get('encounter', { patient: $.data, v: 'full' }).then(state => {

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map(formUuid =>
                state.data?.filter(
                  e =>
                    e.auditInfo.dateCreated >= state.cursor &&
                    e?.form?.uuid === formUuid
                )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters.map(e => e[0]).filter(e => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );

              return state;
            })
          );

          fn(state => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map(
                ({ uuid, patient, obs, form, encounterDatetime }) => ({
                  uuid,
                  patient,
                  obs,
                  form,
                  encounterDatetime,
                })
              );
              console.log(next.encounters.length, '# of new encounters to sync to dhis2');
            } else {
              console.log('No encounters found for cursor: ', next.cursor);
            }


            // Group encounters by patient UUID
            next.encountersByPatient = next.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return next;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter
          create(
            "tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4"
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261"

          const processAnswer = (
            answer,
            conceptUuid,
            dataElement,
            optsMap,
            optionSetKey
          ) => {
            if (typeof answer.value === "object") {
              const optionKey = `${answer.formUuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              // console.log(`matchingOption value: "${matchingOption}" for`);
              // console.log({
              //   optionKey,
              //   conceptUid: answer.concept.uuid,
              //   'answer.value.uid': answer.value.uuid,
              //   'answer.value.display': answer.value.display,
              //   matchingOption,
              //   matchingOptionSet,
              // });

              if (matchingOption === "FALSE" || matchingOption === "No") {
                return "false";
              }
              if (matchingOption === "TRUE" || matchingOption === "Yes") {
                return "true";
              }

              return matchingOption || "";
            }

            return answer.value;
          };

          const processNoAnswer = (encounter, conceptUuid, dataElement) => {
            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );
            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2

            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }
            return "";
          };

          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) =>
            encounter.obs.find((o) => o.concept.uuid === conceptUuid);

          // Helper function to process dataValues from an encounter
          function processEncounterDataValues(encounter, form, state) {
            return Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const conceptUuid = form.dataValueMap[dataElement];
                const obsAnswer = encounter.obs.find(
                  (o) => o.concept.uuid === conceptUuid
                );
                const answer = {
                  ...obsAnswer,
                  formUuid: encounter.form.uuid,
                };
                const value = answer
                  ? processAnswer(
                    answer,
                    conceptUuid,
                    dataElement,
                    state.optsMap,
                    state.optionSetKey
                  )
                  : processNoAnswer(encounter, conceptUuid, dataElement);

                return { dataElement, value };
              })
              .filter((d) => d);
          }

          fn((state) => {
            state.eventsMapping = Object.entries(state.encountersByPatient)
              .map(([patientUuid, encounters]) => {
                // Skip if we don't have exactly 2 encounters
                if (encounters.length !== 2) return null;
                
                // Get the forms for both encounters
                const form1 = state.formMaps[encounters[0].form.uuid];
                const form2 = state.formMaps[encounters[1].form.uuid];
                
                // Skip if either form doesn't have dataValueMap
                if (!form1?.dataValueMap || !form2?.dataValueMap) return null;
                
                // Combine dataValues from both encounters
                const formDataValues = [
                  ...processEncounterDataValues(encounters[0], form1, state),
                  ...processEncounterDataValues(encounters[1], form2, state)
                ];
                
                // Use properties from the first encounter for the event metadata
                // (or choose which encounter to use for each field)
                return {
                  program: form1.programId,
                  orgUnit: form1.orgUnit,
                  occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                  programStage: form1.programStage,
                  dataValues: formDataValues,
                  trackedEntityInstance: patientUuid
                };
              })
              .filter(Boolean);

            return state;
          });
    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Mappings-from-Collection:
        source_trigger: cron
        target_job: Get-Mappings-from-Collection
        condition_type: always
        enabled: true
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: on_job_success
        enabled: true
      Get-Encounters->Custom-Logic-for-Events:
        source_job: Get-Encounters
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters?.length > 0

        enabled: true
