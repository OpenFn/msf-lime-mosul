name: msf-lime-mosul-staging
description: |
  staging project for main MSF workflows

collections: null
credentials:
  aisha@openfn.org-MSF-OMRS-admin:
    name: MSF OMRS admin
    owner: aisha@openfn.org
  "mtuchi@openfn.org-Collections-Config[Mtuchi]":
    name: 'Collections Config[Mtuchi]'
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-MSF-DHIS2-UAT:
    name: MSF DHIS2 UAT
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenFnSharepoint:
    name: OpenFnSharepoint
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenMRS-Demo:
    name: OpenMRS Demo
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-api-token:
    name: mtuchi-api-token
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-github-token:
    name: mtuchi-github-token
    owner: mtuchi@openfn.org
workflows:
  get-metadata-collections:
    name: get-metadata-collections
    jobs:
      Get-and-set-metadata-collections:
        name: Get and set metadata collections
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          // Check out the Job Writing Guide for help getting started:
          // https://docs.openfn.org/documentation/jobs/job-writing-guide

          // collections.remove("metadata-mappings", "mappings-*")

          //  collections.remove("metadata-mappings", "mapping*")

           collections.get("metadata_mappings", "mappingSets") // getting collections from metadata project

           collections.set("mosul-metadata-mappings", "mappingSets", state => {
            return state.data
           })

          collections.get("mosul-metadata-mappings", "mappingSets") 

    triggers:
      webhook:
        type: webhook
        enabled: false
    edges:
      webhook->Get-and-set-metadata-collections:
        source_trigger: webhook
        target_job: Get-and-set-metadata-collections
        condition_type: always
        enabled: true
  wf1-dhis2-omrs-migration:
    name: wf1-dhis2-omrs-migration
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/fetch-metadata.js

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/get-teis-and-locations.js

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: aisha@openfn.org-MSF-OMRS-admin
        body:
          path: workflows/wf1/create-patients.js

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/update-teis.js

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/alert-admin.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: true
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
  wf2-omrs-dhis2:
    name: wf2-omrs-dhis2
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/1-get-patients.js

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-api-token
        body:
          path: workflows/wf2/2-mappings.js

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/3-upsert-teis.js

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/4-get-encounters.js

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/5-get-teis.js

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/6-create-events.js

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/7-update-teis.js

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@latest'
        credential: null
        body:
          path: workflows/wf2/events-mapping.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Mappings->Upsert-TEIs:
        source_job: Mappings
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Event-Mappings:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
  wf3-omrs-dhis2:
    name: wf3-omrs-dhis2
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Enable test mode
          const testMode = false
          
          cursor($.lastRunDateTime || $.manualCursor || '2025-03-20T06:01:24.000Z');
          
          cursor('today', {
            key: 'lastRunDateTime',
            format: c => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });
          
          searchPatient({ q: 'IQ', v: 'full', includeVoide: true, limit: '100' });
          
          fn(state => {
            const { cursor, data, lastRunDateTime } = state;
            console.log('Filtering patients since cursor:', cursor);
          
            const patients = data.results.filter(({ auditInfo }) => {
              const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
              return lastModified > cursor;
            });
            console.log('# of patients to sync to dhis2 ::', patients.length);
            console.log(
              'uuids of patients to sync to dhis2 ::',
              patients.map(p => p.uuid)
            );
          
            return { cursor, lastRunDateTime, patients, testMode };
          });
          
          // get patient - log number of patient that are fetched
          
          // get collections neccessary for patient mapping
          
          // map patient here - this will be passed down to next step
          
          // delete the initial patient object and only pass on the mapped one
          
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.3.0'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          const isValidUUID = id => {
            if (!id || typeof id !== 'string') return false;
          
            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };
          
          collections.get('mosul-metadata-mappings-staging').then(state => {
            state.optsMap = state.data
              .filter(i => i.key.includes('optsMap-value-'))
              .map(i => i.value);
          
            state.identifiers = state.data
              .filter(i => i.key.includes('identifiers-value-'))
              .map(i => i.value);
            state.syncedAt = state.data.find(i => i.key === 'syncedAt')?.value;
            state.formMetadata = state.data.find(i => i.key === 'formMetadata')?.value; // filter form maps where formmap.workflow == "WF3"
            state.placeOflivingMap = state.data.find(i => i.key === 'placeOflivingMap')?.value;
            state.sourceFile = state.data.filter(i => i.key === 'sourceFile')?.[0]?.value;
            state.fileDateModified = state.data.filter(
              i => i.key === 'fileDateModified'
            )?.[0]?.value;
            state.optionSetKey = state.data.filter(
              i => i.key === 'optionSetKey'
            )?.[0]?.value;
            state.formMaps = state.data.find(i => i.key === 'formMaps')?.value;
            delete state.data
            delete state.references
            return state;
          });
          
          
          fn(state => {
            const { formMetadata, identifiers, ...rest } = state;
          
            rest.v2FormUuids = formMetadata
              .filter(
                form =>
                  isValidUUID(form['OMRS form.uuid']) &&
                  form['OMRS Form Version'] === 'v4-2025'
              )
              .map(form => form['OMRS form.uuid']);
            rest.formUuids = formMetadata
              .filter(form => isValidUUID(form['OMRS form.uuid']) &&
                form['Workflow'] === 'WF3')
              .map(form => form['OMRS form.uuid']);
          
            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];
          
            rest.orgUnit = "sUpt0j2GmBD"
          
          
            rest.program = "dWdzxMuKa8Z"
          
            rest.patientProgramStage = state.formMaps.patient.programStage;
          
            rest.dhis2PatientNumber = identifiers.find(
              i => i.type === 'DHIS2_PATIENT_NUMBER'
            )?.['omrs identifierType']; //DHIS2 ID or DHIS2 Patient Number
          
            rest.openmrsAutoId = identifiers.find(i => i.type === 'OPENMRS_AUTO_ID')?.[
              'omrs identifierType'
            ]; //MSF ID or OpenMRS Patient Number
          
            return rest;
          });
          
          
          fn(state => {
            state.genderOptions = state.optsMap
              .filter(o => o['OptionSet name'] === 'Sex - Patient')
              .reduce((acc, value) => {
                acc[value['value.uuid - External ID']] = value['DHIS2 Option Code'];
                return acc;
              }, {});
          
            return state;
          });
          
      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildPatientsUpsert = (state, patient, isNewPatient) => {
            const { placeOflivingMap, genderOptions } = state;
            const dateCreated = patient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find(i => i.identifierType.uuid === targetUuid)?.identifier;
          
            const enrollments = [
              {
                orgUnit: state.orgUnit,
                program: state.program, // searching by MH program but change this EMR
                programStage: state.patientProgramStage, //'MdTtRixaC1B',
                enrollmentDate: dateCreated,
              },
            ];
          
            const findOptsUuid = uuid =>
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value
                ?.uuid ||
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value;
          
            const findOptCode = optUuid =>
              state.optsMap.find(o => o['value.uuid - External ID'] === optUuid)?.[
                'DHIS2 Option Code'
              ];
          
            const patientMap = state.formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map(d => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });
          
            const standardAttr = [
              {
                attribute: 'fa7uwpCKIwa',
                value: patient.person?.names[0]?.givenName,
              },
              {
                attribute: 'Jt9BhFZkvP2',
                value: patient.person?.names[0]?.familyName,
              },
              {
                attribute: 'P4wdYGkldeG', //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(patient.identifiers, state.dhis2PatientNumber) ||
                  findIdentifierByUuid(patient.identifiers, state.openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: 'ZBoxuExmxcZ', //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(patient.identifiers, state.openmrsAutoId),
              },
              {
                attribute: 'AYbfTPYMNJH', //"OpenMRS Patient UID"
                value: patient.uuid,
              },
              {
                attribute: 'qptKDiv9uPl',
                value: genderOptions[patient.person.gender],
              },
              {
                attribute: 'T1iX2NuPyqS',
                value: patient.person.age,
              },
              {
                attribute: 'WDp4nVor9Z7',
                value: patient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: 'rBtrjV1Mqkz', //Place of living
                value: placeOflivingMap[patient.person?.addresses[0]?.cityVillage],
              },
            ];
          
            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter(a => a.value);
            const filteredStatusAttr = statusAttrMaps.filter(a => a.value);
            //console.log('standardAttr ::', JSON.stringify(standardAttr, null,2))
            //console.log('filteredAttr ::', JSON.stringify(filteredAttr, null,2))
          
            const payload = {
              query: {
                ou: state.orgUnit,
                program: state.program,
                filter: [`AYbfTPYMNJH:Eq:${patient.uuid}`], //upsert on omrs.patient.uid
              },
              data: {
                program: state.program,
                orgUnit: state.orgUnit,
                trackedEntityType: 'cHlzCA2MuEF',
                attributes: [...filteredAttr, ...filteredStatusAttr],
              },
            };
          
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));
          
            if (isNewPatient) {
              console.log('create enrollment');
              payload.data.enrollments = enrollments;
            }
          
            return payload;
          };
          
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          
          each(
            $.patients,
            get(
              'tracker/trackedEntities',
              {
                orgUnit: $.orgUnit,
                filter: [`AYbfTPYMNJH:Eq:${$.data?.uuid}`],
                program: $.program,
              },
              {},
              async state => {
                const patient = state.references.at(-1);
                console.log(patient.uuid, 'patient uuid');
          
                const isNewPatient = state.data.instances.length === 0;
          
                state.patientsUpsert ??= [];
                state.patientsUpsert.push(
                  buildPatientsUpsert(state, patient, isNewPatient)
                );
                await delay(2000);
                return state;
              }
            )
          );
          
          // Upsert TEIs to DHIS2
          each(
            $.patientsUpsert,
            upsert('trackedEntityInstances', $.data.query, $.data.data)
          );
          fn(state => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              genderOptions,
              identifiers,
              ...next
            } = state;
          
            next.patientUuids = patients.map(p => p.uuid);
            return next;
          });
          
      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Fetch all encounters
          http
            .get('/ws/fhir2/R4/Encounter', {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then(state => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find(l => l.relation === 'next')
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split('/openmrs')[1];
          
              state.allResponse = state.data;
              return state;
            });
          
          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then(state => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );
          
          
          
          fn(state => {
            console.log(
              'Total # of encounters fetched: ',
              state.allResponse?.entry?.length
            );
          
            state.patientUuids = [
              ...new Set(
                state.allResponse?.entry?.map(p =>
                  p.resource.subject.reference.replace('Patient/', '')
                )
              ),
            ];
          
            return state;
          });
          
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          // Fetch patient encounters
          each(
            $.patientUuids,
            get('encounter', { patient: $.data, v: 'full' }).then(state => {
          
              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map(formUuid =>
                state?.data?.results.filter(
                  e =>
                    e.auditInfo.dateCreated >= state.cursor &&
                    e?.form?.uuid === formUuid
                )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );
          
              const encounters = filteredEncounters.map(e => e[0]).filter(e => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);
          
              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500)
          
              return state;
            })
          );
          
          fn(state => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;
          
            if (next.encounters?.length) {
              next.encounters = next.encounters.map(
                ({ uuid, patient, obs, form, encounterDatetime }) => ({
                  uuid,
                  patient,
                  obs,
                  form,
                  encounterDatetime,
                })
              );
              console.log(next.encounters.length, '# of new encounters to sync to dhis2');
            } else {
              console.log('No encounters found for cursor: ', next.cursor);
            }
          
          
            // Group encounters by patient UUID
            next.encountersByPatient = next.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});
          
            return next;
          });
          
      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          
          //TODO: Group the encounters by patient and then get the TEI for each patient
          each(
            $.encounters,
            get('tracker/trackedEntities', state => ({
              orgUnit: $.orgUnit,
              program: $.program,
              // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
            })).then(async state => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, 'Encounter patient uuid');
          
              const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
              if (trackedEntity && enrollments) {
                state.TEIs ??= {};
                state.TEIs[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments[0]?.events,
                  enrollment: enrollments[0]?.enrollment,
                  attributes
                };
              }
          
              await delay(2000);
              return state;
            })
          );
          
      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter create(
          create("tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );
          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));
          
      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";
          
          const processAnswer = (
            answer,
            conceptUuid,
            dataElement,
            optsMap,
            optionSetKey
          ) => {
            if (typeof answer.value === "object") {
              const optionKey = `${answer.formUuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found
          
              // console.log(`matchingOption value: "${matchingOption}" for`);
              // console.log({
              //   optionKey,
              //   conceptUid: answer.concept.uuid,
              //   'answer.value.uid': answer.value.uuid,
              //   'answer.value.display': answer.value.display,
              //   matchingOption,
              //   matchingOptionSet,
              // });
          
              if (matchingOption === "FALSE" || matchingOption === "No") {
                return "false";
              }
              if (matchingOption === "TRUE" || matchingOption === "Yes") {
                return "true";
              }
          
              return matchingOption || "";
            }
          
            return answer.value;
          };
          
          const processNoAnswer = (encounter, conceptUuid, dataElement) => {
            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );
            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
          
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }
            return "";
          };
          
          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };
          
          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) =>
            encounter.obs.find((o) => o.concept.uuid === conceptUuid);
          
          // Helper function to process dataValues from an encounter
          function processEncounterDataValues(encounter, form, state) {
            return Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const conceptUuid = form.dataValueMap[dataElement];
                const obsAnswer = encounter.obs.find(
                  (o) => o.concept.uuid === conceptUuid
                );
          
                const answer = {
                  ...obsAnswer,
                  formUuid: encounter.form.uuid,
                };
                const value = answer
                  ? processAnswer(
                    answer,
                    conceptUuid,
                    dataElement,
                    state.optsMap,
                    state.optionSetKey
                  )
                  : processNoAnswer(encounter, conceptUuid, dataElement);
          
                return { dataElement, value };
              })
              .filter((d) => d);
          }
          
          fn((state) => {
            state.eventsMapping = Object.entries(state.encountersByPatient)
              .map(([patientUuid, encounters]) => {
                // Skip if we don't have exactly 2 encounters
                if (encounters.length !== 2) return null;
          
          
                // Get the forms for both encounters
                const form1 = state.formMaps[encounters[0].form.uuid];
                const form2 = state.formMaps[encounters[1].form.uuid];
          
                // Skip if either form doesn't have dataValueMap
                if (!form1?.dataValueMap || !form2?.dataValueMap) return null;
                const f8Encounter = encounters.find(e => e.form.uuid === f08Form)
                const obsDatetime = findObsByConcept(f8Encounter, '7f00c65d-de60-467a-8964-fe80c7a85ef0')?.obsDatetime
          
                const datePart = obsDatetime.substring(0, 10);
                const timePart = obsDatetime.substring(11, 19);
                const f8Mapping = [
                  {
                    dataElement: "yprMS34o8s3",
                    value: f8Encounter.encounterDatetime
                  },
                  {
                    dataElement: "iQio7NYSA3m",
                    value: datePart
                  },
                  {
                    dataElement: "yprMS34o8s3",
                    value: timePart
                  }
                ]
          
          
                const tei = state.TEIs[patientUuid];
                console.log({ tei, patientUuid })
          
                const attributeMap = {
                  "Lg1LrNf9LQR": "qptKDiv9uPl",
                  "OVo3FxLURtH": "k26cdlS78i9",
                  "f3n6kIB9IbI": "Rv8WM2mTuS5",
                  "oc9zlhOoWmP": "YUIQIA2ClN6",
                  "DbyD9bbGIvE": "Qq6xQ2s6LO8",
                  "fiPFww1viBB": "rBtrjV1Mqkz",
                  "FsL5BjQocuo": "Xvzc9e0JJmp"
                };
          
                const f9Mapping = Object.entries(attributeMap)
                  .map(([dataElement, attributeId]) => {
                    const value = tei?.attributes?.find(attr => attr.attribute === attributeId)?.value;
          
                    return { dataElement, value };
                  })
                  .filter(Boolean);
          
                // Combine dataValues from both encounters
                const formDataValues = [
                  ...f8Mapping,
                  ...f9Mapping,
                  ...processEncounterDataValues(encounters[0], form1, state),
                  ...processEncounterDataValues(encounters[1], form2, state),
                ].filter(d => d.value)
          
                // Use properties from the first encounter for the event metadata
                // (or choose which encounter to use for each field)
                return {
                  program: form1.programId,
                  orgUnit: form1.orgUnit,
                  occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                  programStage: form1.programStage,
                  dataValues: formDataValues,
                  trackedEntityInstance: patientUuid,
                };
              })
              .filter(Boolean);
          
            return state;
          });
          
      Get-Tie:
        name: Get Tie
        adaptor: '@openfn/language-dhis2@7.1.3'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          
          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"
          //TODO: Group the encounters by patient and then get the TEI for each patient
          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');
          
            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }
          
            await delay(2000);
            return state;
          })
    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors
          
        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0
          
        enabled: true
      Get-Patients->Get-Mappings-from-Collection:
        source_job: Get-Patients
        target_job: Get-Mappings-from-Collection
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors
          
        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state?.encounters?.length > 0
          
        enabled: true
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode
          
        enabled: false
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Mappings-from-Collection->Upsert-TEIs:
        source_job: Get-Mappings-from-Collection
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors
          
        enabled: true
      Get-Tie->Custom-Logic-for-Events:
        source_job: Get-Tie
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: test-mode
        condition_expression: |
          state.testMode
        enabled: true
