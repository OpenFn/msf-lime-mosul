name: msf-lime-mosul-staging
description: |
  staging project for main MSF workflows

collections: null
credentials:
  aisha@openfn.org-MSF-OMRS-admin:
    name: MSF OMRS admin
    owner: aisha@openfn.org
  "mtuchi@openfn.org-Collections-Config[Mtuchi]":
    name: 'Collections Config[Mtuchi]'
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-MSF-DHIS2-UAT:
    name: MSF DHIS2 UAT
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenFnSharepoint:
    name: OpenFnSharepoint
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-OpenMRS-Demo:
    name: OpenMRS Demo
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-api-token:
    name: mtuchi-api-token
    owner: mtuchi@openfn.org
  mtuchi@openfn.org-mtuchi-github-token:
    name: mtuchi-github-token
    owner: mtuchi@openfn.org
workflows:
  129-wf1-dhis2-omrs-migration:
    name: 129-wf1-dhis2-omrs-migration
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          cursor($.manualCursor || $.lastRunDateTime).then((state) => {
            console.log("Date cursor to filter TEI extract ::", state.cursor);
            return state;
          });

          cursor("now", {
            key: "lastRunDateTime",
            format: (c) => {
              const offset = 2; // GMT+2 (Geneva time)
              c.setHours(c.getHours() + offset);
              return c.toISOString().replace("Z", "");
            },
          }).then((state) => {
            console.log("Next sync start date:", state.lastRunDateTime);
            return state;
          });

          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);

            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;

            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            delete state.data;
            delete state.references;
            return state;
          });

          fn(({ identifiers, optsMap, formMaps, ...state }) => {
            state.genderOptions = {
              male: "M",
              female: "F",
              unknown: "U",
              transgender_female: "O",
              transgender_male: "O",
              prefer_not_to_answer: "O",
              gender_variant_non_conforming: "O",
            };
            state.orgUnit = identifiers.find((i) => i.type === "ORG_UNIT")?.[
              "dhis2 attribute id"
            ];
            state.program = identifiers.find((i) => i.type === "PROGRAM")?.[
              "dhis2 attribute id"
            ];
            state.nationalityMap = optsMap
              .filter((o) => o["DHIS2 DE full name"] === "Nationality")
              .reduce((acc, value) => {
                acc[value["DHIS2 Option Code"]] = value["value.uuid - External ID"];
                return acc;
              }, {});

            state.statusMap = optsMap
              .filter((o) => {
                const fullName = o["DHIS2 DE full name"];
                return fullName && fullName.includes(" status");
              })
              .reduce((acc, value) => {
                acc[value["DHIS2 Option Code"]] = value["value.uuid - External ID"];
                return acc;
              }, {});

            state.patientAttributes = formMaps.patient.dataValueMap;

            state.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            state.dhis2PatientNumberAttributeId = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["dhis2 attribute id"]; //DHIS2 ID or DHIS2 Patient Number

            state.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            state.openmrsAutoIdAttributeId = identifiers.find(
              (i) => i.type === "OPENMRS_AUTO_ID"
            )?.["dhis2 attribute id"]; //MSF ID or OpenMRS Patient Number

            return state;
          });

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const findDuplicatePatient = teis => {
            const seen = new Map();
            const duplicates = new Set();

            teis.forEach(tei => {
              const patientNumber = tei.attributes.find(
                attr => attr.code === 'patient_number'
              )?.value;

              if (seen.get(patientNumber)) {
                duplicates.add(patientNumber);
              } else {
                seen.set(patientNumber, tei);
              }
            });

            return duplicates;
          };
          // Get teis that are "active" in the target program
          get('tracker/trackedEntities', {
            orgUnit: $.orgUnit,
            program: $.program,
            programStatus: 'ACTIVE',
            updatedAfter: $.cursor,
            skipPaging: true,
          });

          fn(state => {
            console.log('# of TEIs found before filter ::', state.data.instances.length);
            const uniqueTeis = [];
            const duplicatePatients = [];
            const missingPatientNumber = [];
            const teisWithOMRSID = [];

            const filteredTeis = state.data.instances.filter(
              tei => tei.updatedAt >= state.cursor
            );

            console.log('Filtered TEIs ::', filteredTeis.length);
            const duplicateIds = findDuplicatePatient(filteredTeis);

            filteredTeis.forEach(tei => {
              const patientNumber = tei.attributes.find(
                attr => attr.code === 'patient_number'
              )?.value;
              const patientUid = tei.attributes.find(
                attr => attr.code === 'patient_uid'
              )?.value;

              if (patientUid) {
                console.log(
                  `Skipping TEI:: ${tei.trackedEntity}. Found existing patient uid.`
                );
                teisWithOMRSID.push(tei)
              }

              if (!patientNumber) {
                missingPatientNumber.push(tei);
              } else if (duplicateIds.has(patientNumber)) {
                duplicatePatients.push(tei);
              } else {
                uniqueTeis.push(tei);
              }
            });

            console.log('# of Unique TEIs to migrate to OMRS ::', uniqueTeis.length);
            console.log('# Duplicate Patients found::', duplicatePatients.length);

            // return { uniqueTeis, duplicatePatients, filteredTeis, missingPatientNumber };
            return {
              ...state,
              // data: {},
              // references: [],
              uniqueTeis,
              teisWithOMRSID,
              duplicatePatients,
              missingPatientNumber,
            };
          });

          get('optionGroups/kdef7pUey9f', {
            fields: 'id,displayName,options[id,displayName,code]',
          });

          // fn(({ data, ...state }) => {
          //   state.locations = data;
          //   return state;
          // });

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          //Define gender options and prepare newPatientUuid and identifiers
          fn(state => {
            const { uniqueTeis } = state;
            if (uniqueTeis.length > 0)
              console.log('# of TEIs to send to OpenMRS: ', uniqueTeis.length);
            if (uniqueTeis.length === 0)
              console.log('No data fetched in step prior to sync.');

            return state;
          });

          //First we generate a unique OpenMRS ID for each patient
          each(
            $.uniqueTeis,
            post(
              'idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier'
            ).then(state => {
              state.identifiers ??= [];
              state.identifiers.push(state.data.identifier);
              return state;
            })
          );

          // Then we map uniqueTeis to openMRS data model
          fn(state => {
            const {
              uniqueTeis,
              nationalityMap,
              genderOptions,
              identifiers,
              statusMap,
              locations,
            } = state;

            const getValueForCode = (attributes, code) => {
              const result = attributes.find(attribute => attribute.code === code);
              return result ? result.value : undefined;
            };

            const calculateDOB = age => {
              if (!age) return age;
              const currentDate = new Date();
              const currentYear = currentDate.getFullYear();
              const birthYear = currentYear - age;

              const birthday = new Date(
                birthYear,
                currentDate.getMonth(),
                currentDate.getDay()
              );

              return birthday.toISOString().replace(/\.\d+Z$/, '+0000');
            };

            state.patients = uniqueTeis.map((d, i) => {
              const patientNumber =
                getValueForCode(d.attributes, 'patient_number') || d.trackedEntity; // Add random number for testing + Math.random()

              const lonlat = d.attributes.find(a => a.attribute === 'rBtrjV1Mqkz')?.value;
              const location = lonlat
                ? locations.options.find(o => o.code === lonlat)?.displayName
                : undefined;

              let countyDistrict, cityVillage;

              if (location) {
                const match = location.match(/^(.*?)\s*\((.*?)\)/);
                if (match) {
                  [, countyDistrict, cityVillage] = match;
                  cityVillage = cityVillage.split('-')[0].trim(); // Remove country code and trim
                }
              }

              const attributes = d.attributes
                .filter(a => a.attribute in state.patientAttributes)
                .map(a => {
                  let value = a.value;

                  if (a.displayName === 'Nationality') {
                    value = nationalityMap[a.value];
                  } else if (a.displayName.includes(' status')) {
                    value = statusMap[a.value];
                  }

                  if (value) {
                    return {
                      attributeType: state.patientAttributes[a.attribute].trim(),
                      value,
                    };
                  }
                })
                .filter(Boolean);

              return {
                patientNumber,
                person: {
                  age: getValueForCode(d.attributes, 'age'),
                  gender: genderOptions[getValueForCode(d.attributes, 'sex')] ?? 'U',
                  birthdate:
                    d.attributes.find(a => a.attribute === 'WDp4nVor9Z7')?.value ??
                    calculateDOB(getValueForCode(d.attributes, 'age')),
                  // d.attributes.find(a => a.attribute === 'WDp4nVor9Z7')?.value ?
                  // calculateDOB(getValueForCode(d.attributes, 'age')) : '1900-01-01',
                  birthdateEstimated: d.attributes.find(
                    a => a.attribute === 'WDp4nVor9Z7'
                  )
                    ? true
                    : false,
                  names: [
                    {
                      familyName:
                        d.attributes.find(a => a.attribute === 'fa7uwpCKIwa')?.value ??
                        'unknown',
                      givenName:
                        d.attributes.find(a => a.attribute === 'Jt9BhFZkvP2')?.value ??
                        'unknown',
                    },
                  ],
                  addresses: [
                    {
                      country: 'Iraq',
                      stateProvince: 'Ninewa',
                      countyDistrict,
                      cityVillage,
                    },
                  ],
                  attributes,
                },
                identifiers: [
                  {
                    identifier: identifiers[i], //OMRS-generated identifier - see above
                    identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',
                    location: 'cf6fa7d4-1f19-4c85-ac50-ff824805c51c', //default location old:44c3efb0-2583-4c80-a79e-1f756a03c0a1
                    preferred: true,
                  },
                  {
                    uuid: d.trackedEntity,
                    identifier: patientNumber, //Patient Number from DHIS2
                    identifierType: '8d79403a-c2cc-11de-8d13-0010c6dffd0f', //Old Identification number
                    location: 'cf6fa7d4-1f19-4c85-ac50-ff824805c51c', //default location
                    preferred: false, //default value for this identifiertype
                  },
                ],
              };
            });

            return state;
          });

          // Creating patients in openMRS
          each(
            $.patients,
            upsert(
              'patient',
              {
                q: $.data.patientNumber,
                limit: 1,
                startIndex: 0
              },
              state => {
                const { patientNumber, ...patient } = state.data;
                console.log(
                  'Upserting patient record...',
                  JSON.stringify(patient, null, 2)
                );
                return patient;
              },
              state => {
                state.newPatientUuid ??= [];
                //console.log('state.references ::', state.references)
                state.newPatientUuid.push({
                  patient_number: state.references.at(-1)?.patientNumber,
                  omrs_patient_number: state.references
                    .at(-1)
                    ?.identifiers.find(
                      i => (i.identifierType === `${state.openmrsAutoId}`)
                    ),
                  uuid: state.data.uuid,
                });
                return state;
              }
            )
          );

          // Clean up state
          fn(({ data, references, ...state }) => state);

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          fn(state => {
            if (state.newPatientUuid.length === 0) {
              console.log('No data fetched in step prior to sync.');
            }

            console.log(
              'newPatientUuid ::',
              JSON.stringify(state.newPatientUuid, null, 2)
            );
            return state;
          });

          // Update TEI on DHIS2
          each(
            $.newPatientUuid,
            upsert(
              'trackedEntityInstances',
              {
                ou: $.orgUnit,
                program: $.program,
                filter: [`${$.dhis2PatientNumberAttributeId}:Eq:${$.data.patient_number}`],
              },
              state => {
                const payload = {
                  orgUnit: state.orgUnit,
                  program: state.program,
                  trackedEntityType: 'cHlzCA2MuEF',
                  attributes: [
                    {
                      attribute: `${state.dhis2PatientNumberAttributeId}`,
                      value: `${state.data.patient_number}`,
                    }, //DHIS2 patient number to use as lookup key
                    { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
                    {
                      attribute: `${state.openmrsAutoIdAttributeId}`,
                      value: `${state.data.omrs_patient_number.identifier}`,
                    }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
                  ],
                }

                console.log('final payload to send to dhis2:', payload)
                return payload;
              }
            )
            // {
            //   orgUnit: $.orgUnit,
            //   program: $.program,
            //   trackedEntityType: 'cHlzCA2MuEF',
            //   attributes: [
            //     {
            //       attribute: `${$.dhis2PatientNumberAttributeId}`,
            //       value: `${state.data.patient_number}`,
            //     }, //DHIS2 patient number to use as lookup key
            //     { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
            //     {
            //       attribute: `${state.openmrsAutoIdAttributeId}`,
            //       value: `${state.data.omrs_patient_number.identifier}`,
            //     }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
            //   ],
            // },
          );

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          fn(state => {
            const code = 'DUPLICATE_PATIENT_NUMBERS';
            const description = `Found ${state.duplicatePatients.length} TIEs with duplicate patient numbers`;
            const message = `${code}: ${description}`;
            const patientNumbers = state.duplicatePatients.map(
              patient =>
                patient.attributes.find(attr => attr.code === 'patient_number').value
            );

            const details = {
              code,
              description,
              duplicatePatientNumbers: patientNumbers,
            };
            const e = new Error(message);
            e.details = details;
            console.error(e.details);
            throw e;
          });

      Validate-TEIs-with-OMRS-Id:
        name: Validate TEIs with OMRS Id
        adaptor: '@openfn/language-openmrs@5.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          fn((state) => {
            state.patientUuids = state.teisWithOMRSID.map((patient) => {
              return patient.attributes.find(
                (attr) => attr.displayName === "OpenMRS patient UID"
              )?.value;
            });
            state.notFound ??= [];
            return state;
          });

          each(
            $.patientUuids,
            get(`patient/${$.data}`).catch((error, state) => {
              if (error) {
                const tei = state.teisWithOMRSID.find(
                  (tei) =>
                    tei.attributes.find(
                      (attr) => attr.displayName === "OpenMRS patient UID"
                    )?.value === state.data
                );
                state.notFound.push({ patient: state.data, tei: tei.trackedEntity });
              }
              return state;
            })
          );

          fnIf($.notFound.length > 0, (state) => {
            const details = state.notFound
              .map(
                ({ patient, tei }) =>
                  `Patient not found in OMRS for TEI:${tei} with OMRS ID: ${patient}.`
              )
              .join("\n");
            const e = new Error(details);
            throw e;
          });

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: false
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
      Get-Teis-and-Locations->Validate-TEIs-with-OMRS-Id:
        source_job: Get-Teis-and-Locations
        target_job: Validate-TEIs-with-OMRS-Id
        condition_type: js_expression
        condition_label: has-teisWithOMRSID
        condition_expression: |
          !state.errors && state. teisWithOMRSID.length > 0
        enabled: true
  130-wf2-omrs-dhis2-new:
    name: 130-wf2-omrs-dhis2-new
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          cursor($.lastRunDateTime || "2025-03-20T06:01:24.000Z");

          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({ q: "IQ", v: "full", limit: "100" });
          fn((state) => {
            const { cursor, data } = state;
            console.log("Filtering patients since cursor:", cursor);
            console.log('Patient fetched', data.results.length)

            state.patients = data.results.filter(({ auditInfo }) => {
              const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
              return lastModified > cursor;
            });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });

          // Fetch all encounters
          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );

          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });

          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [...new Set(searchPatientUuids, encounterPatientUuids)];

            console.log('inbothResults', inbothResults.length)
            console.log('patient-search-array', onlyInSearchPatient.length)
            console.log('r4-encounter-array', onlyInR4Encounter.length)
            console.log('combined uuids', patientUuids.length)

            return { cursor, lastRunDateTime, patients, patientUuids };
          });

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          const isValidUUID = id => {
            if (!id || typeof id !== 'string') return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get('mosul-metadata-mappings-staging').then(state => {
            state.optsMap = state.data
              .filter(i => i.key.includes('optsMap-value-'))
              .map(i => i.value);

            state.identifiers = state.data
              .filter(i => i.key.includes('identifiers-value-'))
              .map(i => i.value);
            state.syncedAt = state.data.find(i => i.key === 'syncedAt')?.value;
            state.formMetadata = state.data.find(i => i.key === 'formMetadata')?.value;
            state.placeOflivingMap = state.data.find(i => i.key === 'placeOflivingMap')?.value;
            state.sourceFile = state.data.filter(i => i.key === 'sourceFile')?.[0]?.value;
            state.fileDateModified = state.data.filter(
              i => i.key === 'fileDateModified'
            )?.[0]?.value;
            state.optionSetKey = state.data.filter(
              i => i.key === 'optionSetKey'
            )?.[0]?.value;
            state.formMaps = state.data.find(i => i.key === 'formMaps')?.value;

            delete state.data
            delete state.references
            return state;
          });

          fn(state => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                form =>
                  isValidUUID(form['OMRS form.uuid']) &&
                  form['OMRS Form Version'] === 'v4-2025'
              )
              .map(form => form['OMRS form.uuid']);
            rest.formUuids = formMetadata
              .filter(form => isValidUUID(form['OMRS form.uuid']) &&
                form['Workflow'] === 'WF2')
              .map(form => form['OMRS form.uuid']);

            
            rest.patientProgramStage = "vN61drMkGqO"

          // rest.orgUnit = "sUpt0j2GmBD"
            rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
              'dhis2 attribute id'
            ];
            // rest.program = "dWdzxMuKa8Z"
            rest.program = identifiers.find(i => i.type === 'PROGRAM')?.[
              'dhis2 attribute id'
            ];
            // rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              i => i.type === 'DHIS2_PATIENT_NUMBER'
            )?.['omrs identifierType']; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find(i => i.type === 'OPENMRS_AUTO_ID')?.[
              'omrs identifierType'
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });

          fn(state => {
            state.genderOptions = state.optsMap
              .filter(o => o['OptionSet name'] === 'Sex - Patient')
              .reduce((acc, value) => {
                acc[value['value.uuid - External ID']] = value['DHIS2 Option Code'];
                return acc;
              }, {});

            return state;
          });

      Upsert-Parent-TEIs:
        name: Upsert Parent TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildPatientsUpsert = (globals, dhis2Config, patient) => {
            const { placeOflivingMap, genderOptions, formMaps, optsMap } = globals;
            const dateCreated = patient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findOptsUuid = (uuid) =>
              patient.person.attributes.find((a) => a.attributeType.uuid === uuid)?.value
                ?.uuid ||
              patient.person.attributes.find((a) => a.attributeType.uuid === uuid)?.value;

            const findOptCode = (optUuid) =>
              optsMap.find((o) => o["value.uuid - External ID"] === optUuid)?.[
              "DHIS2 Option Code"
              ];

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const omrsId = findIdentifierByUuid(
              patient.identifiers,
              dhis2Config.openmrsAutoId
            );
            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: patient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: patient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(
                    patient.identifiers,
                    dhis2Config.dhis2PatientNumber
                  ) || omrsId, //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: omrsId,
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: patient.uuid,
              },
              {
                attribute: "qptKDiv9uPl",
                value: genderOptions[patient.person.gender],
              },
              {
                attribute: "T1iX2NuPyqS",
                value: patient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: patient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[patient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);
            //console.log('standardAttr ::', JSON.stringify(standardAttr, null,2))
            //console.log('filteredAttr ::', JSON.stringify(filteredAttr, null,2))

            const payload = {
              query: {
                ou: dhis2Config.orgUnit,
                program: dhis2Config.program,
                filter: [`AYbfTPYMNJH:Eq:${patient.uuid}`], //upsert on omrs.patient.uid
              },
              data: {
                program: dhis2Config.program,
                orgUnit: dhis2Config.orgUnit,
                trackedEntityType: "cHlzCA2MuEF",
                attributes: [...filteredAttr, ...filteredStatusAttr],
              },
            };

            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (patient.isNewPatient) {
              console.log("create enrollment");
              const enrollments = [
                {
                  orgUnit: dhis2Config.orgUnit,
                  program: dhis2Config.program, // searching by MH program but change this EMR
                  programStage: dhis2Config.patientProgramStage, //'MdTtRixaC1B',
                  enrollmentDate: dateCreated,
                },
              ];
              payload.data.enrollments = enrollments;
            }

            return payload;
          };

          const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          each(
            $.patients,
            get(
              "tracker/trackedEntities",
              {
                orgUnit: $.orgUnit,
                filter: [`AYbfTPYMNJH:Eq:${$.data?.uuid}`],
                program: $.program,
              },
              {},
              async (state) => {
                const {
                  placeOflivingMap,
                  genderOptions,
                  formMaps,
                  optsMap,
                  program,
                  orgUnit,
                  openmrsAutoId,
                  dhis2PatientNumber,
                  patientProgramStage,
                } = state;
                const globals = { placeOflivingMap, genderOptions, formMaps, optsMap };
                const dhis2Config = {
                  orgUnit,
                  program,
                  openmrsAutoId,
                  dhis2PatientNumber,
                  patientProgramStage,
                };
                const patient = state.references.at(-1);
                console.log(patient.uuid, "patient uuid");
                patient.isNewPatient = state.data.instances.length === 0;

                const parentMapping = buildPatientsUpsert(globals, dhis2Config, patient);
                // const childMapping = buildPatientsUpsert()
                state.patientsUpsert ??= [];
                state.patientsUpsert.push(parentMapping);
                await delay(2000);
                return state;
              }
            )
          );

          // Upsert TEIs to DHIS2
          each(
            $.patientsUpsert,
            upsert('trackedEntityInstances', $.data.query, $.data.data)
          );
          fn(state => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              genderOptions,
              identifiers,
              ...next
            } = state;

            next.patientUuids = patients.map(p => p.uuid);
            return next;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Fetch patient encounters
          each(
            $.patientUuids,
            get('encounter', { patient: $.data, v: 'full' }).then(state => {
              state.allEncounters ??= [];
              state.allEncounters.push(
                // v2FormsUuids are for mental health forms
                // ...state.data.results.filter(e =>
                //   state.v2FormUuids.includes(e?.form?.uuid)
                // )
                ...state.data.results.filter(e =>
                  state.formUuids.includes(e?.form?.uuid)
                )
              );

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map(formUuid =>
                state.data.results
                  .filter(
                    e =>
                      e.auditInfo.dateCreated >= state.cursor &&
                      e?.form?.uuid === formUuid
                  )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters.map(pe => {
                const isLatestForm = pe.find(e => {
                  return state.formMaps[e?.form?.uuid]?.syncType === 'latest'
                })
                if (isLatestForm) {
                  return [isLatestForm]
                } else {
                  const allPatientEncounter = pe.filter(e => state.formMaps[e?.form?.uuid]?.syncType === 'all')
                  return allPatientEncounter
                }
              }).flat()

              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );

              return state;
            })
          );

          fn(state => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map(
                ({ uuid, patient, obs, form, encounterDatetime }) => ({
                  uuid,
                  patient,
                  obs,
                  form,
                  encounterDatetime,
                })
              )
              console.log(next.encounters.length, '# of new encounters to sync to dhis2');
            } else {
              console.log('No encounters found for cursor: ', next.cursor);
            }
            next.allEncounters = next.allEncounters?.map(
              ({ uuid, patient, obs, form, encounterDatetime }) => ({
                uuid,
                patient,
                obs,
                form,
                encounterDatetime,
              })
            );

            return next;
          });

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          fn(state => {
            // Group encounters by patient UUID
            state.encountersByPatient = state.encounters.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return state;
          })

          each(state => Object.keys(state.encountersByPatient), get('tracker/trackedEntities', {
            orgUnit: $.orgUnit,
            program: $.program,
            filter: [`AYbfTPYMNJH:Eq:${$.data}`]
          }).then(state => {
            const patientUid = state.references.at(-1)

            const tei = state.data?.instances?.[0];
            if (tei?.trackedEntity) {
              console.log('Parent TEI found:', tei.trackedEntity)
              state.parentTeis ??= {};
              state.parentTeis[patientUid] = tei;
            } else {
              console.log('Parent TEI Not Found for Patient:', patientUid)
              state.missingParentTeis ??= {}
              state.missingParentTeis[patientUid] = state.encountersByPatient[patientUid]
            }
            return state
          }))

          each(
            $.encounters,
            get('tracker/trackedEntities', state => ({
              orgUnit: state.formMaps[state.data.form.uuid].orgUnit,
              program: state.formMaps[state.data.form.uuid].programId,
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: '*,enrollments[*],enrollments[events[*]], relationships[*]',
            })).then(async state => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, 'Encounter patient uuid');

              const { trackedEntity, enrollments } = state.data?.instances?.[0] || {};
              if (trackedEntity) {
                state.childTeis ??= {};
                state.childTeis[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments?.[0]?.events,
                  enrollment: enrollments?.[0]?.enrollment,
                };
              } else {
                state.teisToCreate ??= {}
                const { attributes, trackedEntityType } = state.parentTeis[encounter.patient.uuid]
                const program = state.formMaps[encounter.form.uuid].programId
                const orgUnit = state.formMaps[encounter.form.uuid].orgUnit

                state.teisToCreate[encounter.patient.uuid] = {
                  trackedEntityType,
                  enrollments: [{
                    orgUnit,
                    program,
                    enrollmentDate: new Date().toISOString().split('T')[0],
                  }],
                  attributes,
                  orgUnit,
                  program
                }
              }

              await delay(2000);
              return state;
            })
          );

          each(state => {
            return state?.teisToCreate ? Object.entries(state?.teisToCreate) : []
          }, create('trackedEntityInstances', state => {
            const payload = state.data[1]
            return payload
          }).then(state => {
            const [patient, payload] = state.references.at(-1)
            const trackedEntity = state.data?.response?.importSummaries[0]?.reference
            state.childTeis ??= {}
            state.createdTeis ??= []
            state.createdTeis.push(trackedEntity)
            state.childTeis[patient] = { trackedEntity }
            return state
          }))

          each($?.createdTeis || [], get(`tracker/trackedEntities/${$.data}`, { fields: 'attributes[*],enrollments,trackedEntity' }).then(state => {
            const { trackedEntity, enrollments, attributes } = state.data || {};
            console.log(state.data)
            const patientUuid = attributes.find(a => a.attribute === 'AYbfTPYMNJH').value

            console.log('Fetched Teis', state.data)
            state.childTeis ??= {};
            state.childTeis[patientUuid] = {
              trackedEntity,
              events: enrollments?.[0]?.events,
              enrollment: enrollments?.[0]?.enrollment,
            };

            return state
          }))


          fnIf($.childTeis && $.parentTeis, state => {
            const { childTeis, parentTeis } = state
            state.relationshipsMapping = Object.keys(childTeis).map(uuid => {
              const childTei = childTeis[uuid].trackedEntity
              const parentTei = parentTeis[uuid].trackedEntity

              if (childTei != parentTei) {
                return {
                  "from": {
                    "trackedEntityInstance": {
                      "trackedEntityInstance": parentTei
                    }
                  },
                  "to": {
                    "trackedEntityInstance": {
                      "trackedEntityInstance": childTei
                    }
                  },
                  "relationshipType": "cJJTZ51EK24"
                }
              }

            }).filter(Boolean)
            return state
          })

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter
          create(
            'tracker',
            {
              events: state => {
                console.log(
                  'Creating events for: ',
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: 'UID',
                importStrategy: 'CREATE_AND_UPDATE',
              },
            }
          );

          const findlatestAnswer = (encounters, conceptUuid) => {
            const latestAnswer = encounters.reduce((acc, e) => {
              const answer = e.obs.find((o) => o.concept.uuid === conceptUuid);
              if (answer) {
                const personUuid = answer.person.uuid;
                if (
                  !acc[personUuid] ||
                  new Date(answer.obsDatetime) > new Date(acc[personUuid].obsDatetime)
                ) {
                  acc[personUuid] = { ...answer, formUuid: e.form.uuid };
                }
              }
              return acc;
            }, {});

            return Object.values(latestAnswer);
          };

          fn((state) => {
            const {
              encounters,
              childTeis,
              parentTeis,
              program,
              orgUnit,
              optsMap,
              // Lighten state by removing unused properties
              formMaps,
              optionSetKey,
              eventsMapping,
              formUuids,
              references,
              ...next
            } = state;

            const genderMap = optsMap
              .filter((o) => o["DHIS2 DE UID"] === "qptKDiv9uPl")
              .reduce((acc, obj) => {
                acc[obj["value.display - Answers"]] = obj["DHIS2 Option Code"];
                return acc;
              }, {});

            const latestGenderUpdate = findlatestAnswer(
              encounters,
              "ec42d68d-3e23-43de-b8c5-a03bb538e7c7"
            );

            const genderUpdated = latestGenderUpdate
              .map((answer) => {
                const parentTei = parentTeis[answer?.person?.uuid].trackedEntity
                const childTei = childTeis[answer?.person?.uuid].trackedEntity

                const mappings = [];
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "qptKDiv9uPl", //gender
                      value: genderMap[answer.value.display],
                    },
                    {
                      attribute: "AYbfTPYMNJH", //OpenMRS Patient UID to use to upsert TEI
                      value: answer.person.uuid,
                    },
                  ],
                };
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }
                if (childTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntity: childTei,
                    program: formMaps[answer.formUuid].programId,
                    orgUnit: formMaps[answer.formUuid].orgUnit,
                  });
                }
                if (parentTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntity: parentTei,
                    program,
                    orgUnit,
                  });
                }
                return mappings
              })
              .filter(Boolean)
              .flat();

            const latestEducationUpdate = findlatestAnswer(
              encounters,
              "cc3a5a7a-abfe-4630-b0c0-c1275c6cbb54"
            );

            // console.log({ latestEducationUpdate })
            const educationUpdated = latestEducationUpdate
              .map((answer) => {
                const parentTei = parentTeis[answer?.person?.uuid]?.trackedEntity
                const childTei = childTeis[answer?.person?.uuid]?.trackedEntity
                console.log({ parentTei, childTei })
                const mappings = []
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "Dggll4f9Efj", //education
                      value: optsMap.find(
                        (o) => o["value.display - Answers"] === answer.value.display
                      )?.["DHIS2 Option Code"], //map to DHIS2 Option Code in optsMap
                    },
                  ],
                }
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }

                if (parentTei) {
                  mappings.push({
                    trackedEntity: parentTei,
                    program,
                    orgUnit,
                    ...sharedMapping
                  })
                }
                if (childTei) {
                  mappings.push({
                    trackedEntity: childTei,
                    program: formMaps[answer.formUuid].programId,
                    orgUnit: formMaps[answer.formUuid].orgUnit,
                    ...sharedMapping
                  })
                }

                return mappings
              })
              .filter(Boolean)
              .flat();

            return {
              ...next,
              teisToUpdate: [...genderUpdated, ...educationUpdated],
            };
          });

          fnIf(
            (state) => state.teisToUpdate.length === 0,
            ({ lastRunDateTime }) => ({ lastRunDateTime })
          );

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Update TEIs
          create(
            'tracker',
            { trackedEntities: $.teisToUpdate },
            { params: { async: false, importStrategy: 'UPDATE' } }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@latest'
        credential: null
        body: |
          const getRangePhq = input => {
            if (input >= 20) return '>20';
            if (input >= 15) return '15_19';
            if (input >= 10) return '10_14';
            if (input >= 5) return '5_9';
            return '0_4';
          };
          const processAnswer = (
            answer,
            conceptUuid,
            dataElement,
            optsMap,
            optionSetKey,
            formUuid
          ) => {
            if (typeof answer.value === 'object') {
              const isDiagnosisByPsychologist =
                conceptUuid === '722dd83a-c1cf-48ad-ac99-45ac131ccc96' &&
                dataElement === 'pN4iQH4AEzk';
              if (isDiagnosisByPsychologist) {
                console.log('Yes done by psychologist..');
                return '' + answer.value.uuid === '278401ee-3d6f-4c65-9455-f1c16d0a7a98';
              }

              const isTrueOnlyQuestion =
                conceptUuid === '54e8c1b6-6397-4822-89a4-cf81fbc68ce9' &&
                dataElement === 'G0hLyxqgcO7';

              if (isTrueOnlyQuestion) {
                console.log('True only question detected..', dataElement);
                return answer.value.uuid === '681cf0bc-5213-492a-8470-0a0b3cc324dd'
                  ? 'true'
                  : undefined;
              }

              const optionKey = `${formUuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                o =>
                  o['value.uuid - External ID'] === answer.value.uuid &&
                  o['DHIS2 Option Set UID'] === matchingOptionSet
              );
              const matchingOption =
                opt?.['DHIS2 Option Code'] ||
                opt?.['DHIS2 Option name'] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              // console.log(`matchingOption value: "${matchingOption}" for`);
              // console.log({
              //   optionKey,
              //   conceptUid: answer.concept.uuid,
              //   'answer.value.uid': answer.value.uuid,
              //   'answer.value.display': answer.value.display,
              //   matchingOption,
              //   matchingOptionSet,
              // });

              if (matchingOption === 'FALSE' || matchingOption === 'No') {
                return 'false';
              }
              if (matchingOption === 'TRUE' || matchingOption === 'Yes') {
                return 'true';
              }

              return matchingOption || '';
            }

            const PHQ9_CONCEPT_UUIDS = [
              '5f3d618e-5c89-43bd-8c79-07e4e98c2f23',
              '6545b874-f44d-4d18-9ab1-7a8bb21c0a15',
            ];
            const isPhq9Score =
              typeof answer.value === 'number' &&
              PHQ9_CONCEPT_UUIDS.includes(conceptUuid);
            if (isPhq9Score) {
              return getRangePhq(answer.value);
            }
            return answer.value;
          };

          const processNoAnswer = (encounter, conceptUuid, dataElement) => {
            const isEncounterDate =
              conceptUuid === 'encounter-date' &&
              ['CXS4qAJH2qD', 'I7phgLmRWQq', 'yUT7HyjWurN', 'EOFi7nk2vNM'].includes(
                dataElement
              );
            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace('+0000', '');
            }
            return '';
          };

          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find(o => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) =>
            encounter.obs.find(o => o.concept.uuid === conceptUuid);

          // Concept UUIDs
          const CONCEPTS = {
            BASELINE_CONCEPT: '22809b19-54ca-4d88-8d26-9577637c184e',
            PRIORITY_1: '45b39cbf-0fb2-4682-8544-8aaf3e07a744',
            PRIORITY_2: 'ee1b7973-e931-494e-a9cb-22b814b4d8ed',
            PRIORITY_3: '92a92f62-3ff6-4944-9ea9-a7af23949bad',
            OTHER_SPECIFY: 'e08d532b-e56c-43dc-b831-af705654d2dc',
            PRECIPITATING_EVENT_1: 'd5e3d927-f7ce-4fdd-ac4e-6ad0b510b608',
            PRECIPITATING_EVENT_2: '54a9b20e-bce5-4d4a-8c9c-e0248a182586',
            PRECIPITATING_EVENT_3: 'e0d4e006-85b5-41cb-8a21-e013b1978b8b',
            PRECIPITATING_EVENT_OTHER: '790b41ce-e1e7-11e8-b02f-0242ac130002',
          };

          // DHIS2 Data Elements
          const DATA_ELEMENTS = {
            BASELINE: 'pN4iQH4AEzk',
            PRIORITY_1_OTHER: 'pj5hIE6iyAR',
            PRIORITY_2_OTHER: 'Em5zvpdd5ha',
            PRIORITY_3_OTHER: 'aWsxYkJR8Ua',
            PRECIPITATING_EVENT_1_OTHER: 'm8qis4iUOTo',
            PRECIPITATING_EVENT_2_OTHER: 'mNK6CITsdWD',
            PRECIPITATING_EVENT_3_OTHER: 'jocqmYW394G',
          };

          // Prepare DHIS2 data model for create events
          fn(state => {
            const handleMissingRecord = (data, state) => {
              const { uuid, display } = data.patient;

              console.log(uuid, 'Patient is missing trackedEntity && enrollment');

              state.missingRecords ??= {};
              state.missingRecords[uuid] ??= {
                encounters: [],
                patient: display,
              };

              state.missingRecords[uuid].encounters.push(data.uuid);
            };

            state.eventsMapping = state.encounters
              .map(encounter => {
                const form = state.formMaps[encounter.form.uuid];
                if (!form?.dataValueMap) {
                  return null;
                }
                const { trackedEntity, enrollment, events } =
                  state.childTeis[encounter.patient.uuid] || {};

                if (!trackedEntity || !enrollment) {
                  handleMissingRecord(encounter, state);
                  return null;
                }
                let formDataValues = Object.keys(form.dataValueMap)
                  .map(dataElement => {
                    const conceptUuid = form.dataValueMap[dataElement];
                    const obsAnswer = encounter.obs.find(
                      o => o.concept.uuid === conceptUuid
                    );
                    const answer = obsAnswer;
                    const value = answer
                      ? processAnswer(
                          answer,
                          conceptUuid,
                          dataElement,
                          state.optsMap,
                          state.optionSetKey,
                          encounter.form.uuid
                        )
                      : processNoAnswer(encounter, conceptUuid, dataElement);
                    if (value) {
                      return { dataElement, value };
                    }
                  })
                  .filter(d => d);

                let customMapping = [];

                if (
                  encounter.form.description.includes('F11-Family Planning Assessment')
                ) {
                  const answers = encounter.obs.filter(
                    o => o.concept.uuid === '30b2d692-6a05-401f-8ede-13e027b8a436'
                  );

                  const mappingConfig = [
                    { dataElement: 'DYTLOoEKRas', index: 0 },
                    { dataElement: 'ddTrzQtQUGz', index: 1 },
                    { dataElement: 'fuNs3Uzspsm', index: 2 },
                  ];

                  mappingConfig.forEach(config => {
                    if (answers[config.index]) {
                      customMapping.push({
                        dataElement: config.dataElement,
                        value: state.optsMap.find(
                          o =>
                            o['value.display - Answers'] ===
                            answers[config.index]?.value?.display
                        )?.['DHIS2 Option Code'],
                      });
                    }
                  });
                }
                if (encounter.form.description.includes('F13-PNC')) {
                  const answers = encounter.obs.filter(
                    o => o.concept.uuid === '22809b19-54ca-4d88-8d26-9577637c184e'
                  );

                  // Define mapping configurations
                  const mappingConfig = [
                    { dataElement: 'ErtqJsZINyX', index: 0 },
                    { dataElement: 'wWAMdsjks50', index: 1 },
                    { dataElement: 'Dh1ocjojOrC', index: 2 },
                    { dataElement: 'KR03PHkzVw1', index: 3 },
                    { dataElement: 'kDA55sgLAwY', index: 4 },
                  ];

                  // Only add mappings for answers that exist
                  mappingConfig.forEach(config => {
                    if (answers[config.index] !== undefined) {
                      customMapping.push({
                        dataElement: config.dataElement,
                        value: state.optsMap.find(
                          o =>
                            o['value.display - Answers'] ===
                            answers[config.index]?.value?.display
                        )?.['DHIS2 Option Code'],
                      });
                    }
                  });
                }

                if (encounter.form.description.includes('F29-MHPSS Baseline v2')) {
                  customMapping.push({
                    dataElement: DATA_ELEMENTS.BASELINE,
                    value: findAnswerByConcept(encounter, CONCEPTS.BASELINE_CONCEPT)
                      ? true
                      : false,
                  });

                  const priority1 = findObsByConcept(encounter, CONCEPTS.PRIORITY_1);
                  if (priority1 && priority1?.value?.display === 'Other') {
                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRIORITY_1_OTHER,
                      value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                    });
                  }

                  const priority2 = findObsByConcept(encounter, CONCEPTS.PRIORITY_2);
                  if (priority2 && priority2?.value?.display === 'Other') {
                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRIORITY_2_OTHER,
                      value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                    });
                  }

                  const priority3 = findObsByConcept(encounter, CONCEPTS.PRIORITY_3);
                  if (priority3 && priority3?.value?.display === 'Other') {
                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRIORITY_3_OTHER,
                      value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY).value,
                    });
                  }

                  const precipitatingEvent1 = findObsByConcept(
                    encounter,
                    CONCEPTS.PRECIPITATING_EVENT_1
                  );
                  const otherValue = encounter.obs.find(o =>
                    o.display.includes('Past / Precipitating Events - Other')
                  );

                  if (
                    precipitatingEvent1 &&
                    precipitatingEvent1?.value?.uuid === otherValue?.value?.uuid
                  ) {
                    const opt = state.optsMap.find(
                      o => o['value.uuid - External ID'] === otherValue?.value?.uuid
                    );

                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRECIPITATING_EVENT_1_OTHER,
                      value: opt?.['DHIS2 Option Code'],
                    });
                  }

                  const precipitatingEvent2 = findObsByConcept(
                    encounter,
                    CONCEPTS.PRECIPITATING_EVENT_2
                  );

                  if (
                    precipitatingEvent2 &&
                    precipitatingEvent2?.value?.uuid === otherValue?.value?.uuid
                  ) {
                    const opt = state.optsMap.find(
                      o => o['value.uuid - External ID'] === otherValue?.value?.uuid
                    );
                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRECIPITATING_EVENT_2_OTHER,
                      value: opt?.['DHIS2 Option Code'],
                    });
                  }

                  const precipitatingEvent3 = findObsByConcept(
                    encounter,
                    CONCEPTS.PRECIPITATING_EVENT_3
                  );

                  if (
                    precipitatingEvent3 &&
                    precipitatingEvent3?.value?.uuid === otherValue?.uuid
                  ) {
                    const opt = state.optsMap.find(
                      o => o['value.uuid - External ID'] === otherValue?.value?.uuid
                    );
                    customMapping.push({
                      dataElement: DATA_ELEMENTS.PRECIPITATING_EVENT_3_OTHER,
                      value: opt?.['DHIS2 Option Code'],
                    });
                  }
                }

                if (encounter.form.description.includes('F30-MHPSS Follow-up v2')) {
                  const missedSession = encounter => {
                    if (
                      encounter.obs.find(
                        o => o.concept.uuid === '54e8c1b6-6397-4822-89a4-cf81fbc68ce9'
                      )?.value?.display === 'No'
                    ) {
                      return encounter.encounterDatetime.replace('+0000', '');
                    }
                    const lastFollowupEncounter = state.allEncounters.find(
                      e =>
                        e.form.description.includes('F30-MHPSS Follow-up v2') &&
                        e.patient.uuid === encounter.patient.uuid &&
                        e.uuid !== encounter.uuid &&
                        e.obs.find(
                          o => o.concept.uuid === '54e8c1b6-6397-4822-89a4-cf81fbc68ce9'
                        )?.value?.display === 'No'
                    );

                    if (lastFollowupEncounter) {
                      return lastFollowupEncounter.encounterDatetime.replace('+0000', '');
                    }

                    const f29Encounter = state.allEncounters.find(
                      e =>
                        e.form.description.includes('F29-MHPSS Baseline v2') &&
                        e.patient.uuid === encounter.patient.uuid
                    );
                    if (f29Encounter) {
                      return f29Encounter.encounterDatetime.replace('+0000', '');
                    }
                    return undefined;
                  };
                  const mapping = [
                    {
                      dataElement: 'jtKIoKducvE',
                      value: missedSession(encounter),
                    },
                  ];
                  customMapping.push(...mapping);
                }
                if (encounter.form.description.includes('F32-mhGAP Follow-up v2')) {
                  const missedSession = encounter => {
                    if (
                      encounter.obs.find(
                        o => o.concept.uuid === '54e8c1b6-6397-4822-89a4-cf81fbc68ce9'
                      )?.value?.display === 'No'
                    ) {
                      return encounter.encounterDatetime.replace('+0000', '');
                    }
                    const lastFollowupEncounter = state.allEncounters.find(
                      e =>
                        e.form.description.includes('F32-mhGAP Follow-up v2') &&
                        e.patient.uuid === encounter.patient.uuid &&
                        e.uuid !== encounter.uuid &&
                        e.obs.find(
                          o => o.concept.uuid === '54e8c1b6-6397-4822-89a4-cf81fbc68ce9'
                        )?.value?.display === 'No'
                    );

                    if (lastFollowupEncounter) {
                      return lastFollowupEncounter.encounterDatetime.replace('+0000', '');
                    }

                    const f31Encounter = state.allEncounters.find(
                      e =>
                        e.form.description.includes('F31-mhGAP Baseline v2') &&
                        e.patient.uuid === encounter.patient.uuid
                    );

                    if (f31Encounter) {
                      return f31Encounter.encounterDatetime.replace('+0000', '');
                    }
                  };
                  const changeInDiagnosis = encounter => {
                    const patientUuid = encounter.patient.uuid;
                    const previousChangeInDiagnosis = state.allEncounters
                      .find(
                        e =>
                          e.patient.uuid === patientUuid &&
                          e.form.description.includes('F32-mhGAP Follow-up v2') &&
                          encounter.uuid !== e.uuid
                      )
                      ?.obs.find(
                        o => o.concept.uuid === '22809b19-54ca-4d88-8d26-9577637c184e'
                      )?.value?.display;

                    const currentChangeInDiagnosis = encounter.obs.find(
                      o => o.concept.uuid === '22809b19-54ca-4d88-8d26-9577637c184e'
                    )?.value?.display;

                    if (
                      previousChangeInDiagnosis &&
                      previousChangeInDiagnosis !== currentChangeInDiagnosis
                    ) {
                      return true;
                    }

                    return false;
                  };
                  const mapping = [
                    {
                      dataElement: 'fMqEZpiRVZV',
                      value: missedSession(encounter),
                    },
                    {
                      dataElement: 'XBVRRpgkEvE',
                      value: changeInDiagnosis(encounter),
                    },
                  ];
                  customMapping.push(...mapping);
                }
                if (
                  encounter.form.description.includes('F33-MHPSS Closure v2') ||
                  encounter.form.description.includes('F34-mhGAP Closure v2')
                ) {
                  const lastScore = encounter.obs.find(
                    o => o.concept.uuid === '90b3d09c-d296-44d2-8292-8e04377fe027'
                  )?.value;

                  const filterOutScore = state.allEncounters.filter(e => {
                    const obs = e.obs.find(
                      o => o.concept.display === 'Mental Health Outcome Scale'
                    );
                    return e.uuid !== encounter.uuid && obs && obs?.value !== 0;
                  });

                  const firstScore = filterOutScore
                    .sort((a, b) => {
                      return (
                        new Date(a.encounterDatetime) - new Date(b.encounterDatetime)
                      );
                    })
                    .at(0)
                    ?.obs.find(
                      o => o.concept.display === 'Mental Health Outcome Scale'
                    )?.value;

                  customMapping.push({
                    dataElement: 'b8bjS7ah8Qi',
                    value: lastScore - firstScore,
                  });
                }
                formDataValues = formDataValues.filter(
                  item =>
                    item.dataElement !== DATA_ELEMENTS.PRIORITY_1_OTHER &&
                    item.dataElement !== 'KjgDauY9v4J' &&
                    item.dataElement !== 'DYTLOoEKRas'
                );

                return {
                  event: events.find(e => e.programStage === form.programStage)?.event,
                  program: state.formMaps[encounter.form.uuid]?.programId,
                  orgUnit: state.formMaps[encounter.form.uuid]?.orgUnit,
                  trackedEntity,
                  enrollment,
                  occurredAt: encounter.encounterDatetime.replace('+0000', ''),
                  programStage: form.programStage,
                  dataValues: [...formDataValues, ...customMapping],
                };
              })
              .filter(Boolean);

            return state;
          });

      Create-TEIs-Relationship:
        name: Create TEIs Relationship
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Check if relationship exist
          each($.relationshipsMapping, get('tracker/relationships', { trackedEntity: $.data.from.trackedEntityInstance.trackedEntityInstance }).then(state => {
            const relationship = state.references.at(-1)
            const toTei = relationship.to.trackedEntityInstance.trackedEntityInstance
            const hasRelationship = state.data.instances.find(r => r.to.trackedEntity.trackedEntity === toTei)
            state.relationshipsToCreate ??= []
            if (!hasRelationship) {
              state.relationshipsToCreate.push(relationship)
            }
            return state
          }))

          // Creating relationship between parent and child tei
          each($.relationshipsToCreate, create('relationships', $.data))
    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Mappings->Upsert-Parent-TEIs:
        source_job: Mappings
        target_job: Upsert-Parent-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-Parent-TEIs->Get-Encounters:
        source_job: Upsert-Parent-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters.length > 0

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors

        enabled: true
      Get-TEIs-and-Map-Answers->Create-TEIs-Relationship:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Create-TEIs-Relationship
        condition_type: js_expression
        condition_label: relationship-mapping
        condition_expression: |
          state?.relationshipsMapping?.length > 0
        enabled: true
      Create-TEIs-Relationship->Event-Mappings:
        source_job: Create-TEIs-Relationship
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-child-teis
        condition_expression: |
          state.childTeis && !state.errors
        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
  get-metadata-collections:
    name: get-metadata-collections
    jobs:
      Get-and-set-metadata-collections:
        name: Get and set metadata collections
        adaptor: '@openfn/language-common@2.1.1'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          // Check out the Job Writing Guide for help getting started:
          // https://docs.openfn.org/documentation/jobs/job-writing-guide

          // collections.remove("metadata-mappings", "mappings-*")

          //  collections.remove("metadata-mappings", "mapping*")

           collections.get("metadata_mappings", "mappingSets") // getting collections from metadata project

           collections.set("mosul-metadata-mappings", "mappingSets", state => {
            return state.data
           })

          collections.get("mosul-metadata-mappings", "mappingSets") 

    triggers:
      webhook:
        type: webhook
        enabled: false
    edges:
      webhook->Get-and-set-metadata-collections:
        source_trigger: webhook
        target_job: Get-and-set-metadata-collections
        condition_type: always
        enabled: true
  wf1-dhis2-omrs-migration:
    name: wf1-dhis2-omrs-migration
    jobs:
      Fetch-Metadata:
        name: Fetch Metadata
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/fetch-metadata.js

      Get-Teis-and-Locations:
        name: Get Teis and Locations
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/get-teis-and-locations.js

      Create-Patients:
        name: Create Patients
        adaptor: '@openfn/language-openmrs@4.2.0'
        credential: aisha@openfn.org-MSF-OMRS-admin
        body:
          path: workflows/wf1/create-patients.js

      Update-Teis:
        name: Update Teis
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf1/update-teis.js

      Alert-Admin-of-Duplicate-TEIs:
        name: Alert Admin of Duplicate TEIs
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body:
          path: workflows/wf1/alert-admin.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Fetch-Metadata:
        source_trigger: cron
        target_job: Fetch-Metadata
        condition_type: always
        enabled: true
      Fetch-Metadata->Get-Teis-and-Locations:
        source_job: Fetch-Metadata
        target_job: Get-Teis-and-Locations
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Create-Patients:
        source_job: Get-Teis-and-Locations
        target_job: Create-Patients
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.uniqueTeis.length > 0 && !state.errors

        enabled: true
      Create-Patients->Update-Teis:
        source_job: Create-Patients
        target_job: Update-Teis
        condition_type: on_job_success
        enabled: true
      Get-Teis-and-Locations->Alert-Admin-of-Duplicate-TEIs:
        source_job: Get-Teis-and-Locations
        target_job: Alert-Admin-of-Duplicate-TEIs
        condition_type: js_expression
        condition_label: has-duplicate-patients
        condition_expression: |
          state.duplicatePatients.length > 0 && !state.errors

        enabled: true
  wf2-omrs-dhis2:
    name: wf2-omrs-dhis2
    jobs:
      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/1-get-patients.js

      Mappings:
        name: Mappings
        adaptor: '@openfn/language-common@2.1.1'
        credential: mtuchi@openfn.org-mtuchi-api-token
        body:
          path: workflows/wf2/2-mappings.js

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/3-upsert-teis.js

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body:
          path: workflows/wf2/4-get-encounters.js

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/5-get-teis.js

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/6-create-events.js

      Update-TEIs:
        name: Update TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body:
          path: workflows/wf2/7-update-teis.js

      Event-Mappings:
        name: Event Mappings
        adaptor: '@openfn/language-common@latest'
        credential: null
        body:
          path: workflows/wf2/events-mapping.js

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Mappings->Upsert-TEIs:
        source_job: Mappings
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Mappings->Get-Encounters:
        source_job: Mappings
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state.encounters

        enabled: true
      Create-Events->Update-TEIs:
        source_job: Create-Events
        target_job: Update-TEIs
        condition_type: js_expression
        condition_label: has-gender-updated
        condition_expression: |
          state?.teisToUpdate?.length > 0

        enabled: true
      Get-Patients->Mappings:
        source_job: Get-Patients
        target_job: Mappings
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Event-Mappings:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Event-Mappings
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Event-Mappings->Create-Events:
        source_job: Event-Mappings
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
  wf3-omrs-dhis2:
    name: wf3-omrs-dhis2
    jobs:
      Get-Mappings-from-Collection:
        name: Get Mappings from Collection
        adaptor: '@openfn/language-common@2.3.0'
        credential: 'mtuchi@openfn.org-Collections-Config[Mtuchi]'
        body: |
          const isValidUUID = id => {
            if (!id || typeof id !== 'string') return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };

          collections.get('mosul-metadata-mappings-staging').then(state => {
            state.optsMap = state.data
              .filter(i => i.key.includes('optsMap-value-'))
              .map(i => i.value);

            state.identifiers = state.data
              .filter(i => i.key.includes('identifiers-value-'))
              .map(i => i.value);
            state.syncedAt = state.data.find(i => i.key === 'syncedAt')?.value;
            state.formMetadata = state.data.find(i => i.key === 'formMetadata')?.value; // filter form maps where formmap.workflow == "WF3"
            state.placeOflivingMap = state.data.find(i => i.key === 'placeOflivingMap')?.value;
            state.sourceFile = state.data.filter(i => i.key === 'sourceFile')?.[0]?.value;
            state.fileDateModified = state.data.filter(
              i => i.key === 'fileDateModified'
            )?.[0]?.value;
            state.optionSetKey = state.data.filter(
              i => i.key === 'optionSetKey'
            )?.[0]?.value;
            state.formMaps = state.data.find(i => i.key === 'formMaps')?.value;
            delete state.data
            delete state.references
            return state;
          });


          fn(state => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                form =>
                  isValidUUID(form['OMRS form.uuid']) &&
                  form['OMRS Form Version'] === 'v4-2025'
              )
              .map(form => form['OMRS form.uuid']);
            rest.formUuids = formMetadata
              .filter(form => isValidUUID(form['OMRS form.uuid']) &&
                form['Workflow'] === 'WF3')
              .map(form => form['OMRS form.uuid']);

            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];

            rest.orgUnit = "sUpt0j2GmBD"


            rest.program = "dWdzxMuKa8Z"

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              i => i.type === 'DHIS2_PATIENT_NUMBER'
            )?.['omrs identifierType']; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find(i => i.type === 'OPENMRS_AUTO_ID')?.[
              'omrs identifierType'
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });


          fn(state => {
            state.genderOptions = state.optsMap
              .filter(o => o['OptionSet name'] === 'Sex - Patient')
              .reduce((acc, value) => {
                acc[value['value.uuid - External ID']] = value['DHIS2 Option Code'];
                return acc;
              }, {});

            return state;
          });

      Get-Encounters:
        name: Get Encounters
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Fetch all encounters
          http
            .get('/ws/fhir2/R4/Encounter', {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then(state => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find(l => l.relation === 'next')
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split('/openmrs')[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then(state => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );



          fn(state => {
            console.log(
              'Total # of encounters fetched: ',
              state.allResponse?.entry?.length
            );

            state.patientUuids = [
              ...new Set(
                state.allResponse?.entry?.map(p =>
                  p.resource.subject.reference.replace('Patient/', '')
                )
              ),
            ];

            return state;
          });

          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
          // Fetch patient encounters
          each(
            $.patientUuids,
            get('encounter', { patient: $.data, v: 'full' }).then(state => {

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map(formUuid =>
                state?.data?.results.filter(
                  e =>
                    e.auditInfo.dateCreated >= state.cursor &&
                    e?.form?.uuid === formUuid
                )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters.map(e => e[0]).filter(e => e);
              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500)

              return state;
            })
          );

          fn(state => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map(
                ({ uuid, patient, obs, form, encounterDatetime }) => ({
                  uuid,
                  patient,
                  obs,
                  form,
                  encounterDatetime,
                })
              );
              console.log(next.encounters.length, '# of new encounters to sync to dhis2');
            } else {
              console.log('No encounters found for cursor: ', next.cursor);
            }


            // Group encounters by patient UUID
            next.encountersByPatient = next.encounters?.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return next;
          });

      Create-Events:
        name: Create Events
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          // Create or update events for each encounter create(
          create("tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );
          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));

      Custom-Logic-for-Events:
        name: Custom Logic for Events
        adaptor: '@openfn/language-common@2.1.1'
        credential: null
        body: |
          const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";
          const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";

          const processAnswer = (
            answer,
            conceptUuid,
            dataElement,
            optsMap,
            optionSetKey
          ) => {
            if (typeof answer.value === "object") {
              const optionKey = `${answer.formUuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];
              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              // console.log(`matchingOption value: "${matchingOption}" for`);
              // console.log({
              //   optionKey,
              //   conceptUid: answer.concept.uuid,
              //   'answer.value.uid': answer.value.uuid,
              //   'answer.value.display': answer.value.display,
              //   matchingOption,
              //   matchingOptionSet,
              // });

              if (matchingOption === "FALSE" || matchingOption === "No") {
                return "false";
              }
              if (matchingOption === "TRUE" || matchingOption === "Yes") {
                return "true";
              }

              return matchingOption || "";
            }

            return answer.value;
          };

          const processNoAnswer = (encounter, conceptUuid, dataElement) => {
            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );
            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2

            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }
            return "";
          };

          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };

          // Helper functions for finding observations
          const findObsByConcept = (encounter, conceptUuid) =>
            encounter.obs.find((o) => o.concept.uuid === conceptUuid);

          // Helper function to process dataValues from an encounter
          function processEncounterDataValues(encounter, form, state) {
            return Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const conceptUuid = form.dataValueMap[dataElement];
                const obsAnswer = encounter.obs.find(
                  (o) => o.concept.uuid === conceptUuid
                );

                const answer = {
                  ...obsAnswer,
                  formUuid: encounter.form.uuid,
                };
                const value = answer
                  ? processAnswer(
                    answer,
                    conceptUuid,
                    dataElement,
                    state.optsMap,
                    state.optionSetKey
                  )
                  : processNoAnswer(encounter, conceptUuid, dataElement);

                return { dataElement, value };
              })
              .filter((d) => d);
          }

          fn((state) => {
            state.eventsMapping = Object.entries(state.encountersByPatient)
              .map(([patientUuid, encounters]) => {
                // Skip if we don't have exactly 2 encounters
                if (encounters.length !== 2) return null;


                // Get the forms for both encounters
                const form1 = state.formMaps[encounters[0].form.uuid];
                const form2 = state.formMaps[encounters[1].form.uuid];

                // Skip if either form doesn't have dataValueMap
                if (!form1?.dataValueMap || !form2?.dataValueMap) return null;
                const f8Encounter = encounters.find(e => e.form.uuid === f08Form)
                const obsDatetime = findObsByConcept(f8Encounter, '7f00c65d-de60-467a-8964-fe80c7a85ef0')?.obsDatetime

                const datePart = obsDatetime.substring(0, 10);
                const timePart = obsDatetime.substring(11, 19);
                const f8Mapping = [
                  {
                    dataElement: "yprMS34o8s3",
                    value: f8Encounter.encounterDatetime
                  },
                  {
                    dataElement: "iQio7NYSA3m",
                    value: datePart
                  },
                  {
                    dataElement: "yprMS34o8s3",
                    value: timePart
                  }
                ]


                const tei = state.TEIs[patientUuid];
                console.log({ tei, patientUuid })

                const attributeMap = {
                  "Lg1LrNf9LQR": "qptKDiv9uPl",
                  "OVo3FxLURtH": "k26cdlS78i9",
                  "f3n6kIB9IbI": "Rv8WM2mTuS5",
                  "oc9zlhOoWmP": "YUIQIA2ClN6",
                  "DbyD9bbGIvE": "Qq6xQ2s6LO8",
                  "fiPFww1viBB": "rBtrjV1Mqkz",
                  "FsL5BjQocuo": "Xvzc9e0JJmp"
                };

                const f9Mapping = Object.entries(attributeMap)
                  .map(([dataElement, attributeId]) => {
                    const value = tei?.attributes?.find(attr => attr.attribute === attributeId)?.value;

                    return { dataElement, value };
                  })
                  .filter(Boolean);

                // Combine dataValues from both encounters
                const formDataValues = [
                  ...f8Mapping,
                  ...f9Mapping,
                  ...processEncounterDataValues(encounters[0], form1, state),
                  ...processEncounterDataValues(encounters[1], form2, state),
                ].filter(d => d.value)

                // Use properties from the first encounter for the event metadata
                // (or choose which encounter to use for each field)
                return {
                  program: form1.programId,
                  orgUnit: form1.orgUnit,
                  occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
                  programStage: form1.programStage,
                  dataValues: formDataValues,
                  trackedEntityInstance: patientUuid,
                };
              })
              .filter(Boolean);

            return state;
          });

      Get-Patients:
        name: Get Patients
        adaptor: '@openfn/language-openmrs@4.3.0'
        credential: mtuchi@openfn.org-OpenMRS-Demo
        body: |
          // Enable test mode
          const testMode = false

          cursor($.lastRunDateTime || $.manualCursor || '2025-03-20T06:01:24.000Z');

          cursor('today', {
            key: 'lastRunDateTime',
            format: c => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });

          searchPatient({ q: 'IQ', v: 'full', includeVoide: true, limit: '100' });

          fn(state => {
            const { cursor, data, lastRunDateTime } = state;
            console.log('Filtering patients since cursor:', cursor);

            const patients = data.results.filter(({ auditInfo }) => {
              const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
              return lastModified > cursor;
            });
            console.log('# of patients to sync to dhis2 ::', patients.length);
            console.log(
              'uuids of patients to sync to dhis2 ::',
              patients.map(p => p.uuid)
            );

            return { cursor, lastRunDateTime, patients, testMode };
          });

          // get patient - log number of patient that are fetched

          // get collections neccessary for patient mapping

          // map patient here - this will be passed down to next step

          // delete the initial patient object and only pass on the mapped one

      Upsert-TEIs:
        name: Upsert TEIs
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const buildPatientsUpsert = (state, patient, isNewPatient) => {
            const { placeOflivingMap, genderOptions } = state;
            const dateCreated = patient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find(i => i.identifierType.uuid === targetUuid)?.identifier;

            const enrollments = [
              {
                orgUnit: state.orgUnit,
                program: state.program, // searching by MH program but change this EMR
                programStage: state.patientProgramStage, //'MdTtRixaC1B',
                enrollmentDate: dateCreated,
              },
            ];

            const findOptsUuid = uuid =>
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value
                ?.uuid ||
              patient.person.attributes.find(a => a.attributeType.uuid === uuid)?.value;

            const findOptCode = optUuid =>
              state.optsMap.find(o => o['value.uuid - External ID'] === optUuid)?.[
                'DHIS2 Option Code'
              ];

            const patientMap = state.formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map(d => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: 'fa7uwpCKIwa',
                value: patient.person?.names[0]?.givenName,
              },
              {
                attribute: 'Jt9BhFZkvP2',
                value: patient.person?.names[0]?.familyName,
              },
              {
                attribute: 'P4wdYGkldeG', //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(patient.identifiers, state.dhis2PatientNumber) ||
                  findIdentifierByUuid(patient.identifiers, state.openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: 'ZBoxuExmxcZ', //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(patient.identifiers, state.openmrsAutoId),
              },
              {
                attribute: 'AYbfTPYMNJH', //"OpenMRS Patient UID"
                value: patient.uuid,
              },
              {
                attribute: 'qptKDiv9uPl',
                value: genderOptions[patient.person.gender],
              },
              {
                attribute: 'T1iX2NuPyqS',
                value: patient.person.age,
              },
              {
                attribute: 'WDp4nVor9Z7',
                value: patient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: 'rBtrjV1Mqkz', //Place of living
                value: placeOflivingMap[patient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter(a => a.value);
            const filteredStatusAttr = statusAttrMaps.filter(a => a.value);
            //console.log('standardAttr ::', JSON.stringify(standardAttr, null,2))
            //console.log('filteredAttr ::', JSON.stringify(filteredAttr, null,2))

            const payload = {
              query: {
                ou: state.orgUnit,
                program: state.program,
                filter: [`AYbfTPYMNJH:Eq:${patient.uuid}`], //upsert on omrs.patient.uid
              },
              data: {
                program: state.program,
                orgUnit: state.orgUnit,
                trackedEntityType: 'cHlzCA2MuEF',
                attributes: [...filteredAttr, ...filteredStatusAttr],
              },
            };

            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (isNewPatient) {
              console.log('create enrollment');
              payload.data.enrollments = enrollments;
            }

            return payload;
          };

          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          each(
            $.patients,
            get(
              'tracker/trackedEntities',
              {
                orgUnit: $.orgUnit,
                filter: [`AYbfTPYMNJH:Eq:${$.data?.uuid}`],
                program: $.program,
              },
              {},
              async state => {
                const patient = state.references.at(-1);
                console.log(patient.uuid, 'patient uuid');

                const isNewPatient = state.data.instances.length === 0;

                state.patientsUpsert ??= [];
                state.patientsUpsert.push(
                  buildPatientsUpsert(state, patient, isNewPatient)
                );
                await delay(2000);
                return state;
              }
            )
          );

          // Upsert TEIs to DHIS2
          each(
            $.patientsUpsert,
            upsert('trackedEntityInstances', $.data.query, $.data.data)
          );
          fn(state => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              genderOptions,
              identifiers,
              ...next
            } = state;

            next.patientUuids = patients.map(p => p.uuid);
            return next;
          });

      Get-TEIs-and-Map-Answers:
        name: Get TEIs and Map Answers
        adaptor: '@openfn/language-dhis2@5.0.1'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          //TODO: Group the encounters by patient and then get the TEI for each patient
          each(
            $.encounters,
            get('tracker/trackedEntities', state => ({
              orgUnit: $.orgUnit,
              program: $.program,
              // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
              filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
              fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
            })).then(async state => {
              const encounter = state.references.at(-1);
              console.log(encounter.patient.uuid, 'Encounter patient uuid');

              const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
              if (trackedEntity && enrollments) {
                state.TEIs ??= {};
                state.TEIs[encounter.patient.uuid] = {
                  trackedEntity,
                  events: enrollments[0]?.events,
                  enrollment: enrollments[0]?.enrollment,
                  attributes
                };
              }

              await delay(2000);
              return state;
            })
          );

      Get-Tie:
        name: Get Tie
        adaptor: '@openfn/language-dhis2@7.1.3'
        credential: mtuchi@openfn.org-MSF-DHIS2-UAT
        body: |
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"
          //TODO: Group the encounters by patient and then get the TEI for each patient
          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');

            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }

            await delay(2000);
            return state;
          })

    triggers:
      cron:
        type: cron
        cron_expression: '0 0 * * *'
        enabled: false
    edges:
      Custom-Logic-for-Events->Create-Events:
        source_job: Custom-Logic-for-Events
        target_job: Create-Events
        condition_type: js_expression
        condition_label: has-events
        condition_expression: |
          state?.eventsMapping?.length > 0 && !state.errors && !state.testMode

        enabled: true
      Get-Mappings-from-Collection->Get-Encounters:
        source_job: Get-Mappings-from-Collection
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-no-patients
        condition_expression: |
          !state.errors && state.patients.length === 0

        enabled: true
      Upsert-TEIs->Get-Encounters:
        source_job: Upsert-TEIs
        target_job: Get-Encounters
        condition_type: js_expression
        condition_label: has-patient-uuids
        condition_expression: |
          state.patientUuids.length > 0 && !state.errors

        enabled: true
      Get-Patients->Get-Mappings-from-Collection:
        source_job: Get-Patients
        target_job: Get-Mappings-from-Collection
        condition_type: on_job_success
        enabled: true
      Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
        source_job: Get-TEIs-and-Map-Answers
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: has-teis
        condition_expression: |
          state.TEIs && !state.errors

        enabled: true
      Get-Encounters->Get-TEIs-and-Map-Answers:
        source_job: Get-Encounters
        target_job: Get-TEIs-and-Map-Answers
        condition_type: js_expression
        condition_label: has-encounters
        condition_expression: |
          !state.errors && state?.encounters?.length > 0

        enabled: true
      cron->Get-Patients:
        source_trigger: cron
        target_job: Get-Patients
        condition_type: always
        enabled: true
      Get-Mappings-from-Collection->Upsert-TEIs:
        source_job: Get-Mappings-from-Collection
        target_job: Upsert-TEIs
        condition_type: js_expression
        condition_label: has-patients
        condition_expression: |
          state.patients.length > 0 && !state.errors

        enabled: true
      Get-Tie->Custom-Logic-for-Events:
        source_job: Get-Tie
        target_job: Custom-Logic-for-Events
        condition_type: js_expression
        condition_label: test-mode
        condition_expression: |
          state.testMode

        enabled: true
