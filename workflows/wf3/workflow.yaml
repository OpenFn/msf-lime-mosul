name: wf3-omrs-dhis2
jobs:
  Get-Mappings-from-Collection:
    name: Get Mappings from Collection
    adaptor: "@openfn/language-common@2.3.0"
    body: >
      const isValidUUID = (id) => {
        if (!id || typeof id !== "string") return false;

        const UUID_PATTERN =
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        return UUID_PATTERN.test(id);
      };


      collections.get("mosul-metadata-mappings-staging").then((state) => {
        state.optsMap = state.data
          .filter((i) => i.key.includes("optsMap-value-"))
          .map((i) => i.value);

        state.identifiers = state.data
          .filter((i) => i.key.includes("identifiers-value-"))
          .map((i) => i.value);
        state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
        state.formMetadata = state.data.find((i) => i.key ===
      "formMetadata")?.value;
        state.placeOflivingMap = state.data.find(
          (i) => i.key === "placeOflivingMap"
        )?.value;
        state.sourceFile = state.data.filter(
          (i) => i.key === "sourceFile"
        )?.[0]?.value;
        state.fileDateModified = state.data.filter(
          (i) => i.key === "fileDateModified"
        )?.[0]?.value;
        state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

        // TODO: Remove state.optionSetKey, when needed
        // Build from state.formMaps
        state.optionSetKey = state.data.filter(
          (i) => i.key === "optionSetKey"
        )?.[0]?.value;

        delete state.data;
        delete state.references;
        return state;
      });


      fn((state) => {
        const { formMetadata, identifiers, ...rest } = state;

        rest.v2FormUuids = formMetadata
          .filter(
            (form) =>
              isValidUUID(form["OMRS form.uuid"]) &&
              form["OMRS Form Version"] === "v4-2025"
          )
          .map((form) => form["OMRS form.uuid"]);
        rest.formUuids = formMetadata
          .filter(
            (form) =>
              isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF3"
          )
          .map((form) => form["OMRS form.uuid"]);

        // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
        //   'dhis2 attribute id'
        // ];

        rest.orgUnit = "sUpt0j2GmBD";

        rest.program = "dWdzxMuKa8Z";

        rest.patientProgramStage = state.formMaps.patient.programStage;

        rest.dhis2PatientNumber = identifiers.find(
          (i) => i.type === "DHIS2_PATIENT_NUMBER"
        )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

        rest.openmrsAutoId = identifiers.find((i) => i.type ===
      "OPENMRS_AUTO_ID")?.[
          "omrs identifierType"
        ]; //MSF ID or OpenMRS Patient Number

        return rest;
      });
  Get-Encounters:
    name: Get Encounters
    adaptor: "@openfn/language-openmrs@4.3.0"
    body: >
      function removeLinks(data) {
        if (Array.isArray(data)) {
          return data.map(removeLinks);
        }

        if (typeof data === "object" && data !== null) {
          const { links, ...rest } = data;
          return Object.fromEntries(
            Object.entries(rest).map(([key, value]) => [key,
      removeLinks(value)])
          );
        }

        return data;
      }


      function removeNulls(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => item !== null).map(removeNulls);
        }

        if (typeof data === "object" && data !== null) {
          const result = {};
          for (const [key, value] of Object.entries(data)) {
            if (value !== null) {
              result[key] = removeNulls(value);
            }
          }
          return result;
        }

        return data;
      }

      const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

      // Fetch patient encounters

      each(
        $.patientUuids,
        get("encounter", { patient: $.data, v: "full" }).then((state) => {
          const patientUuid = state.references.at(-1);
          const filteredEncounters = state.formUuids.map((formUuid) =>
            state?.data?.results
              .filter(
                (e) =>
                  e.auditInfo.dateCreated >= state.cursor &&
                  e?.form?.uuid === formUuid
              )
              .sort(
                (a, b) =>
                  new Date(b.auditInfo.dateCreated) -
                  new Date(a.auditInfo.dateCreated)
              )
          );

          // Why we only keep the latest one form encounter?
          const encounters = filteredEncounters.map((e) => e[0]).filter((e) =>
      e);
          state.encounters ??= [];
          state.encounters.push(...encounters);

          console.log(
            encounters.length,
            `# of filtered encounters found in OMRS for ${patientUuid}`
          );
          delay(1500);

          return state;
        })
      );


      fn((state) => {
        const {
          data,
          index,
          response,
          references,
          allResponse,
          patientUuids,
          patients,
          ...next
        } = state;

        if (next.encounters?.length) {
          next.encounters = next.encounters.map((encounter) => {
            const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
              removeNulls(encounter)
            );

            return {
              uuid,
              patient: {
                uuid: patient.uuid,
                display: patient.display,
              },
              obs: obs.map((o) => {
                return {
                  uuid: o.uuid,
                  concept: o.concept,
                  display: o.display,
                  formFieldPath: o.formFieldPath,
                  value: o.value,
                };
              }),
              form: {
                uuid: form.uuid,
                display: form.display,
                description: form.description,
                name: form.name,
              },
              encounterDatetime,
            };
          });
          console.log(next.encounters.length, "# of new encounters to sync to
      dhis2");
        } else {
          console.log("No encounters found for cursor: ", next.cursor);
        }

        return next;
      });
  Create-Events:
    name: Create Events
    adaptor: "@openfn/language-dhis2@5.0.1"
    body: |
      // Create or update events for each encounter create(
      create(
        "tracker",
        {
          events: (state) => {
            console.log(
              "Creating events for: ",
              JSON.stringify(state.eventsMapping, null, 2)
            );
            return state.eventsMapping;
          },
        },
        {
          params: {
            async: false,
            dataElementIdScheme: "UID",
            importStrategy: "CREATE_AND_UPDATE",
          },
        }
      );

      fn(({ lastRunDateTime }) => ({ lastRunDateTime }));
  Custom-Logic-for-Events:
    name: Custom Logic for Events
    adaptor: "@openfn/language-common@2.1.1"
    body: >
      const f08Form = "f0bb3bf7-4e0a-3545-afce-a6b33b0378e4";

      const f09Form = "6e1e468b-00b1-3e5d-a8cf-00f45b8fe261";

      const f27Form = "ac97ec76-5647-3153-b4e1-2eceae121e50";

      const f28Form = "893ef4b7-5ad1-39e7-8515-eab308ccd636";


      const findAnswerByConcept = (encounter, conceptUuid) => {
        const answer = encounter.obs.find((o) => o.concept.uuid ===
      conceptUuid);
        return answer?.value?.display;
      };


      // Helper functions for finding observations

      const findObsByConcept = (encounter, conceptUuid) => {
        const [conceptId, questionId] = conceptUuid.split("-rfe-");
        const answer = encounter.obs.find(
          (o) =>
            o.concept.uuid === conceptId &&
            (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
        );
        return answer;
      };


      const findDataValue = (encounter, dataElement, metadataMap) => {
        const { optsMap, optionSetKey, form } = metadataMap;
        const [conceptUuid, questionId] =
          form.dataValueMap[dataElement]?.split("-rfe-");
        const answer = encounter.obs.find((o) => o.concept.uuid ===
      conceptUuid);
        const isObjectAnswer = answer && typeof answer.value === "object";
        const isStringAnswer = answer && typeof answer.value === "string";

        if (isStringAnswer) {
          return answer.value;
        }

        if (isObjectAnswer) {
          const optionKey = questionId
            ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
            : `${encounter.form.uuid}-${answer.concept.uuid}`;
          const matchingOptionSet = optionSetKey[optionKey];
          const opt = optsMap.find(
            (o) =>
              o["value.uuid - External ID"] === answer.value.uuid &&
              o["DHIS2 Option Set UID"] === matchingOptionSet
          );
          const matchingOption =
            opt?.["DHIS2 Option Code"] ||
            opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added
      this because  Opticon Code is empty in some cases.
            answer?.value?.display; //TODO: revisit this logic if optionSet not
      found

          if (["FALSE", "No"].includes(matchingOption)) return "false";
          if (["TRUE", "Yes"].includes(matchingOption)) return "true";

          return matchingOption;
        }

        const isEncounterDate =
          conceptUuid === "encounter-date" &&
          ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
            dataElement
          );

        // These are data elements for encounter date in DHIS2
        // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2,
      F32-mhGAp Follow-up v2
        if (isEncounterDate) {
          return encounter.encounterDatetime.replace("+0000", "");
        }

        return "";
      };

      // Helper function to process dataValues from an encounter

      function processEncounterDataValues(encounter, form, state) {
        return Object.keys(form.dataValueMap)
          .map((dataElement) => {
            const value = findDataValue(encounter, dataElement, {
              optsMap: state.optsMap,
              optionSetKey: state.optionSetKey,
              form,
            });

            return { dataElement, value };
          })
          .filter((d) => d);
      }


      const MILLISECONDS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;

      const calculateAge = (dob) =>
        Math.floor((new Date() - new Date(dob)) / MILLISECONDS_PER_YEAR);

      fn((state) => {
        // Group encounters by patient UUID
        const encountersByPatient = state.encounters?.reduce((acc, obj) => {
          const key = obj.patient.uuid;
          if (!acc[key]) {
            acc[key] = [];
          }
          acc[key].push(obj);
          return acc;
        }, {});

        state.eventsMapping = Object.entries(encountersByPatient)
          .map(([patientUuid, encounters]) => {
            // Skip if we don't have exactly 2 encounters
            if (encounters.length !== 2) return null;

            // Get the forms for both encounters
            const form1 = state.formMaps[encounters[0].form.uuid];
            const form2 = state.formMaps[encounters[1].form.uuid];

            // Skip if either form doesn't have dataValueMap

            if (!form1?.dataValueMap || !form2?.dataValueMap) {
              return null;
            }
            let encountersMapping = [];
            const f8Encounter = encounters.find((e) => e.form.uuid === f08Form);

            if (f8Encounter) {
              const obsDatetime = findObsByConcept(
                f8Encounter,
                "7f00c65d-de60-467a-8964-fe80c7a85ef0"
              )?.obsDatetime;

              const datePart = obsDatetime.substring(0, 10);
              const timePart = obsDatetime.substring(11, 19);
              const f8Mapping = [
                {
                  dataElement: "yprMS34o8s3",
                  value: f8Encounter.encounterDatetime,
                },
                {
                  dataElement: "iQio7NYSA3m",
                  value: datePart,
                },
                {
                  dataElement: "yprMS34o8s3",
                  value: timePart,
                },
              ];
              encountersMapping.push(...f8Mapping);
            }

            const f27Encounter = encounters.find((e) => e.form.uuid ===
      f27Form);

            if (f27Encounter) {
              const admissionDate = findObsByConcept(
                f27Encounter,
                "7f00c65d-de60-467a-8964-fe80c7a85ef0"
              )?.value;

              const f27Mapping = [
                {
                  dataElement: "eYvDzr2m8f5",
                  value: admissionDate,
                },
              ];
              encountersMapping.push(...f27Mapping);
            }

            const tei = state.TEIs[patientUuid];
            if (tei) {
              const attributeMap = {
                Lg1LrNf9LQR: "qptKDiv9uPl",
                OVo3FxLURtH: "k26cdlS78i9",
                f3n6kIB9IbI: "Rv8WM2mTuS5",
                oc9zlhOoWmP: "YUIQIA2ClN6",
                DbyD9bbGIvE: "Qq6xQ2s6LO8",
                fiPFww1viBB: "rBtrjV1Mqkz",
                FsL5BjQocuo: "Xvzc9e0JJmp",
                //F28 DSHI2 UID
                WP5vr8KB2lH: "qptKDiv9uPl",
                Y7qzoa4Qaiz: "YUIQIA2ClN6",
                XCUd9xOGXkn: "Qq6xQ2s6LO8",
                onKT21rxH6Z: "rBtrjV1Mqkz",
                sCKCNreiqEA: "Xvzc9e0JJmp",
              };

              const attributeMapping = Object.entries(attributeMap)
                .map(([dataElement, attributeId]) => {
                  const value = tei?.attributes?.find(
                    (attr) => attr.attribute === attributeId
                  )?.value;

                  return { dataElement, value };
                })
                .filter(Boolean);

              let age = tei?.attributes?.find(
                (attr) => attr.attribute === "T1iX2NuPyqS"
              )?.value;

              if (!age) {
                const birthdate = tei?.attributes?.find(
                  (attr) => attr.attribute === "WDp4nVor9Z7"
                )?.value;
                age = calculateAge(birthdate);
              }

              const f28Mapping = [
                {
                  dataElement: "NWOnMq8h4w1",
                  value: age,
                },
              ];
              encountersMapping.push(...attributeMapping, ...f28Mapping);
            }

            // Combine dataValues from both encounters
            const formDataValues = [
              ...encountersMapping,
              ...processEncounterDataValues(encounters[0], form1, state),
              ...processEncounterDataValues(encounters[1], form2, state),
            ].filter((d) => d.value);

            // Use properties from the first encounter for the event metadata
            // (or choose which encounter to use for each field)
            return {
              program: form1.programId,
              orgUnit: form1.orgUnit,
              occurredAt: encounters[0].encounterDatetime.replace("+0000", ""),
              programStage: form1.programStage,
              dataValues: formDataValues,
              trackedEntityInstance: patientUuid,
            };
          })
          .filter(Boolean);

        return state;
      });


      fn((state) => {
        return {
          eventsMapping: state.eventsMapping,
        };
      });
  Get-Patients:
    name: Get Patients
    adaptor: "@openfn/language-openmrs@4.3.0"
    body: >
      function removeLinks(data) {
        if (Array.isArray(data)) {
          return data.map(removeLinks);
        }

        if (typeof data === "object" && data !== null) {
          const { links, ...rest } = data;
          return Object.fromEntries(
            Object.entries(rest).map(([key, value]) => [key,
      removeLinks(value)])
          );
        }

        return data;
      }


      function removeNulls(data) {
        if (Array.isArray(data)) {
          return data.filter((item) => item !== null).map(removeNulls);
        }

        if (typeof data === "object" && data !== null) {
          const result = {};
          for (const [key, value] of Object.entries(data)) {
            if (value !== null) {
              result[key] = removeNulls(value);
            }
          }
          return result;
        }

        return data;
      }

      cursor($.lastRunDateTime || $.manualCursor || "2025-03-20T06:01:24.000Z");


      cursor("today", {
        key: "lastRunDateTime",
        format: (c) => dateFns.format(new Date(c),
      "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
      });


      searchPatient({
        q: "IQ146-25-012-289",
        v: "full",
        includeVoide: true,
        limit: "100",
      });


      fn((state) => {
        const { cursor, data, lastRunDateTime } = state;
        console.log("Filtering patients since cursor:", cursor);

        state.patients = data.results
          .filter(({ auditInfo }) => {
            const lastModified = auditInfo?.dateChanged ||
      auditInfo?.dateCreated;
            return lastModified > cursor;
          })
          .map((p) => {
            const { uuid, auditInfo, identifiers, person } = removeLinks(
              removeNulls(p)
            );
            const { dateCreated } = auditInfo;
            const { age, birthdate, gender, names, addresses, attributes } =
      person;

            return {
              uuid,
              person: {
                age,
                birthdate,
                gender,
                names,
                addresses: [addresses.find((a) => a.cityVillage)],
                attributes,
              },
              identifiers,
              auditInfo: { dateCreated },
            };
          });
        state.searchPatientUuids = state.patients.map((p) => p.uuid);
        console.log("# of patients to sync to dhis2 ::", state.patients.length);

        return state;
      });


      // Fetch all encounters

      http
        .get("/ws/fhir2/R4/Encounter", {
          query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
        })
        .then((state) => {
          const { link, total } = state.data;
          state.nextUrl = link
            .find((l) => l.relation === "next")
            ?.url.replace(/(_count=)\d+/, `$1${total}`)
            .split("/openmrs")[1];

          state.allResponse = state.data;
          return state;
        });

      fnIf(
        $.nextUrl,
        http.get($.nextUrl).then((state) => {
          console.log(`Fetched ${state.data.entry.length} remaining
      encounters`);
          delete state.allResponse.link;
          state.allResponse.entry.push(...state.data.entry);
          return state;
        })
      );


      fn((state) => {
        console.log(
          "Total # of encounters fetched: ",
          state.allResponse?.entry?.length
        );

        const uuids = [
          ...new Set(
            state.allResponse?.entry?.map((p) =>
              p.resource?.subject?.reference?.replace("Patient/", "")
            )
          ),
        ];
        state.encounterPatientUuids = [...new Set(uuids)];

        return state;
      });


      fn((state) => {
        const {
          cursor,
          lastRunDateTime,
          patients,
          searchPatientUuids,
          encounterPatientUuids,
        } = state;

        const onlyInSearchPatient = searchPatientUuids.filter(
          (id) => !encounterPatientUuids.includes(id)
        );

        const onlyInR4Encounter = encounterPatientUuids.filter(
          (id) => !searchPatientUuids.includes(id)
        );
        const inbothResults = searchPatientUuids.filter((id) =>
          encounterPatientUuids.includes(id)
        );
        const patientUuids = [...new Set(searchPatientUuids,
      encounterPatientUuids)];

        console.log("inbothResults", inbothResults.length);
        console.log("patient-search-array", onlyInSearchPatient.length);
        console.log("r4-encounter-array", onlyInR4Encounter.length);
        console.log("combined uuids", patientUuids.length);

        return { cursor, lastRunDateTime, patients, patientUuids };
      });
  Upsert-TEIs:
    name: Upsert TEIs
    adaptor: "@openfn/language-dhis2@5.0.1"
    body: >
      const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
        const genderMap = {
          M: "male",
          O: "unknown",
          F: "female",
          U: "unknown",
        };
        const {
          orgUnit,
          program,
          optsMap,
          formMaps,
          placeOflivingMap,
          patientProgramStage,
          dhis2PatientNumber,
          openmrsAutoId,
        } = mappingConfig;

        const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
        const findIdentifierByUuid = (identifiers, targetUuid) =>
          identifiers.find((i) => i.identifierType.uuid ===
      targetUuid)?.identifier;

        const findOptsUuid = (uuid) =>
          omrsPatient.person.attributes.find((a) => a.attributeType.uuid ===
      uuid)
            ?.value?.uuid ||
          omrsPatient.person.attributes.find((a) => a.attributeType.uuid ===
      uuid)
            ?.value;

        const findOptCode = (optUuid) =>
          optsMap.find((o) => o["value.uuid - External ID"] === optUuid)?.[
            "DHIS2 Option Code"
          ];

        const patientMap = formMaps.patient.dataValueMap;
        const statusAttrMaps = Object.keys(patientMap).map((d) => {
          const optUid = findOptsUuid(patientMap[d]);
          return {
            attribute: d,
            value: findOptCode(optUid) || optUid,
          };
        });

        const standardAttr = [
          {
            attribute: "fa7uwpCKIwa",
            value: omrsPatient.person?.names[0]?.givenName,
          },
          {
            attribute: "Jt9BhFZkvP2",
            value: omrsPatient.person?.names[0]?.familyName,
          },
          {
            attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
            value:
              findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber)
      ||
              findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
      //map OMRS ID if no DHIS2 id
          },
          {
            attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
            value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
          },
          {
            attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
            value: omrsPatient.uuid,
          },

          {
            attribute: "T1iX2NuPyqS",
            value: omrsPatient.person.age,
          },
          {
            attribute: "WDp4nVor9Z7",
            value: omrsPatient.person.birthdate?.slice(0, 10),
          },
          {
            attribute: "rBtrjV1Mqkz", //Place of living
            value:
      placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
          },
        ];

        //filter out attributes that don't have a value from dhis2
        const filteredAttr = standardAttr.filter((a) => a.value);
        const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

        const payload = {
          program,
          orgUnit,
          attributes: [...filteredAttr, ...filteredStatusAttr],
        };
        // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null,
      2));

        if (!patientTei) {
          payload.trackedEntityType = "cHlzCA2MuEF";
          const enrollments = [
            {
              orgUnit,
              program,
              enrolledAt,
              programStage: patientProgramStage, //'MdTtRixaC1B',
            },
          ];
          payload.attributes.push({
            attribute: "qptKDiv9uPl",
            value: genderMap[omrsPatient.person.gender],
          });
          console.log("create enrollment");
          payload.enrollments = enrollments;
        } else {
          payload.trackedEntity = patientTei.trackedEntity;
          payload.trackedEntityType = patientTei.trackedEntityType;
        }

        return payload;
      };


      const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));


      get("tracker/trackedEntities", {
        orgUnit: $.orgUnit,
        filter: (state) => [
          `AYbfTPYMNJH:IN:${state.patients.map((patient) =>
      patient.uuid).join(";")}`,
        ],
        program: $.program,
      });


      fn((state) => {
        const findTeiByUuid = (patientUuid) => {
          return state.data.instances.find((tei) => {
            return (
              tei.attributes.find(
                (attribute) => attribute.attribute === "AYbfTPYMNJH"
              )?.value === patientUuid
            );
          });
        };

        state.patientsMapping = state.patients.map((patient) => {
          const patientTei = findTeiByUuid(patient.uuid);

          return buildTeiMapping(patient, patientTei, {
            placeOflivingMap: state.placeOflivingMap,
            orgUnit: state.orgUnit,
            program: state.program,
            patientProgramStage: state.patientProgramStage,
            formMaps: state.formMaps,
            optsMap: state.optsMap,
            dhis2PatientNumber: state.dhis2PatientNumber,
            openmrsAutoId: state.openmrsAutoId,
          });
        });

        return state;
      });


      // Bulk upsert

      create(
        "tracker",
        { trackedEntities: $.patientsMapping },
        {
          params: {
            atomicMode: "ALL",
            async: false,
          },
        }
      );


      fn((state) => {
        const {
          data,
          response,
          references,
          patients,
          patientsUpsert,
          placeOflivingMap,
          identifiers,
          ...next
        } = state;
        next.patientUuids = patients.map((p) => p.uuid);
        return next;
      });
  Get-TEIs-and-Map-Answers:
    name: Get TEIs and Map Answers
    adaptor: "@openfn/language-dhis2@5.0.1"
    body: >
      const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));


      //TODO: Group the encounters by patient and then get the TEI for each
      patient

      each(
        $.encounters,
        get("tracker/trackedEntities", (state) => ({
          orgUnit: $.orgUnit,
          program: $.program,
          // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the
      org unit and program should be fetched from fromMap by mapping
      encounter.form.uuid
          // program: state.formMaps[state.data.form.uuid].programId, //TODO:
      the org unit and program should be fetched from fromMap by mapping
      encounter.form.uuid
          filter: [`AYbfTPYMNJH:Eq:${$.data.patient.uuid}`],
          fields: "*,enrollments[*],enrollments[events[*]], attributes[*]",
        })).then(async (state) => {
          const encounter = state.references.at(-1);
          console.log(encounter.patient.uuid, "Encounter patient uuid");

          const { trackedEntity, enrollments, attributes } =
            state.data?.instances?.[0] || {};
          if (trackedEntity && enrollments) {
            state.TEIs ??= {};
            state.TEIs[encounter.patient.uuid] = {
              trackedEntity,
              events: enrollments[0]?.events,
              enrollment: enrollments[0]?.enrollment,
              attributes,
            };
          }

          await delay(2000);
          return state;
        })
      );
  Get-Tie:
    name: Get Tie
    adaptor: "@openfn/language-dhis2@7.1.3"
    body: >
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));


      const patientUid = "d464433d-41d5-482f-808c-7fe364847352"

      //TODO: Group the encounters by patient and then get the TEI for each
      patient

      get('tracker/trackedEntities', state => ({
        orgUnit: "sUpt0j2GmBD",
        program: "dWdzxMuKa8Z",
        // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the
      org unit and program should be fetched from fromMap by mapping
      encounter.form.uuid
        // program: state.formMaps[state.data.form.uuid].programId, //TODO: the
      org unit and program should be fetched from fromMap by mapping
      encounter.form.uuid
        filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
        fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
      })).then(async state => {
        
        console.log(patientUid, 'Encounter patient uuid');

        const { trackedEntity, enrollments, attributes } =
      state.data?.instances?.[0] || {};
        if (trackedEntity && enrollments) {
          state.TEIs ??= {};
          state.TEIs[patientUid] = {
            trackedEntity,
            events: enrollments[0]?.events,
            enrollment: enrollments[0]?.enrollment,
            attributes
          };
        }

        await delay(2000);
        return state;
      })
triggers:
  cron:
    type: cron
    enabled: false
    cron_expression: 0 0 * * *
edges:
  Upsert-TEIs->Get-Encounters:
    condition_type: js_expression
    enabled: true
    target_job: Get-Encounters
    source_job: Upsert-TEIs
    condition_label: has-patient-uuids
    condition_expression: |
      state.patientUuids.length > 0 && !state.errors
  Get-Patients->Get-Mappings-from-Collection:
    condition_type: on_job_success
    enabled: true
    target_job: Get-Mappings-from-Collection
    source_job: Get-Patients
  Get-TEIs-and-Map-Answers->Custom-Logic-for-Events:
    condition_type: js_expression
    enabled: true
    target_job: Custom-Logic-for-Events
    source_job: Get-TEIs-and-Map-Answers
    condition_label: has-teis
    condition_expression: |
      state.TEIs && !state.errors
  Get-Encounters->Get-TEIs-and-Map-Answers:
    condition_type: js_expression
    enabled: true
    target_job: Get-TEIs-and-Map-Answers
    source_job: Get-Encounters
    condition_label: has-encounters
    condition_expression: |
      !state.errors && state?.encounters?.length > 0
  cron->Get-Patients:
    condition_type: always
    enabled: true
    target_job: Get-Patients
    source_trigger: cron
  Get-Mappings-from-Collection->Upsert-TEIs:
    condition_type: js_expression
    enabled: true
    target_job: Upsert-TEIs
    source_job: Get-Mappings-from-Collection
    condition_label: has-patients
    condition_expression: |
      state.patients.length > 0 && !state.errors
  Get-Tie->Custom-Logic-for-Events:
    condition_type: js_expression
    enabled: true
    target_job: Custom-Logic-for-Events
    source_job: Get-Tie
    condition_label: test-mode
    condition_expression: |
      state.testMode
  Custom-Logic-for-Events->Create-Events:
    condition_type: js_expression
    enabled: true
    target_job: Create-Events
    source_job: Custom-Logic-for-Events
    condition_label: has-events
    condition_expression: |
      state?.eventsMapping?.length > 0 && !state.errors && !state.testMode
  Get-Mappings-from-Collection->Get-Encounters:
    condition_type: js_expression
    enabled: true
    target_job: Get-Encounters
    source_job: Get-Mappings-from-Collection
    condition_label: has-no-patients
    condition_expression: |
      !state.errors && state.patients.length === 0
