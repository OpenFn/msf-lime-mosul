id: msf-lime-mosul-staging
name: msf-lime-mosul-staging
version: 2
description: |
  staging project for main MSF workflows
collections: []
credentials:
  - id: 0fa0d3d1-0caa-4f8f-8952-f0b2e2ce51ea
    name: mtuchi-github-token
    owner: mtuchi@openfn.org
  - id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
    name: OpenMRS Demo
    owner: mtuchi@openfn.org
  - id: 49fdae45-c33e-498a-9441-e0c0b4a61568
    name: OpenFnSharepoint
    owner: mtuchi@openfn.org
  - id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
    name: MSF DHIS2 UAT
    owner: mtuchi@openfn.org
  - id: 90cddfa1-9b77-4625-a812-2a04d061522c
    name: mtuchi-collections-config
    owner: mtuchi@openfn.org
  - id: d2c62b09-c071-4cbe-95e5-b703aba863f3
    name: MSF OMRS admin
    owner: aisha@openfn.org
openfn:
  uuid: 7ea6221c-4599-428e-9565-d4f0e05c7803
  endpoint: https://app.openfn.org
  env: project
  inserted_at: 2025-01-30T11:16:04Z
  updated_at: 2025-12-08T17:57:21Z
options:
  env: main
  history_retention_period: 365
  dataclip_retention_period: 365
  retention_policy: retain_all
  version_history: []
  allow_support_access: false
  requires_mfa: false
workflows:
  - name: wf1-dhis2-omrs-migration
    steps:
      - id: alert-admin-of-duplicate-teis
        name: Alert Admin of Duplicate TEIs
        expression: >
          fn(state => {
            const code = 'DUPLICATE_PATIENT_NUMBERS';
            const description = `Found ${state.duplicatePatients.length} TIEs with duplicate patient numbers`;
            const message = `${code}: ${description}`;
            const patientNumbers = state.duplicatePatients.map(
              patient =>
                patient.attributes.find(attr => attr.code === 'patient_number').value
            );

            const details = {
              code,
              description,
              duplicatePatientNumbers: patientNumbers,
            };
            const e = new Error(message);
            e.details = details;
            console.error(e.details);
            throw e;
          });
        adaptor: "@openfn/language-common@2.1.1"
        openfn:
          uuid: eaa87fc7-1b9c-4c23-85ef-894fed073145
      - id: create-patients
        name: Create Patients
        expression: >
          //Define gender options and prepare newPatientUuid and identifiers

          fn(state => {
            const { uniqueTeis } = state;
            if (uniqueTeis.length > 0)
              console.log('# of TEIs to send to OpenMRS: ', uniqueTeis.length);
            if (uniqueTeis.length === 0)
              console.log('No data fetched in step prior to sync.');

            return state;
          });


          //First we generate a unique OpenMRS ID for each patient

          each(
            $.uniqueTeis,
            post(
              'idgen/identifiersource/8549f706-7e85-4c1d-9424-217d50a2988b/identifier'
            ).then(state => {
              state.identifiers ??= [];
              state.identifiers.push(state.data.identifier);
              return state;
            })
          );


          // Then we map uniqueTeis to openMRS data model

          fn(state => {
            const {
              uniqueTeis,
              nationalityMap,
              genderOptions,
              identifiers,
              statusMap,
              locations,
            } = state;

            const getValueForCode = (attributes, code) => {
              const result = attributes.find(attribute => attribute.code === code);
              return result ? result.value : undefined;
            };

            const calculateDOB = age => {
              if (!age) return age;
              const currentDate = new Date();
              const currentYear = currentDate.getFullYear();
              const birthYear = currentYear - age;

              const birthday = new Date(
                birthYear,
                currentDate.getMonth(),
                currentDate.getDay()
              );

              return birthday.toISOString().replace(/\.\d+Z$/, '+0000');
            };

            state.patients = uniqueTeis.map((d, i) => {
              const patientNumber =
                getValueForCode(d.attributes, 'patient_number') || d.trackedEntity; // Add random number for testing + Math.random()

              const lonlat = d.attributes.find(a => a.attribute === 'rBtrjV1Mqkz')?.value;
              const location = lonlat
                ? locations.options.find(o => o.code === lonlat)?.displayName
                : undefined;

              let countyDistrict, cityVillage;

              if (location) {
                const match = location.match(/^(.*?)\s*\((.*?)\)/);
                if (match) {
                  [, countyDistrict, cityVillage] = match;
                  cityVillage = cityVillage.split('-')[0].trim(); // Remove country code and trim
                }
              }

              // const attributes = d.attributes
              //   .filter(a => a.attribute in state.patientAttributes)
              //   .map(a => {
              //     let value = a.value;

              //     if (a.displayName === 'Nationality') {
              //       value = nationalityMap[a.value];
              //     } else if (a.displayName.includes(' status')) {
              //       value = statusMap[a.value];
              //     }

              //     if (value) {
              //       return {
              //         attributeType: state.patientAttributes[a.attribute].trim(),
              //         value,
              //       };
              //     }
              //   })
              //   .filter(Boolean);

              return {
                patientNumber,
                person: {
                  age: getValueForCode(d.attributes, 'age'),
                  gender: genderOptions[getValueForCode(d.attributes, 'sex')] ?? 'U',
                  birthdate:
                    d.attributes.find(a => a.attribute === 'WDp4nVor9Z7')?.value ??
                    calculateDOB(getValueForCode(d.attributes, 'age')),
                  // d.attributes.find(a => a.attribute === 'WDp4nVor9Z7')?.value ?
                  // calculateDOB(getValueForCode(d.attributes, 'age')) : '1900-01-01',
                  birthdateEstimated: d.attributes.find(
                    a => a.attribute === 'WDp4nVor9Z7'
                  )
                    ? true
                    : false,
                  names: [
                    {
                      familyName:
                        d.attributes.find(a => a.attribute === 'fa7uwpCKIwa')?.value ??
                        'unknown',
                      givenName:
                        d.attributes.find(a => a.attribute === 'Jt9BhFZkvP2')?.value ??
                        'unknown',
                    },
                  ],
                  addresses: [
                    {
                      country: 'Iraq',
                      stateProvince: 'Ninewa',
                      countyDistrict,
                      cityVillage,
                    },
                  ],
                  // attributes,
                },
                identifiers: [
                  {
                    identifier: identifiers[i], //OMRS-generated identifier - see above
                    identifierType: '05a29f94-c0ed-11e2-94be-8c13b969e334',
                    location: 'cf6fa7d4-1f19-4c85-ac50-ff824805c51c', //default location old:44c3efb0-2583-4c80-a79e-1f756a03c0a1
                    preferred: true,
                  },
                  {
                    // uuid: d.trackedEntity,
                    identifier: patientNumber, //Patient Number from DHIS2
                    identifierType: '8d79403a-c2cc-11de-8d13-0010c6dffd0f', //Old Identification number
                    location: 'cf6fa7d4-1f19-4c85-ac50-ff824805c51c', //default location
                    preferred: false, //default value for this identifiertype
                  },
                ],
              };
            });

            return state;
          });


          // Creating patients in openMRS

          each(
            $.patients,
            upsert(
              'patient',
              {
                q: $.data.patientNumber,
                limit: 1,
                startIndex: 0
              },
              state => {
                const { patientNumber, ...patient } = state.data;
                console.log(
                  'Upserting patient record...',
                  JSON.stringify(patient, null, 2)
                );
                return patient;
              },
              state => {
                state.newPatientUuid ??= [];
                //console.log('state.references ::', state.references)
                state.newPatientUuid.push({
                  patient_number: state.references.at(-1)?.patientNumber,
                  omrs_patient_number: state.references
                    .at(-1)
                    ?.identifiers.find(
                      i => (i.identifierType === `${state.openmrsAutoId}`)
                    ),
                  uuid: state.data.uuid,
                });
                return state;
              }
            )
          );


          // Clean up state

          fn(({ data, references, ...state }) => state);
        adaptor: "@openfn/language-openmrs@4.2.0"
        openfn:
          uuid: d26ee140-a7d7-424b-8d82-ed34d25174f2
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
        next:
          update-teis:
            disabled: false
            openfn:
              uuid: 05d88b14-52e6-4f24-8acc-ed0ba455c942
      - id: fetch-metadata
        name: Fetch Metadata
        expression: >
          cursor($.manualCursor || $.lastRunDateTime).then((state) => {
            console.log("Date cursor to filter TEI extract ::", state.cursor);
            return state;
          });


          cursor("now", {
            key: "lastRunDateTime",
            format: (c) => {
              const offset = 2; // GMT+2 (Geneva time)
              c.setHours(c.getHours() + offset);
              return c.toISOString().replace("Z", "");
            },
          }).then((state) => {
            console.log("Next sync start date:", state.lastRunDateTime);
            return state;
          });


          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);

            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;

            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            delete state.data;
            delete state.references;
            return state;
          });


          fn(({ identifiers, optsMap, formMaps, ...state }) => {
            state.genderOptions = {
              male: "M",
              female: "F",
              unknown: "U",
              transgender_female: "O",
              transgender_male: "O",
              prefer_not_to_answer: "O",
              gender_variant_non_conforming: "O",
            };
            // state.orgUnit = identifiers.find((i) => i.type === "ORG_UNIT")?.[
            //   "dhis2 attribute id"
            // ];
            // state.program = identifiers.find((i) => i.type === "PROGRAM")?.[
            //   "dhis2 attribute id"
            // ];
            state.orgUnit = "sUpt0j2GmBD"

            state.program = "dWdzxMuKa8Z"
            state.nationalityMap = optsMap
              .filter((o) => o["DHIS2 DE full name"] === "Nationality")
              .reduce((acc, value) => {
                acc[value["DHIS2 Option Code"]] = value["value.uuid - External ID"];
                return acc;
              }, {});

            state.statusMap = optsMap
              .filter((o) => {
                const fullName = o["DHIS2 DE full name"];
                return fullName && fullName.includes(" status");
              })
              .reduce((acc, value) => {
                acc[value["DHIS2 Option Code"]] = value["value.uuid - External ID"];
                return acc;
              }, {});

            state.patientAttributes = Object.entries(formMaps.patient.dataValueMap)
            .filter(([key]) => key !== "qptKDiv9uPl")
            .reduce((acc, [key, value]) => {
              acc[key] = value;
              return acc;
            }, {});
            state.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            state.dhis2PatientNumberAttributeId = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["dhis2 attribute id"]; //DHIS2 ID or DHIS2 Patient Number

            state.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            state.openmrsAutoIdAttributeId = identifiers.find(
              (i) => i.type === "OPENMRS_AUTO_ID"
            )?.["dhis2 attribute id"]; //MSF ID or OpenMRS Patient Number

            return state;
          });
        adaptor: "@openfn/language-common@2.1.1"
        openfn:
          uuid: c4616bf4-6a28-4307-8798-d5710dcfc75f
        next:
          get-teis-and-locations:
            disabled: false
            openfn:
              uuid: 947f7f92-1205-4fda-8595-4d8025786c35
      - id: get-teis-and-locations
        name: Get Teis and Locations
        expression: >
          const findDuplicatePatient = teis => {
            const seen = new Map();
            const duplicates = new Set();

            teis.forEach(tei => {
              const patientNumber = tei.attributes.find(
                attr => attr.code === 'patient_number'
              )?.value;

              if (seen.get(patientNumber)) {
                duplicates.add(patientNumber);
              } else {
                seen.set(patientNumber, tei);
              }
            });

            return duplicates;
          };

          // Get teis that are "active" in the target program

          get('tracker/trackedEntities', {
            orgUnit: $.orgUnit,
            program: $.program,
            programStatus: 'ACTIVE',
            updatedAfter: $.cursor,
            skipPaging: true,
          });


          fn(state => {
            console.log('# of TEIs found before filter ::', state.data.instances.length);
            const uniqueTeis = [];
            const duplicatePatients = [];
            const missingPatientNumber = [];
            const teisWithOMRSID = [];

            const filteredTeis = state.data.instances.filter(
              tei => tei.updatedAt >= state.cursor
            );

            console.log('Filtered TEIs ::', filteredTeis.length);
            const duplicateIds = findDuplicatePatient(filteredTeis);

            filteredTeis.forEach(tei => {
              const patientNumber = tei.attributes.find(
                attr => attr.code === 'patient_number'
              )?.value;
              const patientUid = tei.attributes.find(
                attr => attr.code === 'patient_uid' || attr.displayName === 'OpenMRS patient UID'
              )?.value;

              if (patientUid) {
                console.log(
                  `Skipping TEI:: ${tei.trackedEntity}. Found existing patient uid.`
                );
                teisWithOMRSID.push(tei)
              }

              if (!patientNumber) {
                missingPatientNumber.push(tei);
              } else if (duplicateIds.has(patientNumber)) {
                duplicatePatients.push(tei);
              } else {
                uniqueTeis.push(tei);
              }
            });

            console.log('# of Unique TEIs to migrate to OMRS ::', uniqueTeis.length);
            console.log('# Duplicate Patients found::', duplicatePatients.length);

            // return { uniqueTeis, duplicatePatients, filteredTeis, missingPatientNumber };
            return {
              ...state,
              data: {},
              references: [],
              uniqueTeis,
              teisWithOMRSID,
              duplicatePatients,
              missingPatientNumber,
            };
          });


          get('optionGroups/kdef7pUey9f', {
            fields: 'id,displayName,options[id,displayName,code]',
          });


          fn(({ data, ...state }) => {
            state.locations = data;
            return state;
          });
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 1845ba39-b556-452f-80db-c794c8b2bb9c
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          create-patients:
            disabled: false
            condition: |
              state.uniqueTeis.length > 0 && !state.errors
            openfn:
              uuid: b4e06a4a-f873-407f-824a-39ad2006ccb9
          alert-admin-of-duplicate-teis:
            disabled: false
            condition: |
              state.duplicatePatients.length > 0 && !state.errors
            openfn:
              uuid: c0260aec-64c9-4f5b-8327-bca677cfdcba
          validate-teis-with-omrs-id:
            disabled: false
            condition: |
              !state.errors && state. teisWithOMRSID.length > 0
            openfn:
              uuid: 3c86df64-2a6a-42d0-8107-affe53db8190
      - id: trigger
        type: cron
        openfn:
          enabled: false
          uuid: 836df7a7-d15f-4fc6-8f3d-5bb85c823218
          cron_expression: 0 0 * * *
        next:
          fetch-metadata:
            disabled: false
            condition: true
            openfn:
              uuid: 4f025e3a-80af-47ff-8c25-8891eff0c486
      - id: update-teis
        name: Update Teis
        expression: >
          fn(state => {
            if (state.newPatientUuid.length === 0) {
              console.log('No data fetched in step prior to sync.');
            }

            console.log(
              'newPatientUuid ::',
              JSON.stringify(state.newPatientUuid, null, 2)
            );
            return state;
          });


          // Update TEI on DHIS2

          each(
            $.newPatientUuid,
            upsert(
              'trackedEntityInstances',
              {
                ou: $.orgUnit,
                program: $.program,
                filter: [`${$.dhis2PatientNumberAttributeId}:Eq:${$.data.patient_number}`],
              },
              state => {
                const payload = {
                  orgUnit: state.orgUnit,
                  program: state.program,
                  trackedEntityType: 'cHlzCA2MuEF',
                  attributes: [
                    {
                      attribute: `${state.dhis2PatientNumberAttributeId}`,
                      value: `${state.data.patient_number}`,
                    }, //DHIS2 patient number to use as lookup key
                    { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
                    {
                      attribute: `${state.openmrsAutoIdAttributeId}`,
                      value: `${state.data.omrs_patient_number.identifier}`,
                    }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
                  ],
                }

                console.log('final payload to send to dhis2:', payload)
                return payload;
              }
            )
            // {
            //   orgUnit: $.orgUnit,
            //   program: $.program,
            //   trackedEntityType: 'cHlzCA2MuEF',
            //   attributes: [
            //     {
            //       attribute: `${$.dhis2PatientNumberAttributeId}`,
            //       value: `${state.data.patient_number}`,
            //     }, //DHIS2 patient number to use as lookup key
            //     { attribute: 'AYbfTPYMNJH', value: `${state.data.uuid}` }, //OMRS patient uuid
            //     {
            //       attribute: `${state.openmrsAutoIdAttributeId}`,
            //       value: `${state.data.omrs_patient_number.identifier}`,
            //     }, //id generated in wf1-2 e.g., "IQ146-24-000-027"
            //   ],
            // },
          );
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: f4702169-b017-43da-8e66-5ee3bfa305fb
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
      - id: validate-teis-with-omrs-id
        name: Validate TEIs with OMRS Id
        expression: >
          fn((state) => {
            state.patientUuids = state.teisWithOMRSID.map((patient) => {
              return patient.attributes.find(
                (attr) => attr.displayName === "OpenMRS patient UID"
              )?.value;
            });
            state.notFound ??= [];
            return state;
          });


          each(
            $.patientUuids,
            get(`patient/${$.data}`).catch((error, state) => {
              if (error) {
                const tei = state.teisWithOMRSID.find(
                  (tei) =>
                    tei.attributes.find(
                      (attr) => attr.displayName === "OpenMRS patient UID"
                    )?.value === state.data
                );
                state.notFound.push({ patient: state.data, tei: tei.trackedEntity });
              }
              return state;
            })
          );


          fnIf($.notFound.length > 0, (state) => {
            const details = state.notFound
              .map(
                ({ patient, tei }) =>
                  `Patient not found in OMRS for TEI:${tei} with OMRS ID: ${patient}.`
              )
              .join("\n");
            const e = new Error(details);
            throw e;
          });
        adaptor: "@openfn/language-openmrs@4.2.0"
        openfn:
          uuid: 97edd4ca-1cef-48af-827d-fd8d2450c4fe
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
    history: []
    openfn:
      uuid: 37e14ed6-2caa-4ee2-8d8a-84bcbbd901e0
      inserted_at: 2025-02-11T14:25:57Z
      updated_at: 2025-12-11T13:57:23Z
      lock_version: 45
    id: wf1-dhis2-omrs-migration
  - name: wf3-omrs-dhis2
    steps:
      - id: create-events
        name: Create Events
        expression: |
          // Create or update events for each encounter create(
          create(
            "tracker",
            {
              events: (state) => {
                console.log(
                  "Creating events for: ",
                  JSON.stringify(state.eventsMapping, null, 2)
                );
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 2d668d2e-c513-4b58-88bb-8a2d3261d9a2
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
      - id: custom-logic-for-events
        name: Custom Logic for Events
        expression: >
          const formIdByName = (name, formMaps) => {
            const entry = Object.entries(formMaps).find(([formId, form]) =>
              form.formName.includes(name)
            );
            return entry ? entry[0] : null;
          };

          const MILLISECONDS_PER_YEAR = 365.25 * 24 * 60 * 60 * 1000;

          const calculateAge = (dob) =>
            Math.floor((new Date() - new Date(dob)) / MILLISECONDS_PER_YEAR);

          const teiAge = (tei) => {
            let age = tei?.attributes?.find(
              (attr) => attr.attribute === "T1iX2NuPyqS"
            )?.value;

            if (!age) {
              const birthdate = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;
              age = calculateAge(birthdate);
            }
            return age;
          };


          const ageInDays = (dob, encounterDate) => {
            const birth = new Date(dob);
            const encounter = new Date(encounterDate);
            const diffTime = Math.abs(encounter - birth);
            return Math.floor(diffTime / (1000 * 60 * 60 * 24));
          };


          function f8(encounter) {
            const obsDatetime = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            )?.value;

            if (!obsDatetime) return [];
            const datePart = obsDatetime.substring(0, 10);
            const timePart = obsDatetime.substring(11, 19);
            return [
              {
                dataElement: "iQio7NYSA3m",
                value: timePart,
              },
              // {
              //   dataElement: "yprMS34o8s3",
              //   value: datePart,
              // }, //This mapping might have been removed, to be confirmed.
            ];
          }


          function f27(encounter) {
            const admissionDate = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            )?.value;
            if (!admissionDate) return [];
            const timePart = admissionDate.substring(11, 19);
            const datePart = admissionDate.replace("+0000", "");
            return [
              {
                dataElement: "eYvDzr2m8f5",
                value: timePart,
              },
              {
                eventDate: datePart,
              },
            ];
          }


          function f23(encounter) {
            // Define concept mappings object for cleaner reference
            const CONCEPT_ID = "f587c6a3-6a71-48ae-83b2-5e2417580b6f";

            const conditions = [
              {
                // 'Neonatal infection in previous pregnancy' is selected in OMRS
                dataElement: "H9noxo3e7ox",
                valueId: "09d6bb71-b061-4cae-85f3-2ff020a10c92",
              },
              {
                // 'Mother got antibiotics during delivery/post-partum ' is selected in OMRS
                dataElement: "GfN1TtpqDoJ",
                valueId: "3764bd79-9ae2-478a-88e7-51adc0a8a2e3",
              },
              {
                //'Infection in other baby if multiple pregnancy' is selected in OMRS
                dataElement: "WS1p4xgbZqU",
                valueId: "95d55453-060b-43a2-b4a0-11848dd9ac72",
              },
              {
                //'Maternal fever during labour' is selected in OMRS
                dataElement: "WX19iDuB4Dj",
                valueId: "890f4bdb-91bc-484c-a9cf-17f5068b0507",
              },
              {
                // 'Rupture of membranes â‰¥18h' is selected in OMRS
                dataElement: "eLKs6GUHJdS",
                valueId: "28d10ce0-7f72-4654-834d-64fa37ad8e85",
              },
              {
                // 'Pre-labour rupture of membranes <18h' is selected in OMRS
                dataElement: "hCfngwimBjX",
                valueId: "cf48d000-a741-44e0-81cb-a51f88595e41",
              },
              {
                // 'Smelling/cloudy amniotic fluid' is selected in OMRS
                dataElement: "qc7ubAwULxs",
                valueId: "49829d18-22c9-404c-a79a-49ed6b21d2be",
              },
            ];

            // Map through conditions and create final mapping
            return conditions.map((condition) => ({
              dataElement: condition.dataElement,
              value: findByConceptAndValue(encounter, CONCEPT_ID, condition.valueId)
                ? true
                : undefined,
            }));
          }

          function f41(encounter) {
            const obsDatetime = findObsByConcept(
              encounter,
              "40108bf5-0bbd-42e8-8102-bcbd0550a943"
            )?.value;
            if (!obsDatetime) return [];
            // what is obsdatetime?
            //TODO: extract time componenet and assign
            //TODO: set date component to eventDate attribute
            //TODO: use that when setting OccuredAt
            //TODO: Apply the same changes for f27
            const timePart = obsDatetime.substring(11, 19);
            const datePart = obsDatetime.replace("+0000", "");

            return [
              {
                dataElement: "gluXfK7zg1d",
                value: timePart,
              },
              {
                dataElement: "bkissws06TK",
                value: timePart,
              },
              {
                eventDate: datePart,
              },
            ];
          }


          function f42(encounter) {
            const obsDatetime = findObsByConcept(
              encounter,
              "7f00c65d-de60-467a-8964-fe80c7a85ef0"
            )?.value;
            if (!obsDatetime) return [];

            return [
              {
                dataElement: "xr2Dqw14DGX",
                value: obsDatetime,
              },
            ];
          }


          function f43(encounter, tei) {
            const mappings = [];
            const obsDatetime = findObsByConcept(
              encounter,
              "88472a4e-f26e-4235-8144-4ad6df874949"
            )?.value;

            const birthdate = tei?.attributes?.find(
              (attr) => attr.attribute === "WDp4nVor9Z7"
            )?.value;

            const datePart = obsDatetime.substring(0, 10);
            const timePart = obsDatetime.substring(11, 19);

            if (obsDatetime) {
              mappings.push(
                {
                  dataElement: "tR7XL9TPVkr",
                  value: datePart,
                },
                {
                  dataElement: "P8bmDESxYqn",
                  value: timePart,
                }
              );
            }

            if (birthdate) {
              mappings.push({
                dataElement: "Z2RzJFkXzII",
                value: ageInDays(birthdate, encounter.encounterDatetime),
              });
            }
            return mappings;
          }

          function mapAttribute(attributes, attributeMap) {
            const attrMapping = Object.entries(attributeMap)
              .map(([dataElement, attributeId]) => {
                const value = attributes?.find(
                  (attr) => attr.attribute === attributeId
                )?.value;

                return { dataElement, value };
              })
              .filter(Boolean);

            return attrMapping;
          }


          const findObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );

            return answer;
          };


          const findByConceptAndValue = (encounter, conceptUuid, value) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true) &&
                o.value.uuid === value
            );
            return answer;
          };


          const findDataValue = (encounter, dataElement, metadataMap) => {
            if (dataElement === "H9noxo3e7ox") {
              return;
            }
            const { optsMap, optionSetKey, form } = metadataMap;
            const [conceptUuid, questionId] =
              form.dataValueMap[dataElement]?.split("-rfe-");
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            const isObjectAnswer = answer && typeof answer.value === "object";
            const isStringAnswer = answer && typeof answer.value === "string";
            const isNumberAnswer = answer && typeof answer.value === "number";

            if (isStringAnswer || isNumberAnswer) {
              return answer.value;
            }

            if (isObjectAnswer) {
              const optionKey = questionId
                ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
                : `${encounter.form.uuid}-${answer.concept.uuid}`;
              const matchingOptionSet = optionSetKey[optionKey];

              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found

              // console.log({ matchingOptionSet, opt, matchingOption });
              // If we get errors on true/false, yes/no mappings remove && !matchingOptionSet
              if (["FALSE", "No"].includes(matchingOption) && !matchingOptionSet)
                return "false";
              if (["TRUE", "Yes"].includes(matchingOption) && !matchingOptionSet)
                return "true";

              return matchingOption;
            }

            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );

            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }

            return "";
          };


          const buildDataValues = (encounter, tei, mappingConfig) => {
            const {
              optsMap,
              optionSetKey,
              form,
              f08Form,
              f09Form,
              f23Form,
              f24Form,
              f25Form,
              f26Form,
              f27Form,
              f28Form,
              f41Form,
              f42Form,
              f43Form,
            } = mappingConfig;
            let formMapping = [];
            const visitUuid = encounter.visit.uuid;

            if ([f08Form, f09Form].includes(encounter.form.uuid)) {
              // F08 Form Encounter Mapping
              const f8Mapping = f8(encounter);
              formMapping.push(...f8Mapping);

              // F09 Form Encounter Mapping
              const attributeMap = {
                Lg1LrNf9LQR: "qptKDiv9uPl",
                OVo3FxLURtH: "k26cdlS78i9",
                f3n6kIB9IbI: "Rv8WM2mTuS5",
                oc9zlhOoWmP: "YUIQIA2ClN6",
                DbyD9bbGIvE: "Qq6xQ2s6LO8",
                fiPFww1viBB: "rBtrjV1Mqkz",
                FsL5BjQocuo: "Xvzc9e0JJmp",
                Pi1zytYdq6l: "P4wdYGkldeG",
              };
              const f09Mapping = mapAttribute(tei.attributes, attributeMap);
              formMapping.push(...f09Mapping);
            }

            if ([f23Form, f24Form].includes(encounter.form.uuid)) {
              // F23 Form Encounter Mapping
              const f23Mapping = f23(encounter);
              formMapping.push(...f23Mapping);

              // F24 Form Encounter Mapping
              const attributeMap = {
                Hww0CNYYt3E: "qptKDiv9uPl",
                // Z7vMFdnQxpE: "WDp4nVor9Z7",
                // L97SmAK11DN: "T1iX2NuPyqS",
                yE0dIWW0TXP: "rBtrjV1Mqkz",
                fnH6H3biOkE: "P4wdYGkldeG",
              };
              const attributeMapping = mapAttribute(tei.attributes, attributeMap);

              const dob = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;

              if (dob) {
                let ageInDays = calculateAge(dob) * 365;
                attributeMapping.push({
                  dataElement: "Z7vMFdnQxpE",
                  value: ageInDays,
                });
              }
              if (!dob) {
                const age = tei?.attributes?.find(
                  (attr) => attr.attribute === "T1iX2NuPyqS"
                )?.value;

                const ageInMonths = age * 12;

                attributeMapping.push({
                  dataElement: "L97SmAK11DN",
                  value: ageInMonths,
                });
              }

              formMapping.push(...attributeMapping);
            }

            if ([f25Form, f26Form].includes(encounter.form.uuid)) {
              const attributeMap = {
                eDuqRYx3wLx: "qptKDiv9uPl",
                d7wOfzPBbQD: "T1iX2NuPyqS",
                y9pK9sVcbU9: "k26cdlS78i9",
                // b7z6xIpzkim: "",
                CDuiRuOcfzj: "YUIQIA2ClN6",
                JMhFzB97fcS: "Qq6xQ2s6LO8",
                Nd43pz1Oo62: "rBtrjV1Mqkz",
                kcSuQKfU5Zo: "P4wdYGkldeG",
              };
              const attributeMapping = mapAttribute(tei.attributes, attributeMap);

              const dob = tei?.attributes?.find(
                (attr) => attr.attribute === "WDp4nVor9Z7"
              )?.value;

              if (dob) {
                let ageInDays = calculateAge(dob) * 365;
                attributeMapping.push({
                  dataElement: "b7z6xIpzkim",
                  value: ageInDays,
                });
              }

              formMapping.push(...attributeMapping);
            }

            if ([f27Form, f28Form].includes(encounter.form.uuid)) {
              // F27 Form Encounter Mapping
              const f27Mapping = f27(encounter);
              formMapping.push(...f27Mapping);

              // F28 Form Encounter Mapping
              const attributeMap = {
                WP5vr8KB2lH: "qptKDiv9uPl",
                Y7qzoa4Qaiz: "YUIQIA2ClN6",
                XCUd9xOGXkn: "Qq6xQ2s6LO8",
                onKT21rxH6Z: "rBtrjV1Mqkz",
                sCKCNreiqEA: "Xvzc9e0JJmp",
                ci9C72RjN8Z: "P4wdYGkldeG",
              };
              const attributeMapping = mapAttribute(tei.attributes, attributeMap);

              const f28Mapping = [
                {
                  dataElement: "NWOnMq8h4w1",
                  value: teiAge(tei),
                },
              ];
              formMapping.push(...attributeMapping, ...f28Mapping);
            }

            if ([f41Form, f42Form, f43Form].includes(encounter.form.uuid)) {
              // F41 Form Encounter Mapping
              const f41Mapping = f41(encounter);
              formMapping.push(...f41Mapping);

              // F42 Form Encounter Mapping
              const f42Mapping = f42(encounter);
              formMapping.push(...f42Mapping);

              // F43 Form Encounter Mapping
              const attributeMap = {
                eMXqL66pJSV: "qptKDiv9uPl",
                hT8pIot8b6Y: "k26cdlS78i9",
                BA7aQjiwlrL: "Rv8WM2mTuS5",
                KRNhyZHeGGM: "YUIQIA2ClN6",
                fUxvDvbPKlU: "Qq6xQ2s6LO8",
                xw5Vres1Ndt: "rBtrjV1Mqkz",
                iGHeO9F8CKm: "Xvzc9e0JJmp",
              };
              const f43AttributeMapping = mapAttribute(tei.attributes, attributeMap);
              formMapping.push(...f43AttributeMapping, ...f43(encounter, tei));
            }

            const dataValuesMapping = Object.keys(form.dataValueMap)
              .map((dataElement) => {
                const value = findDataValue(encounter, dataElement, {
                  optsMap,
                  optionSetKey,
                  form,
                });

                return { dataElement, value };
              })
              .filter((d) => d.value);

            dataValuesMapping.push({
              dataElement: "rbFVBI2N6Ex",
              value: visitUuid,
            });

            //setting the visitUuid here as a data element
            const combinedMapping = [...dataValuesMapping, ...formMapping].filter(
              Boolean
            );

            return combinedMapping;
          };


          fn((state) => {
            const f08Form = formIdByName("F08-ITFC Admission", state.formMaps);
            const f09Form = formIdByName("F09-ITFC Discharge", state.formMaps);
            const f23Form = formIdByName("F23-Neonatal Admission", state.formMaps);
            const f24Form = formIdByName("F24-Neonatal Discharge", state.formMaps);
            const f25Form = formIdByName("F25-Pediatrics Admission", state.formMaps);
            const f26Form = formIdByName("F26-Pediatrics Discharge", state.formMaps);
            const f27Form = formIdByName("F27-Adult Admission", state.formMaps);
            const f28Form = formIdByName("F28-Adult Discharge", state.formMaps);
            const f41Form = formIdByName("F41-ER Triage", state.formMaps);
            const f42Form = formIdByName("F42-ER Consultation", state.formMaps);
            const f43Form = formIdByName("F43-ER Exit", state.formMaps);

            const pairedEncounters = state.latestEncountersByVisit.reduce((acc, obj) => {
              const program = state.formMaps[obj.form.uuid].programId;
              const orgUnit = state.formMaps[obj.form.uuid].orgUnit;
              const programStage = state.formMaps[obj.form.uuid].programStage;
              const patientOuProgram = `${orgUnit}:${program}:${programStage}:${obj.patient.uuid}:${obj.visit.uuid}`;
              if (!acc[patientOuProgram]) {
                acc[patientOuProgram] = [];
              }
              acc[patientOuProgram].push(obj);
              return acc;
            }, {});

            state.eventsMapping = Object.entries(pairedEncounters).map(
              ([patientKey, patientEncounters]) => {
                const [orgUnit, program, programStage, patientUuid] =
                  patientKey.split(":");

                const tei = state.TEIs[patientUuid];

                const dataValues = patientEncounters
                  .map((encounter) => {
                    const form = state.formMaps[encounter.form.uuid];
                    if (!form?.dataValueMap) {
                      return null;
                    }
                    return buildDataValues(encounter, tei, {
                      optsMap: state.optsMap,
                      optionSetKey: state.optionSetKey,
                      form,
                      f08Form,
                      f09Form,
                      f23Form,
                      f24Form,
                      f25Form,
                      f26Form,
                      f27Form,
                      f28Form,
                      f41Form,
                      f42Form,
                      f43Form,
                    });
                  })
                  .flat()
                  .filter((d) => d.value);

                const latestEncounter = patientEncounters.sort(
                  (a, b) => new Date(b.encounterDatetime) - new Date(a.encounterDatetime)
                )[0];

                const eventDate = latestEncounter?.encounterDatetime.replace("+0000", "");

                const patientNumber = tei?.attributes?.find(
                  (a) => a.code === "patient_number"
                ).value;

                const visitUuid = latestEncounter.visit.uuid;
                const event = state.eventsByPatient[`${orgUnit}-${program}`]?.[
                  patientNumber
                ]?.find((e) => e.visitUuid === visitUuid)?.event;
                if (event) {
                  console.log("Event found:", event);
                }
                return {
                  event,
                  program,
                  orgUnit,
                  occurredAt: eventDate,
                  programStage,
                  dataValues,
                  trackedEntity: tei.trackedEntity,
                };
              }
            );

            return state;
          });
        adaptor: "@openfn/language-common@2.1.1"
        openfn:
          uuid: 782cdfc3-9357-4763-8681-798ae1b29fd1
        next:
          create-events:
            disabled: false
            condition: >
              state?.eventsMapping?.length > 0 && !state.errors &&
              !state.testMode
            openfn:
              uuid: 168e2969-4f85-4c05-843c-445ca7102086
      - id: get-encounters
        name: Get Encounters
        expression: >
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }


          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }

          const delay = (ms) => new Promise((resolve) => setTimeout(resolve,
          ms));

          // Fetch patient encounters

          each(
            $.patientUuids,
            get("encounter", { patient: $.data, v: "full" }).then((state) => {
              const patientUuid = state.references.at(-1);

              const filteredEncounters = state?.data?.results
                .filter(
                  (e) =>
                    e.auditInfo.dateCreated >= state.cursor &&
                    state.formUuids.includes(e?.form?.uuid)
                )
                .sort(
                  (a, b) =>
                    new Date(b.auditInfo.dateCreated) - new Date(a.auditInfo.dateCreated)
                );

              // Why we only keep the latest one form encounter?
              // const encounters = filteredEncounters.map((e) => e[0]).filter((e) => e);
              state.encounters ??= [];
              state.encounters.push(...filteredEncounters);

              console.log(
                state.encounters?.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );
              delay(1500);

              return state;
            })
          );


          fn((state) => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              encounters,
              ...next
            } = state;

            if (encounters?.length) {
              const encountersByVisit = encounters
                .map((encounter) => {
                  const { uuid, patient, obs, form, encounterDatetime, visit } =
                    removeLinks(removeNulls(encounter));

                  return {
                    visit: { uuid: visit.uuid },
                    uuid,
                    patient: {
                      uuid: patient.uuid,
                      display: patient.display,
                    },
                    obs: obs?.map((o) => {
                      return {
                        uuid: o.uuid,
                        concept: o.concept,
                        display: o.display,
                        formFieldPath: o.formFieldPath,
                        value: o.value,
                      };
                    }),
                    form: {
                      uuid: form?.uuid,
                      display: form?.display,
                      description: form?.description,
                      name: form?.name,
                    },
                    encounterDatetime,
                  };
                })
                .reduce((acc, curr) => {
                  const visitPerForm = `${curr.visit.uuid}-${curr.form.uuid}`;
                  if (!acc[visitPerForm]) {
                    acc[visitPerForm] = [curr];
                  } else {
                    acc[visitPerForm].push(curr);
                  }

                  return acc;
                }, {});

              next.latestEncountersByVisit = Object.values(encountersByVisit)
                .map((encounters) => encounters[0]) // Latest encounter per visit
                .flat();

              next.encountersPatientUuids = [
                ...new Set(
                  next.latestEncountersByVisit.map((encounter) => encounter.patient.uuid)
                ),
              ];
            } else {
              console.log("No encounters found for cursor: ", next.cursor);
            }

            return next;
          });
        adaptor: "@openfn/language-openmrs@4.3.0"
        openfn:
          uuid: 2b1e02ae-7546-480a-86cc-77a815f61256
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
        next:
          get-teis-and-map-answers:
            disabled: false
            condition: |
              !state.errors && state?.encounters?.length > 0
            openfn:
              uuid: bd5834d4-b481-47f0-b497-c56dbd05ed03
      - id: get-mappings-from-collection
        name: Get Mappings from Collection
        expression: >
          const isValidUUID = (id) => {
            if (!id || typeof id !== "string") return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };


          collections.get("mosul-metadata-mappings-staging").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);
            state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
            state.formMetadata = state.data.find((i) => i.key === "formMetadata")?.value;
            state.placeOflivingMap = state.data.find(
              (i) => i.key === "placeOflivingMap"
            )?.value;
            state.sourceFile = state.data.filter(
              (i) => i.key === "sourceFile"
            )?.[0]?.value;
            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;
            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            // TODO: Remove state.optionSetKey, when needed
            // Build from state.formMaps
            state.optionSetKey = state.data.filter(
              (i) => i.key === "optionSetKey"
            )?.[0]?.value;

            delete state.data;
            delete state.references;
            return state;
          });


          fn((state) => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) &&
                  form["OMRS Form Version"] === "v4-2025"
              )
              .map((form) => form["OMRS form.uuid"]);
            rest.formUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF3"
              )
              .map((form) => form["OMRS form.uuid"]);

            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];

            rest.orgUnit = "sUpt0j2GmBD";

            rest.program = "dWdzxMuKa8Z";

            rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });
        adaptor: "@openfn/language-common@2.3.0"
        openfn:
          uuid: 0acf6701-064d-412d-8672-db507c9e95c6
          project_credential_id: 90cddfa1-9b77-4625-a812-2a04d061522c
        next:
          get-encounters:
            disabled: false
            condition: |
              !state.errors && state.patients.length === 0
            openfn:
              uuid: d9d6c1fb-627e-491e-88b1-ed2575e77de3
          upsert-teis:
            disabled: false
            condition: |
              state.patients.length > 0 && !state.errors
            openfn:
              uuid: 7b001148-c273-49f5-9582-09979cbd4ca9
      - id: get-patients
        name: Get Patients
        expression: >
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }


          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }

          cursor($.lastRunDateTime || $.manualCursor ||
          "2025-03-20T06:01:24.000Z");


          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });


          searchPatient({
            q: $.msfId || "IQ",
            v: "full",
            limit: "100",
          });


          fn((state) => {
            const { cursor, data, lastRunDateTime } = state;
            console.log("Filtering patients since cursor:", cursor);

            state.patients = data.results
              .filter(({ auditInfo }) => {
                const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
                return lastModified > cursor;
              })
              .map((p) => {
                const { uuid, auditInfo, identifiers, person } = removeLinks(
                  removeNulls(p)
                );
                const { dateCreated } = auditInfo;
                const { age, birthdate, gender, names, addresses, attributes } = person;

                return {
                  uuid,
                  person: {
                    age,
                    birthdate,
                    gender,
                    names,
                    addresses: [addresses.find((a) => a.cityVillage)],
                    attributes,
                  },
                  identifiers,
                  auditInfo: { dateCreated },
                };
              });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });


          // Fetch all encounters

          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );


          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });


          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [
              ...new Set([...searchPatientUuids, ...encounterPatientUuids]),
            ];

            console.log("inbothResults", inbothResults.length);
            console.log("patient-search-array", onlyInSearchPatient.length);
            console.log("r4-encounter-array", onlyInR4Encounter.length);
            console.log("combined uuids", patientUuids.length);

            return { cursor, lastRunDateTime, patients, patientUuids };
          });
        adaptor: "@openfn/language-openmrs@4.3.0"
        openfn:
          uuid: 51485ee3-05c2-4690-8da6-9b962b6c19d5
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
        next:
          get-mappings-from-collection:
            disabled: false
            openfn:
              uuid: 15dc93e4-fb96-4cc5-b0c3-c0bd544bdc6d
      - id: get-teis-and-map-answers
        name: Get TEIs and Map Answers
        expression: >
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve,
          ms));


          const teiByPatientUuid = (patientUuid, teis) => {
            return teis.find((tei) => {
              const omrsPatientUuid = tei.attributes.find(
                ({ attribute }) => attribute === "AYbfTPYMNJH"
              )?.value;

              return omrsPatientUuid === patientUuid;
            });
          };


          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            program: $.program,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${state.encountersPatientUuids.join(";")}`,
            ],
            fields: "*",
          });


          fn((state) => {
            state.TEIs ??= {};
            state.encountersPatientUuids.forEach((patientUuid) => {
              const tei = teiByPatientUuid(patientUuid, state.data.instances);
              if (tei?.trackedEntity) {
                console.log("Parent TEI found:", tei.trackedEntity);

                state.TEIs[patientUuid] = {
                  ...tei,
                  enrollment: tei.enrollments[0]?.enrollment,
                };
              } else {
                console.log("Parent TEI Not Found for Patient:", patientUuid);
              }
            });

            return state;
          });


          fn((state) => {
            state.ouProgramTeis = state.latestEncountersByVisit.reduce((acc, obj) => {
              const formUuid = obj.form.uuid;
              // const patientUuid = obj.patient.uuid;
              const patientNumber = obj.patient.display.split(" - ")[0];
              const orgUnit = state.formMaps[formUuid].orgUnit;
              const program = state.formMaps[formUuid].programId;
              const key = `${orgUnit}-${program}`;
              if (!acc[key]) {
                acc[key] = {
                  orgUnit,
                  program,
                  patientNumbers: [patientNumber],
                };
              }
              if (!acc[key].patientNumbers.includes(patientNumber)) {
                acc[key].patientNumbers.push(patientNumber);
              }

              return acc;
            }, {});

            return state;
          });


          each(
            (state) => Object.values(state.ouProgramTeis),
            get("tracker/events", (state) => {
              const { orgUnit, program } = state.data;
              return {
                orgUnit,
                program,
                fields: "*",
              };
            }).then((state) => {
              const { orgUnit, program, patientNumbers } = state.references.at(-1);
              state.eventsByPatient ??= {};
              const grouped = state.data.instances?.reduce((acc, event) => {
                const patientNumber = event.dataValues.find(
                  (dv) => dv.dataElement === "Pi1zytYdq6l" ||
                          dv.dataElement === "fnH6H3biOkE" ||
                          dv.dataElement === "kcSuQKfU5Zo" ||
                          dv.dataElement === "ci9C72RjN8Z"
                )?.value;
                if (!patientNumber || !patientNumbers.includes(patientNumber)) {
                  return acc;
                }
                const visitUuid = event.dataValues.find(
                  (dv) => dv.dataElement === "rbFVBI2N6Ex"
                )?.value;

                if (!acc[patientNumber]) {
                  acc[patientNumber] = [];
                }
                acc[patientNumber].push({
                  event: event.event,
                  occuredAt: event.occuredAt,
                  visitUuid
                });
                return acc;
              }, {});
              console.log(`Processing ${state.data.instances?.length || 0} events for ${orgUnit}-${program}`);
              console.log("Grouped events by patient:", Object.keys(grouped).length, "patients");
              state.eventsByPatient[`${orgUnit}-${program}`] = grouped;
              return state;
            })
          );
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 7a1831ef-a388-4565-bf44-d603fdd19871
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          custom-logic-for-events:
            disabled: false
            condition: |
              state.TEIs && !state.errors
            openfn:
              uuid: 9eb6f99d-434c-4b47-ab4b-058a5930435c
      - id: get-tie
        name: Get Tie
        expression: >
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));


          const patientUid = "d464433d-41d5-482f-808c-7fe364847352"

          //TODO: Group the encounters by patient and then get the TEI for each
          patient

          get('tracker/trackedEntities', state => ({
            orgUnit: "sUpt0j2GmBD",
            program: "dWdzxMuKa8Z",
            // orgUnit: state.formMaps[state.data.form.uuid].orgUnit, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            // program: state.formMaps[state.data.form.uuid].programId, //TODO: the org unit and program should be fetched from fromMap by mapping encounter.form.uuid
            filter: [`AYbfTPYMNJH:Eq:${patientUid}`],
            fields: '*,enrollments[*],enrollments[events[*]], attributes[*]',
          })).then(async state => {
            
            console.log(patientUid, 'Encounter patient uuid');

            const { trackedEntity, enrollments, attributes } = state.data?.instances?.[0] || {};
            if (trackedEntity && enrollments) {
              state.TEIs ??= {};
              state.TEIs[patientUid] = {
                trackedEntity,
                events: enrollments[0]?.events,
                enrollment: enrollments[0]?.enrollment,
                attributes
              };
            }

            await delay(2000);
            return state;
          })
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 47c1397c-a146-4511-bada-7ab0bd07b123
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          custom-logic-for-events:
            disabled: false
            condition: |
              state.testMode
            openfn:
              uuid: 80f9eb77-8bc4-4557-8c9b-907ab7408473
      - id: trigger
        type: cron
        openfn:
          enabled: false
          uuid: cd9ea573-fb86-4ec4-8c39-200c7de22dfb
          cron_expression: 0 0 * * *
        next:
          get-patients:
            disabled: false
            condition: true
            openfn:
              uuid: d681f4f9-4e4f-415f-a52c-a6fcd9f2740b
      - id: upsert-teis
        name: Upsert TEIs
        expression: >
          const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
            const genderMap = {
              M: "male",
              O: "unknown",
              F: "female",
              U: "unknown",
            };
            const {
              orgUnit,
              program,
              optsMap,
              formMaps,
              placeOflivingMap,
              patientProgramStage,
              dhis2PatientNumber,
              openmrsAutoId,
            } = mappingConfig;

            const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findOptsUuid = (uuid) =>
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value?.uuid ||
              omrsPatient.person.attributes.find((a) => a.attributeType.uuid === uuid)
                ?.value;

            const findOptCode = (uuid) => {
              const optionKey = `patient-${uuid}`;
              const matchingOptionSet = state.optionSetKey[optionKey];
              return optsMap.find((o) => o["value.uuid - External ID"] === uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet)?.[
                "DHIS2 Option Code"
              ];
            };

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const optUid = findOptsUuid(patientMap[d]);
              return {
                attribute: d,
                value: findOptCode(optUid) || optUid,
              };
            });

            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: omrsPatient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: omrsPatient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber) ||
                  findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: omrsPatient.uuid,
              },

              {
                attribute: "T1iX2NuPyqS",
                value: omrsPatient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: omrsPatient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

            const payload = {
              program,
              orgUnit,
              attributes: [...filteredAttr, ...filteredStatusAttr],
            };
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));

            if (!patientTei) {
              payload.trackedEntityType = "cHlzCA2MuEF";
              const enrollments = [
                {
                  orgUnit,
                  program,
                  enrolledAt,
                  programStage: patientProgramStage, //'MdTtRixaC1B',
                },
              ];
              payload.attributes.push({
                attribute: "qptKDiv9uPl",
                value: genderMap[omrsPatient.person.gender],
              });
              console.log("create enrollment");
              payload.enrollments = enrollments;
            } else {
              payload.trackedEntity = patientTei.trackedEntity;
              payload.trackedEntityType = patientTei.trackedEntityType;
            }

            return payload;
          };


          const delay = (ms) => new Promise((resolve) => setTimeout(resolve,
          ms));


          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${state.patients.map((patient) => patient.uuid).join(";")}`,
            ],
            program: $.program,
          });


          fn((state) => {
            const findTeiByUuid = (patientUuid) => {
              return state.data.instances.find((tei) => {
                return (
                  tei.attributes.find(
                    (attribute) => attribute.attribute === "AYbfTPYMNJH"
                  )?.value === patientUuid
                );
              });
            };

            state.patientsMapping = state.patients.map((patient) => {
              const patientTei = findTeiByUuid(patient.uuid);

              return buildTeiMapping(patient, patientTei, {
                placeOflivingMap: state.placeOflivingMap,
                orgUnit: state.orgUnit,
                program: state.program,
                patientProgramStage: state.patientProgramStage,
                formMaps: state.formMaps,
                optsMap: state.optsMap,
                dhis2PatientNumber: state.dhis2PatientNumber,
                openmrsAutoId: state.openmrsAutoId,
              });
            });

            return state;
          });


          // Bulk upsert

          create(
            "tracker",
            { trackedEntities: $.patientsMapping },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );


          fn((state) => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              identifiers,
              ...next
            } = state;
            next.patientUuids = patients.map((p) => p.uuid);
            return next;
          });
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: f628007a-5a2c-463f-9de3-d2e465f95aae
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          get-encounters:
            disabled: false
            condition: |
              state.patientUuids.length > 0 && !state.errors
            openfn:
              uuid: 1d37cfc8-1a71-4cc8-809d-583d6d8b8fca
    history: []
    openfn:
      uuid: fb49b01d-dba8-420a-9f4c-b9ca20984ee5
      inserted_at: 2025-06-26T12:56:25Z
      updated_at: 2025-12-16T10:35:10Z
      lock_version: 55
    id: wf3-omrs-dhis2
  - name: wf2-omrs-dhis2
    steps:
      - id: create-events
        name: Create Events
        expression: >
          const buildTeiUrl = (baseUrl, { trackedEntity, program, orgUnit }) =>
          {
            return `${baseUrl}/dhis-web-tracker-capture/index.html#/dashboard?tei=${trackedEntity}&program=${program}&ou=${orgUnit}`;
          };

          // Create or update events for each encounter

          create(
            "tracker",
            {
              events: (state) => {
                const baseUrl = state.configuration.hostUrl;

                const groupedEvents = state.eventsMapping.reduce((acc, event) => {
                  const { trackedEntity, program, orgUnit } = event;
                  const key = `${trackedEntity}-${program}-${orgUnit}`;
                  if (!acc[key]) {
                    acc[key] = [];
                  }
                  acc[key].push(event);
                  return acc;
                }, {});
                Object.entries(groupedEvents).forEach(([key, events]) => {
                  const [trackedEntity, program, orgUnit] = key.split("-");

                  const teiUrl = buildTeiUrl(baseUrl, {
                    trackedEntity,
                    program,
                    orgUnit,
                  });

                  console.log({ events, teiUrl });
                });
                return state.eventsMapping;
              },
            },
            {
              params: {
                async: false,
                dataElementIdScheme: "UID",
                importStrategy: "CREATE_AND_UPDATE",
              },
            }
          );


          const findlatestAnswer = (encounters, conceptUuid) => {
            const latestAnswer = encounters.reduce((acc, e) => {
              const answer = e.obs.find((o) => o.concept.uuid === conceptUuid);
              if (answer) {
                const personUuid = answer.person.uuid;
                if (
                  !acc[personUuid] ||
                  new Date(answer.obsDatetime) > new Date(acc[personUuid].obsDatetime)
                ) {
                  acc[personUuid] = { ...answer, formUuid: e.form.uuid };
                }
              }
              return acc;
            }, {});

            return Object.values(latestAnswer);
          };


          fn((state) => {
            const {
              encounters,
              childTeis,
              parentTeis,
              program,
              orgUnit,
              optsMap,
              // Lighten state by removing unused properties
              formMaps,
              optionSetKey,
              eventsMapping,
              formUuids,
              references,
              ...next
            } = state;

            const genderMap = optsMap
              .filter((o) => o["DHIS2 DE UID"] === "qptKDiv9uPl")
              .reduce((acc, obj) => {
                acc[obj["value.display - Answers"]] = obj["DHIS2 Option Code"];
                return acc;
              }, {});

            const latestGenderUpdate = findlatestAnswer(
              encounters,
              "ec42d68d-3e23-43de-b8c5-a03bb538e7c7"
            );

            const genderUpdated = latestGenderUpdate
              .map((answer) => {
                const chilProgram = formMaps[answer.formUuid].programId;
                const childOrgUnit = formMaps[answer.formUuid].orgUnit;
                const personUuid = answer.person.uuid;
                const parentTei = parentTeis[personUuid].trackedEntity;
                const childTei =
                  childTeis[`${childOrgUnit}-${chilProgram}-${personUuid}`].trackedEntity;

                const mappings = [];
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "qptKDiv9uPl", //gender
                      value: genderMap[answer.value.display],
                    },
                    {
                      attribute: "AYbfTPYMNJH", //OpenMRS Patient UID to use to upsert TEI
                      value: answer.person.uuid,
                    },
                  ],
                };
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }
                if (childTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntityInstance: childTei,
                    program: chilProgram,
                    orgUnit: childOrgUnit,
                  });
                }
                if (parentTei) {
                  mappings.push({
                    ...sharedMapping,
                    trackedEntityInstance: parentTei,
                    program,
                    orgUnit,
                  });
                }
                return mappings;
              })
              .filter(Boolean)
              .flat();

            const latestEducationUpdate = findlatestAnswer(
              encounters,
              "cc3a5a7a-abfe-4630-b0c0-c1275c6cbb54"
            );

            // console.log({ latestEducationUpdate })
            const educationUpdated = latestEducationUpdate
              .map((answer) => {
                const chilProgram = formMaps[answer.formUuid].programId;
                const childOrgUnit = formMaps[answer.formUuid].orgUnit;
                const personUuid = answer.person.uuid;
                const parentTei = parentTeis[personUuid]?.trackedEntity;
                const childTei =
                  childTeis[`${childOrgUnit}-${chilProgram}-${personUuid}`]
                    ?.trackedEntity;
                console.log({ parentTei, childTei });
                const mappings = [];
                const sharedMapping = {
                  trackedEntityType: "cHlzCA2MuEF",
                  attributes: [
                    {
                      attribute: "Dggll4f9Efj", //education
                      value: optsMap.find(
                        (o) => o["value.display - Answers"] === answer.value.display
                      )?.["DHIS2 Option Code"], //map to DHIS2 Option Code in optsMap
                    },
                  ],
                };
                if (!childTei) {
                  console.log("No TEI found for person", answer.person.uuid);
                }

                if (parentTei) {
                  mappings.push({
                    trackedEntityInstance: parentTei,
                    program,
                    orgUnit,
                    ...sharedMapping,
                  });
                }
                if (childTei) {
                  mappings.push({
                    trackedEntityInstance: childTei,
                    program: chilProgram,
                    orgUnit: childOrgUnit,
                    ...sharedMapping,
                  });
                }

                return mappings;
              })
              .filter(Boolean)
              .flat();

            return {
              ...next,
              teisToUpdate: [...genderUpdated, ...educationUpdated],
            };
          });


          fnIf(
            (state) => state.teisToUpdate.length === 0,
            ({ lastRunDateTime }) => ({ lastRunDateTime })
          );
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: bc9ae464-bc1c-42ef-8d8d-24614ce5e4f1
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          update-teis:
            disabled: false
            condition: |
              state?.teisToUpdate?.length > 0
            openfn:
              uuid: 30bc10fc-d40f-4704-81f4-a05fefc5e1e3
      - id: create-teis-relationship
        name: Create TEIs Relationship
        expression: >
          fn((state) => {
            state.relationshipsMapping = Object.values(state.childTeis)
              .map((tei) => {
                const omrsPatientUuid = tei?.attributes.find(
                  ({ attribute }) => attribute === "AYbfTPYMNJH"
                )?.value;

                const childTei = tei?.trackedEntity;
                const parentTei = state.parentTeis[omrsPatientUuid]?.trackedEntity;
                const relationshipType = tei?.relationshipType;

                if (childTei != parentTei) {
                  return {
                    from: {
                      trackedEntityInstance: {
                        trackedEntityInstance: parentTei,
                      },
                    },
                    to: {
                      trackedEntityInstance: {
                        trackedEntityInstance: childTei,
                      },
                    },
                    relationshipType,
                  };
                }
              })
              .filter(Boolean);

            return state;
          });

          // Check if relationship exist

          each(
            $.relationshipsMapping,
            get("tracker/relationships", {
              trackedEntity: $.data.from.trackedEntityInstance.trackedEntityInstance,
            }).then((state) => {
              const relationship = state.references.at(-1);
              const toTei = relationship.to.trackedEntityInstance.trackedEntityInstance;
              const hasRelationship = state.data.instances.find(
                (r) => r.to.trackedEntity.trackedEntity === toTei
              );
              state.relationshipsToCreate ??= [];
              if (!hasRelationship) {
                state.relationshipsToCreate.push(relationship);
              }
              return state;
            })
          );


          // Creating relationship between parent and child tei

          each($.relationshipsToCreate || [], create("relationships", $.data));
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: ff3980d5-2f46-41f0-8d63-ccb63328325d
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          event-mappings:
            disabled: false
            condition: |
              state.childTeis && !state.errors
            openfn:
              uuid: d11da1ea-7d5d-4021-8ecb-9394be06623d
      - id: event-mappings
        name: Event Mappings
        expression: >
          const findAnswerByConcept = (encounter, conceptUuid) => {
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            return answer?.value?.display;
          };


          // Helper functions for finding observations

          const findObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answer = encounter.obs.find(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );
            return answer;
          };


          const filterObsByConcept = (encounter, conceptUuid) => {
            const [conceptId, questionId] = conceptUuid.split("-rfe-");
            const answers = encounter.obs.filter(
              (o) =>
                o.concept.uuid === conceptId &&
                (questionId ? o.formFieldPath === `rfe-${questionId}` : true)
            );
            return answers;
          };


          function mapF11(encounter, optsMap) {
            if (encounter.form.description.includes("F11-Family Planning Assessment")) {
              const answers = encounter.obs.filter(
                (o) => o.concept.uuid === "30b2d692-6a05-401f-8ede-13e027b8a436"
              );

              const mappingConfig = [
                { dataElement: "DYTLOoEKRas", index: 0 },
                { dataElement: "ddTrzQtQUGz", index: 1 },
                { dataElement: "fuNs3Uzspsm", index: 2 },
              ];

              return mappingConfig.map((config) => {
                if (answers[config.index]) {
                  return {
                    dataElement: config.dataElement,
                    value: optsMap.find(
                      (o) =>
                        o["value.display - Answers"] ===
                        answers[config.index]?.value?.display
                    )?.["DHIS2 Option Code"],
                  };
                }
              });
            }
          }

          function mapF13(encounter, optsMap) {
            if (encounter.form.description.includes("F13-PNC")) {
              const answers = encounter.obs.filter(
                (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
              );

              // Define mapping configurations
              const mappingConfig = [
                { dataElement: "ErtqJsZINyX", index: 0 },
                { dataElement: "wWAMdsjks50", index: 1 },
                { dataElement: "Dh1ocjojOrC", index: 2 },
                { dataElement: "KR03PHkzVw1", index: 3 },
                { dataElement: "kDA55sgLAwY", index: 4 },
              ];

              // Only add mappings for answers that exist
              return mappingConfig.map((config) => {
                if (answers[config.index] !== undefined) {
                  return {
                    dataElement: config.dataElement,
                    value: optsMap.find(
                      (o) =>
                        o["value.display - Answers"] ===
                        answers[config.index]?.value?.display
                    )?.["DHIS2 Option Code"],
                  };
                }
              });
            }
          }


          function mapF16(encounter) {
            const answers = encounter.obs.filter(
              (o) => o.concept.uuid === "877aa979-c02f-4890-8156-836d52696f09"
            );

            if (encounter.form.description.includes("F16-Operative Report") && answers) {
              const [date, time] = encounter.encounterDatetime.split("T");
              return [
                {
                  dataElement: "ZQgbPvQ7dWC",
                  value: date,
                },
                {
                  dataElement: "onsyxszD8X7",
                  value: time,
                },
              ];
            }
            return;
          }


          function mapF17(encounter) {
            const mappings = [];
            if (
              encounter.form.description.includes("F17-Surgery Admission") &&
              findObsByConcept(encounter, "13d4d6b8-0cd3-46c5-be7b-c3a7565aaca7")
            ) {
              mappings.push({
                dataElement: "hMqZO0MIIT1",
                value: "hours",
              });
            }
            if (
              encounter.form.description.includes("F17-Surgery Admission") &&
              findObsByConcept(encounter, "7f00c65d-de60-467a-8964-fe80c7a85ef0")
            ) {
              const [date, time] = encounter.encounterDatetime.split("T");
              mappings.push(
                {
                  dataElement: "DEGa7RaIDTo",
                  value: date,
                },
                {
                  dataElement: "aUSp8oQZIWu",
                  value: date,
                },
                {
                  dataElement: "mDOUf2zzwS2",
                  value: time,
                }
              );
            }
            return mappings;
          }


          function mapF18(encounter, encounters) {
            const isDischarge = findObsByConcept(
              encounter,
              "13cea1c8-e426-411f-95b4-33651fc4325d"
            );

            if (
              encounter.form.description.includes("F18-Surgery Discharge") &&
              isDischarge
            ) {
              const lastAdmission = formEncounters("F17-Surgery Admission", encounters)
                .at(-1)
                ?.encounterDatetime.replace("+0000", "");
              return [
                {
                  dataElement: "zt3Ocipob8I",
                  value: lastAdmission,
                },
              ];
            }
          }


          function mapF22(encounter) {
            const answers = filterObsByConcept(
              encounter,
              "38d5dcf5-b8bf-420e-bb14-a270e1f518b3"
            ).map((o) => o.value.display);

            if (answers.length === 0) {
              return;
            }
            // Define mapping configurations
            const mappingConfig = [
              { dataElement: "y5EEruMtgG1", has: "None" },
              { dataElement: "SqCZBLTRSt7", has: "Ventilation" },
              { dataElement: "hW2US5pqO9c", has: "Cardiac massage" },
              { dataElement: "ZgzXA4TjsDg", has: "Adrenaline" },
              { dataElement: "BYxj9JiIETF", has: "Other" },
            ];

            return mappingConfig
              .map((config) => {
                if (answers.some((a) => a.includes(config.has))) {
                  return {
                    dataElement: config.dataElement,
                    value: true,
                  };
                }
              })
              .filter(Boolean);
          }


          function mapF29(encounter, optsMap) {
            const CONCEPTS = {
              OTHER_SPECIFY: "e08d532b-e56c-43dc-b831-af705654d2dc",
              PRECIPITATING_EVENT_OTHER: "790b41ce-e1e7-11e8-b02f-0242ac130002", // Todo: no used anywhere
            };
            const mappings = [];
            if (encounter.form.description.includes("F29-MHPSS Baseline v2")) {
              mappings.push({
                dataElement: "pN4iQH4AEzk",
                value: findAnswerByConcept(
                  encounter,
                  "22809b19-54ca-4d88-8d26-9577637c184e"
                )
                  ? true
                  : false,
              });

              const priority1 = findObsByConcept(
                encounter,
                "45b39cbf-0fb2-4682-8544-8aaf3e07a744"
              );
              if (priority1 && priority1?.value?.display === "Other") {
                mappings.push({
                  dataElement: "pj5hIE6iyAR",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY)?.value,
                });
              }

              const priority2 = findObsByConcept(
                encounter,
                "ee1b7973-e931-494e-a9cb-22b814b4d8ed"
              );
              if (priority2 && priority2?.value?.display === "Other") {
                mappings.push({
                  dataElement: "Em5zvpdd5ha",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY)?.value,
                });
              }

              const priority3 = findObsByConcept(
                encounter,
                "92a92f62-3ff6-4944-9ea9-a7af23949bad"
              );
              if (priority3 && priority3?.value?.display === "Other") {
                mappings.push({
                  dataElement: "aWsxYkJR8Ua",
                  value: findObsByConcept(encounter, CONCEPTS.OTHER_SPECIFY)?.value,
                });
              }

              const precipitatingEvent1 = findObsByConcept(
                encounter,
                "d5e3d927-f7ce-4fdd-ac4e-6ad0b510b608"
              );
              const otherValue = encounter.obs.find((o) =>
                o.display.includes("Past / Precipitating Events - Other")
              );

              if (
                precipitatingEvent1 &&
                precipitatingEvent1?.value?.uuid === otherValue?.value?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );

                mappings.push({
                  dataElement: "m8qis4iUOTo",
                  value: opt?.["DHIS2 Option Code"],
                });
              }

              const precipitatingEvent2 = findObsByConcept(
                encounter,
                "54a9b20e-bce5-4d4a-8c9c-e0248a182586"
              );

              if (
                precipitatingEvent2 &&
                precipitatingEvent2?.value?.uuid === otherValue?.value?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );
                mappings.push({
                  dataElement: "mNK6CITsdWD",
                  value: opt?.["DHIS2 Option Code"],
                });
              }

              const precipitatingEvent3 = findObsByConcept(
                encounter,
                "e0d4e006-85b5-41cb-8a21-e013b1978b8b"
              );

              if (
                precipitatingEvent3 &&
                precipitatingEvent3?.value?.uuid === otherValue?.uuid
              ) {
                const opt = optsMap.find(
                  (o) => o["value.uuid - External ID"] === otherValue?.value?.uuid
                );
                mappings.push({
                  dataElement: "jocqmYW394G",
                  value: opt?.["DHIS2 Option Code"],
                });
              }
            }
            return mappings;
          }


          function mapF30F29(encounter, allEncounters) {
            if (encounter.form.description.includes("F30-MHPSS Follow-up v2")) {
              const missedSession = (encounter) => {
                if (
                  encounter.obs.find(
                    (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                  )?.value?.display === "No"
                ) {
                  return encounter.encounterDatetime.replace("+0000", "");
                }
                const lastFollowupEncounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F30-MHPSS Follow-up v2") &&
                    e.patient.uuid === encounter.patient.uuid &&
                    e.uuid !== encounter.uuid &&
                    e.obs.find(
                      (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                    )?.value?.display === "No"
                );

                if (lastFollowupEncounter) {
                  return lastFollowupEncounter.encounterDatetime.replace("+0000", "");
                }

                const f29Encounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F29-MHPSS Baseline v2") &&
                    e.patient.uuid === encounter.patient.uuid
                );
                if (f29Encounter) {
                  return f29Encounter.encounterDatetime.replace("+0000", "");
                }
                return undefined;
              };
              const mapping = [
                {
                  dataElement: "jtKIoKducvE",
                  value: missedSession(encounter),
                },
              ];
              return mapping;
            }
          }


          function mapF32F31(encounter, allEncounters) {
            if (encounter.form.description.includes("F32-mhGAP Follow-up v2")) {
              const missedSession = (encounter) => {
                if (
                  encounter.obs.find(
                    (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                  )?.value?.display === "No"
                ) {
                  return encounter.encounterDatetime.replace("+0000", "");
                }
                const lastFollowupEncounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F32-mhGAP Follow-up v2") &&
                    e.patient.uuid === encounter.patient.uuid &&
                    e.uuid !== encounter.uuid &&
                    e.obs.find(
                      (o) => o.concept.uuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9"
                    )?.value?.display === "No"
                );

                if (lastFollowupEncounter) {
                  return lastFollowupEncounter.encounterDatetime.replace("+0000", "");
                }

                const f31Encounter = allEncounters.find(
                  (e) =>
                    e.form.description.includes("F31-mhGAP Baseline v2") &&
                    e.patient.uuid === encounter.patient.uuid
                );

                if (f31Encounter) {
                  return f31Encounter.encounterDatetime.replace("+0000", "");
                }
              };
              const changeInDiagnosis = (encounter) => {
                const patientUuid = encounter.patient.uuid;
                const previousChangeInDiagnosis = allEncounters
                  .find(
                    (e) =>
                      e.patient.uuid === patientUuid &&
                      e.form.description.includes("F32-mhGAP Follow-up v2") &&
                      encounter.uuid !== e.uuid
                  )
                  ?.obs.find(
                    (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
                  )?.value?.display;

                const currentChangeInDiagnosis = encounter.obs.find(
                  (o) => o.concept.uuid === "22809b19-54ca-4d88-8d26-9577637c184e"
                )?.value?.display;

                if (
                  previousChangeInDiagnosis &&
                  previousChangeInDiagnosis !== currentChangeInDiagnosis
                ) {
                  return true;
                }

                return false;
              };
              const mapping = [
                {
                  dataElement: "fMqEZpiRVZV",
                  value: missedSession(encounter),
                },
                {
                  dataElement: "XBVRRpgkEvE",
                  value: changeInDiagnosis(encounter),
                },
              ];
              return mapping;
            }
          }


          function mapF33F34(encounter, allEncounters) {
            if (
              encounter.form.description.includes("F33-MHPSS Closure v2") ||
              encounter.form.description.includes("F34-mhGAP Closure v2")
            ) {
              const lastScore = encounter.obs.find(
                (o) => o.concept.uuid === "90b3d09c-d296-44d2-8292-8e04377fe027"
              )?.value;

              const filterOutScore = allEncounters.filter((e) => {
                const obs = e.obs.find(
                  (o) => o.concept.display === "Mental Health Outcome Scale"
                );
                return e.uuid !== encounter.uuid && obs && obs?.value !== 0;
              });

              const firstScore = filterOutScore
                .sort((a, b) => {
                  return new Date(a.encounterDatetime) - new Date(b.encounterDatetime);
                })
                .at(0)
                ?.obs.find(
                  (o) => o.concept.display === "Mental Health Outcome Scale"
                )?.value;

              return {
                dataElement: "b8bjS7ah8Qi",
                value: lastScore - firstScore,
              };
            }
          }


          function mapF37(encounter) {
            const answers = filterObsByConcept(
              encounter,
              "d30db8b8-f8fb-450c-9562-629195212a45"
            ).map((o) => o.value.display);

            if (answers.length === 0) {
              return;
            }
            const mappingConfig = [
              { dataElement: "MATDmdd9lRR", has: "Medical induction" },
              { dataElement: "DNQWSGBOBQB", has: "Unassisted induction" },
              { dataElement: "ts3xCk7k7x0", has: "Artificial rupture of membrane" },
              { dataElement: "p59TQ8PvXVH", has: "Dilatation and curettage" },
              { dataElement: "Uby3bOB4hFn", has: "Prepare for C-section" },
              { dataElement: "G2XoPI8Onh6", has: "Prepare for emergency C-section" },
              { dataElement: "cLo2RytNPE9", has: "Deferred admission" },
              { dataElement: "xB4S4ZVgAbm", has: "External referral" },
              { dataElement: "HgexHDb2auE", has: "Other" },
            ];

            const f37Mapping = mappingConfig
              .map((config) => {
                if (answers.some((a) => a.includes(config.has))) {
                  return {
                    dataElement: config.dataElement,
                    value: true,
                  };
                }
              })
              .filter(Boolean);

            console.log({ f37Mapping });
            return f37Mapping;
          }


          function mapF38(encounter) {
            const procedureAnswers = filterObsByConcept(
              encounter,
              "482af9e6-795d-42d9-be5b-64f4df54a63e"
            ).map((o) => o.value.display);

            const anaesthesiaAnswers = filterObsByConcept(
              encounter,
              "84cc236e-90fa-4eec-acf5-d0cd6b713dc4"
            ).map((o) => o.value.display);

            let f38Mapping = [];
            if (procedureAnswers.length > 1) {
              const procedureConfig = [
                {
                  dataElement: "JshMCeD8bNx",
                  has: "FGM / female circumcision management",
                },
                { dataElement: "oxXdt4qFPUT", has: "Episiotomy" },
                { dataElement: "puJfC1hX0CN", has: "Induction of labor" },
                {
                  dataElement: "ncgztSFld2L",
                  has: "Oxytocin for augmentation of labour",
                },
                {
                  dataElement: "cQsT8zdLu6s",
                  has: "VBAC (Vaginal birth after Caesearan)",
                },
                { dataElement: "BvfOhTNVitn", has: "Vaginal breech delivery" },
                { dataElement: "RHSujdOFWre", has: "Twins / triplets vaginal delivery" },
                { dataElement: "z1Bej1f1gCu", has: "Maneuver" },
                { dataElement: "JHZVr6SECp3", has: "Manual exploration of uterus" },
                { dataElement: "RiSel8y1SuF", has: "Curettage" },
                {
                  dataElement: "DxnQSPcbxdF",
                  has: "Laceration (perineal tear) repaired",
                },
                { dataElement: "IIoljELzj95", has: "Cervical tear repair" },
                { dataElement: "Lvk3ipAxiAH", has: "Tubal ligation (sterilization)" },
              ];
              const procedureMapping = procedureConfig
                .map((config) => {
                  if (procedureAnswers.some((a) => a.includes(config.has))) {
                    return {
                      dataElement: config.dataElement,
                      value: true,
                    };
                  }
                })
                .filter(Boolean);
              f38Mapping.push(...procedureMapping);
            }

            if (anaesthesiaAnswers.length > 0) {
              const anaesthesiaConfig = [
                { dataElement: "kjg89ETfuSW", has: "General" },
                { dataElement: "bgauK1cE1HM", has: "Local" },
                { dataElement: "dBAXsq3kl3p", has: "Spinal" },
              ];
              const anaesthesiaMapping = anaesthesiaConfig
                .map((config) => {
                  if (anaesthesiaAnswers.some((a) => a.includes(config.has))) {
                    return {
                      dataElement: config.dataElement,
                      value: true,
                    };
                  }
                })
                .filter(Boolean);
              f38Mapping.push(...anaesthesiaMapping);
            }

            if (f38Mapping.length === 0) {
              return;
            }

            console.log({ f38Mapping });
            return f38Mapping;
          }


          function mapF55(encounter) {
            if (encounter.form.description.includes("F55-HBV Baseline")) {
              const encounterDate = encounter.encounterDatetime.replace("+0000", "");
              return {
                dataElement: "z62bfjOA5CD",
                value: encounterDate,
              };
            }
          }


          function mapF56(encounter, metadataMap) {
            const { events } = metadataMap;
            const event = events?.find((e) => e.programStage === "d5sMByjqQFm")?.event;

            return {
              event,
              programStage: "d5sMByjqQFm",
              dataValues: [
                {
                  dataElement: "W450u7KdzUz",
                  value: encounter.encounterDatetime.replace("+0000", ""),
                },
                {
                  dataElement: "WaPztwF7kGN",
                  value: findAnswerByConcept(
                    encounter,
                    "4f4c6be4-1e1a-4770-a73b-bcc69c171748"
                  ),
                },
                {
                  dataElement: "Gl1axYBX5gV",
                  value: findAnswerByConcept(
                    encounter,
                    "0f478fde-1219-4815-9481-f507e8457c38"
                  ),
                },
                {
                  dataElement: "psbKn33o6yi",
                  value: findAnswerByConcept(
                    encounter,
                    "ef0b1e26-411e-40d5-bd98-8762f92c22d0"
                  ),
                },
              ],
            };
          }


          function mapF58(encounter, metadataMap) {
            const { events } = metadataMap;
            const event = events?.find((e) => e.programStage === "Rd73a6zlYEy")?.event;

            return {
              event,
              programStage: "Rd73a6zlYEy",
              dataValues: [
                {
                  dataElement: "gn40F7cEQTI",
                  value: encounter.encounterDatetime.replace("+0000", ""),
                },
                {
                  dataElement: "rmYRcxE5I5G",
                  value: findAnswerByConcept(
                    encounter,
                    "0f478fde-1219-4815-9481-f507e8457c38"
                  ),
                },
              ],
            };
          }


          function mapF59(encounter, metadataMap) {
            const { events } = metadataMap;

            const event = events?.find((e) => e.programStage === "sBepdVG2c9O")?.event;

            const typeOfIncome = findAnswerByConcept(
              encounter,
              "f501e482-d6cd-45d7-be5d-ef6e09461380"
            );

            const usedDrug = findAnswerByConcept(
              encounter,
              "30837713-453e-4456-ac48-b3886acf02ac"
            );
            const typeOfExit = findObsByConcept(
              encounter,
              "4f4c6be4-1e1a-4770-a73b-bcc69c171748"
            );

            const typeOfExitOther = findObsByConcept(
              encounter,
              "790b41ce-e1e7-11e8-b02f-0242ac130002"
            );

            return {
              event,
              programStage: "sBepdVG2c9O",
              dataValues: [
                {
                  dataElement: "Nfd45uVy6lc",
                  value: ["full time", "part time"].some((keyword) =>
                    typeOfIncome.toLowerCase().includes(keyword)
                  )
                    ? "Employment"
                    : null,
                },

                {
                  dataElement: "Ir0qLWsNv4n",
                  value: ["in the past", "currently"].some((keyword) =>
                    usedDrug.toLowerCase().includes(keyword)
                  )
                    ? "Yes"
                    : "No",
                },
                {
                  dataElement: "JvgfNjNklmI",
                  value: encounter.encounterDatetime.replace("+0000", ""),
                },
                {
                  dataElement: "LhgHv4gjW18",
                  value: typeOfExit?.value?.display,
                },
                {
                  dataElement: "k64e6bcyPtH",
                  value: typeOfExitOther?.value?.display,
                },
              ],
            };
          }


          function mapF60(encounter, metadataMap) {
            const { events } = metadataMap;
            const event = events?.find((e) => e.programStage === "sBepdVG2c9O")?.event;
            const typeOfExit = findObsByConcept(
              encounter,
              "4f4c6be4-1e1a-4770-a73b-bcc69c171748"
            );

            const typeOfExitOther = findObsByConcept(
              encounter,
              "790b41ce-e1e7-11e8-b02f-0242ac130002"
            );
            return {
              event,
              programStage: "sBepdVG2c9O",
              dataValues: [
                {
                  dataElement: "JvgfNjNklmI",
                  value: encounter.encounterDatetime.replace("+0000", ""),
                },
                {
                  dataElement: "LhgHv4gjW18",
                  value: typeOfExit?.value?.display,
                },
                {
                  dataElement: "k64e6bcyPtH",
                  value: typeOfExitOther?.value?.display,
                },
              ],
            };
          }


          const conceptAndValue = (encounter, conceptUuid, valueUuid) => {
            const answer = encounter.obs.find(
              (o) => o.concept.uuid === conceptUuid && o.value.uuid === valueUuid
            );
            return answer ? "TRUE" : "FALSE";
          };

          const conceptNotValue = (encounter, conceptUuid, valueUuid) => {
            const answer = encounter.obs.find(
              (o) => o.concept.uuid === conceptUuid && o.value.uuid !== valueUuid
            );
            return answer ? "TRUE" : "FALSE";
          };

          function mapF61(encounter, metadataMap) {
            const { events } = metadataMap;
            const event = events?.find((e) => e.programStage === "y8MvLYtuKE3")?.event;

            return {
              event,
              programStage: "y8MvLYtuKE3",
              dataValues: [
                {
                  dataElement: "wqSAGFM1Oz8",
                  value: conceptNotValue("2ff0d1ad-df05-4128-b2d2-d72307a6aa3f"),
                },
                {
                  dataElement: "M7aqCkQSnIP",
                  value: conceptAndValue(
                    "2ff0d1ad-df05-4128-b2d2-d72307a6aa3f",
                    "95ac8931-7222-4d14-9d94-2e55074e6261"
                  ),
                },
                {
                  dataElement: "H6mrPZ2PvGa",
                  value: conceptAndValue(
                    "2ff0d1ad-df05-4128-b2d2-d72307a6aa3f",
                    "a257d08e-b90d-4505-91c3-e23ea040f61c"
                  ),
                },
                {
                  dataElement: "aHEgOilU4Sg",
                  value: conceptAndValue(
                    "2ff0d1ad-df05-4128-b2d2-d72307a6aa3f",
                    "02e8a7bc-d18c-4650-bf47-c8e52f493f3b"
                  ),
                },
                {
                  dataElement: "I64ENhlDzP6",
                  value: conceptAndValue(
                    "2ff0d1ad-df05-4128-b2d2-d72307a6aa3f",
                    "a6fe73a2-0352-4104-82a7-4456f1866c1e"
                  ),
                },
                {
                  dataElement: "i69GqSWXwRZ",
                  value: conceptAndValue(
                    "2ff0d1ad-df05-4128-b2d2-d72307a6aa3f",
                    "9f50dc11-9ed4-4e25-a059-9cb770651c35"
                  ),
                },
                {
                  dataElement: "KGwTrsJjYR5",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a"
                  ),
                },
                {
                  dataElement: "G10cJ5RJ2uE",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "04684645-508f-4ec4-91a9-406e5567a934"
                  ),
                },
                {
                  dataElement: "Yp6qfnhSbTx",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "e81a13a6-d469-465d-9c6b-9930c7bb7d39"
                  ),
                },
                {
                  dataElement: "LgoaYXv2mkO",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "05aa3b94-7e7e-47f1-80b9-1304889c293c"
                  ),
                },
                {
                  dataElement: "ScHhUDsY1JM",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "b10b22e3-a46d-4682-aba5-fdeac3591d29"
                  ),
                },
                {
                  dataElement: "vKTI1wQhhy7",
                  value: conceptNotValue(
                    "ebb50467-1a62-41f0-a849-2ec0ed49607a",
                    "67322e0a-0def-4543-97cd-89cdd03e2950"
                  ),
                },
                {
                  dataElement: "qrcrEVE5vOL",
                  value: () => {
                    const hasConceptId = (conceptId) =>
                      encounter.obs.some((o) => o.concept.uuid === conceptId);
                    const notValueId = (valueUuid) =>
                      encounter.obs.find((o) => o.value.uuid !== valueUuid);
                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("1eff97cc-bec8-4bdf-9022-dc0f2132c260")
                    ) {
                      return "By road";
                    }
                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("8c5d6c46-1712-483f-91db-c6a9db213c50")
                    ) {
                      return "By plane";
                    }
                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("1eff97cc-bec8-4bdf-9022-dc0f2132c260") &&
                      notValueId("a31cd4a6-a02b-490b-b913-59cbc8f305f8")
                    ) {
                      return "By road and boat";
                    }

                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("1eff97cc-bec8-4bdf-9022-dc0f2132c260") &&
                      notValueId("8c5d6c46-1712-483f-91db-c6a9db213c50")
                    ) {
                      return "By road and plane";
                    }

                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("b10b22e3-a46d-4682-aba5-fdeac3591d29") &&
                      notValueId("8c5d6c46-1712-483f-91db-c6a9db213c50")
                    ) {
                      return "By boat and plane";
                    }

                    if (
                      hasConceptId("d0e31c9b-fb6b-4d8b-9c54-c8410c719f1c") &&
                      notValueId("1eff97cc-bec8-4bdf-9022-dc0f2132c260") &&
                      notValueId("a31cd4a6-a02b-490b-b913-59cbc8f305f8") &&
                      notValueId("8c5d6c46-1712-483f-91db-c6a9db213c50")
                    ) {
                      return "By road, boat and plane";
                    }
                    if (
                      hasConceptId("d30db8b8-f8fb-450c-9562-629195212a45") &&
                      notValueId("a6fe73a2-0352-4104-82a7-4456f1866c1e")
                    ) {
                      return true;
                    }
                  },
                },
                {
                  dataElement: "gJoiya16c1E",
                  value: conceptNotValue(
                    "d30db8b8-f8fb-450c-9562-629195212a45",
                    "a6fe73a2-0352-4104-82a7-4456f1866c1e"
                  ),
                },
                {
                  dataElement: "aHEgOilU4Sg",
                  value: conceptNotValue(
                    "d30db8b8-f8fb-450c-9562-629195212a45",
                    "02e8a7bc-d18c-4650-bf47-c8e52f493f3b"
                  ),
                },
                {
                  dataElement: "ahGVTDSbSaq",
                  value: conceptNotValue(
                    "d30db8b8-f8fb-450c-9562-629195212a45",
                    "a257d08e-b90d-4505-91c3-e23ea040f61c"
                  ),
                },
                {
                  dataElement: "i69GqSWXwRZ",
                  value: conceptNotValue(
                    "d30db8b8-f8fb-450c-9562-629195212a45",
                    "9f50dc11-9ed4-4e25-a059-9cb770651c35"
                  ),
                },
                {
                  dataElement: "Sp0VsyyvDCI",
                  value: conceptNotValue(
                    "96d32363-694a-4d6a-9710-6ceadd0e2894",
                    "4a946686-7d67-40d5-b1f1-a0aad133193c"
                  ),
                },
                {
                  dataElement: "JNNfaYcPPuS",
                  value: conceptNotValue(
                    "96d32363-694a-4d6a-9710-6ceadd0e2894",
                    "9de0f8c5-df5c-4fc2-a586-48acd7219e04"
                  ),
                },
                {
                  dataElement: "awIYcHfNEnI",
                  value: conceptNotValue(
                    "96d32363-694a-4d6a-9710-6ceadd0e2894",
                    "0254978b-c858-4b9d-ba66-074ced37a6d5"
                  ),
                },
                {
                  dataElement: "xjG5N6RD9vm",
                  value: conceptNotValue(
                    "96d32363-694a-4d6a-9710-6ceadd0e2894",
                    "e48a7343-bbc1-4e83-85ab-87e267f15cec"
                  ),
                },
                {
                  dataElement: "Lj15WiOE5Jj",
                  value: conceptNotValue(
                    "96d32363-694a-4d6a-9710-6ceadd0e2894",
                    "2b616aa9-e573-40a1-8e01-dfdde229553b"
                  ),
                },
              ],
            };
          }


          function mapF62(encounter, metadataMap) {
            const { events } = metadataMap;

            const hospitalisationEvent = {
              event: events?.find((e) => e.programStage === "YivvTlIw5Ep")?.event,
              programStage: "YivvTlIw5Ep",
              dataValues: [
                {
                  dataElement: "d3BwrZYHAbK",
                  value: encounter.encounterDatetime
                    .replace("+0000", "")
                    .substring(11, 19),
                },
                {
                  dataElement: "RSQqK2yZGz6",
                  value: findAnswerByConcept(
                    encounter,
                    "c149755e-dd32-43b0-b643-ab14aa483207"
                  ),
                },
                {
                  dataElement: "NHBJjpIXPBI",
                  value: findAnswerByConcept(
                    encounter,
                    "b996944c-b136-4e8e-9068-562476a0595a"
                  ),
                },
                {
                  dataElement: "LPIyv58pWVg",
                  value: findAnswerByConcept(
                    encounter,
                    "13cea1c8-e426-411f-95b4-33651fc4325d"
                  ),
                },
                {
                  dataElement: "nrqutHXxAUk",
                  value: findAnswerByConcept(
                    encounter,
                    "09a06404-afc5-457a-91b9-54152e45a854"
                  ),
                },
                {
                  dataElement: "dNJ9ZJ4zaJw",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "895813df-fbec-4164-9375-eed588ff0387"
                  ),
                },
                {
                  dataElement: "KlAcesRNOlU",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "bfcf416f-8aa1-4b9d-a0f7-77c142c1df67"
                  ),
                },
                {
                  dataElement: "pP8Bb7H0arh",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "10156771-379a-4eb1-af43-39b418adba4a"
                  ),
                },
                {
                  dataElement: "fKmCFuaV2wo",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "14e79fdc-4250-428f-949e-dabb2cef4315"
                  ),
                },
                {
                  dataElement: "oOa893M9qnL",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "a39e540e-b988-40e8-a8b2-26b831c179ef"
                  ),
                },
                {
                  dataElement: "rDJiUSUtmrg",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "c884bf19-6791-4c38-af6b-1ad910191a89"
                  ),
                },
                {
                  dataElement: "PG9mocTexDK",
                  value: conceptNotValue(
                    "6b3cf530-e574-419a-9dd4-2c8d3ad69562",
                    "d592dcaf-ae83-4acc-921e-127aa27545b5"
                  )
                    ? "Dressing"
                    : null,
                },
              ],
            };

            const exitEvent = {
              event: events?.find((e) => e.programStage === "Otoff7Cj8JQ")?.event,
              programStage: "Otoff7Cj8JQ",
              dataValues: [
                {
                  dataElement: "iGsz0Q3b0HC",
                  value: findAnswerByConcept(
                    encounter,
                    "1f473371-613f-4ef3-b297-49eb779ccd27"
                  ),
                },
                {
                  dataElement: "mpiPBwCu6Xa",
                  value: findAnswerByConcept(
                    encounter,
                    "9e861ef1-e07c-4955-9650-2ebac3138fc3"
                  ),
                },
                {
                  dataElement: "d8eoys0WPgR",
                  value: findAnswerByConcept(
                    encounter,
                    "a844ff25-b3fb-4873-9681-f2f35f5159ec"
                  ),
                },
                {
                  dataElement: "p1t7OpwVBcl",
                  value: findAnswerByConcept(
                    encounter,
                    "778b70b5-c6de-4459-a101-6bf02f77d5c7"
                  ),
                },
              ],
            };
            const f62Events = [hospitalisationEvent, exitEvent];

            return f62Events;
          }


          function mapF63(encounter, metadataMap) {
            return mapF62(encounter, metadataMap); // TODO @Aisha to confirm with ludovic
          }


          const findDataValue = (encounter, dataElement, metadataMap) => {
            const { optsMap, optionSetKey, form } = metadataMap;
            const [conceptUuid, questionId] =
              form.dataValueMap[dataElement]?.split("-rfe-") || [];
            const answer = encounter.obs.find((o) => o.concept.uuid === conceptUuid);
            const isObjectAnswer = answer && typeof answer.value === "object";
            const isStringAnswer = answer && typeof answer.value === "string";
            const isNumberAnswer = answer && typeof answer.value === "number";

            if (isStringAnswer || isNumberAnswer) {
              return answer.value;
            }

            if (
              isObjectAnswer &&
              conceptUuid === "722dd83a-c1cf-48ad-ac99-45ac131ccc96" &&
              dataElement === "pN4iQH4AEzk"
            ) {
              console.log("Yes done by psychologist..");
              return "" + answer.value.uuid === "278401ee-3d6f-4c65-9455-f1c16d0a7a98";
            }

            if (
              isObjectAnswer &&
              conceptUuid === "54e8c1b6-6397-4822-89a4-cf81fbc68ce9" &&
              dataElement === "G0hLyxqgcO7"
            ) {
              console.log("True only question detected..", dataElement);
              return answer.value.uuid === "681cf0bc-5213-492a-8470-0a0b3cc324dd"
                ? "true"
                : undefined;
            }

            if (isObjectAnswer) {
              const optionKey = questionId
                ? `${encounter.form.uuid}-${answer.concept.uuid}-rfe-${questionId}`
                : `${encounter.form.uuid}-${answer.concept.uuid}`;

              const matchingOptionSet = optionSetKey[optionKey];
              console.log("matchingOptionSet:", matchingOptionSet);
              console.log("Answer:", answer.value.uuid);

              const opt = optsMap.find(
                (o) =>
                  o["value.uuid - External ID"] === answer.value.uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet
              );

              console.log("Opt:", opt);
              const matchingOption =
                opt?.["DHIS2 Option Code"] ||
                opt?.["DHIS2 Option name"] || // TODO: Sync with AK: We have added this because  Opticon Code is empty in some cases.
                answer?.value?.display; //TODO: revisit this logic if optionSet not found
              if (!opt) {
                console.log(
                  `No opt found for External id ${answer.value.uuid} and DHIS2 OptionSet ${matchingOptionSet}`
                );
              }
              if (matchingOption !== opt?.["DHIS2 Option Code"]) {
                console.log(
                  `No DHIS2 Option Code found for External id ${answer.value.uuid} and DHIS2 OptionSet ${matchingOptionSet}`
                );
              }

              if (["FALSE", "No"].includes(matchingOption)) return "false";
              if (["TRUE", "Yes"].includes(matchingOption)) return "true";

              return matchingOption;
            }

            const isEncounterDate =
              conceptUuid === "encounter-date" &&
              ["CXS4qAJH2qD", "I7phgLmRWQq", "yUT7HyjWurN", "EOFi7nk2vNM"].includes(
                dataElement
              );

            // These are data elements for encounter date in DHIS2
            // F29 MHPSS Baseline v2, F31-mhGAP Baseline v2, F30-MHPSS Follow-up v2, F32-mhGAp Follow-up v2
            if (isEncounterDate) {
              return encounter.encounterDatetime.replace("+0000", "");
            }

            return "";
          };


          const formEncounters = (formDescription, encounters) => {
            return encounters.filter((e) => e.form.description.includes(formDescription));
          };


          const buildExitEvent = (encounter, tei) => {
            const { program, orgUnit, trackedEntity, enrollment, events } = tei;

            let exitEvent = null;
            const mapping = {
              program,
              orgUnit,
              trackedEntity,
              enrollment,
              occurredAt: encounter.encounterDatetime.replace("+0000", ""),
            };

            if (encounter.form.description.includes("F56-HBV Follow-up")) {
              exitEvent = {
                ...mapping,
                ...mapF56(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F58-HCV Follow-up")) {
              exitEvent = {
                ...mapping,
                ...mapF58(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F59-Social Work Baseline")) {
              exitEvent = {
                ...mapping,
                ...mapF59(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F60-Social Work Follow-up")) {
              exitEvent = {
                ...mapping,
                ...mapF60(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F61-Travel medicine")) {
              exitEvent = {
                ...mapping,
                ...mapF61(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F62-Palliative care Baseline")) {
              exitEvent = {
                ...mapping,
                ...mapF62(encounter, { events }),
              };
            }
            if (encounter.form.description.includes("F63-Palliative care Follow-up")) {
              exitEvent = {
                ...mapping,
                ...mapF63(encounter, { events }),
              };
            }

            return exitEvent;
          };

          // Prepare DHIS2 data model for create events

          fn((state) => {
            const handleMissingRecord = (data, state) => {
              const { uuid, display } = data.patient;

              console.log(uuid, "Patient is missing trackedEntity or enrollment");

              state.missingRecords ??= {};
              state.missingRecords[uuid] ??= {
                encounters: [],
                patient: display,
              };

              state.missingRecords[uuid].encounters.push(data.uuid);
            };

            state.eventsMapping = state.encounters
              .map((encounter) => {
                const form = state.formMaps[encounter.form.uuid];
                if (!form?.dataValueMap) {
                  return null;
                }
                const program = state.formMaps[encounter.form.uuid].programId;
                const orgUnit = state.formMaps[encounter.form.uuid].orgUnit;
                const patientOuProgram = `${orgUnit}-${program}-${encounter.patient.uuid}`;
                const { trackedEntity, enrollment, events } =
                  state.childTeis[patientOuProgram] || {};

                if (!trackedEntity || !enrollment) {
                  handleMissingRecord(encounter, state);
                  return null;
                }
                let formDataValues = Object.keys(form.dataValueMap)
                  .map((dataElement) => {
                    const value = findDataValue(encounter, dataElement, {
                      optsMap: state.optsMap,
                      optionSetKey: state.optionSetKey,
                      form,
                    });

                    return { dataElement, value };
                  })
                  .filter(
                    ({ dataElement, value }) =>
                      value &&
                      !["pj5hIE6iyAR", "KjgDauY9v4J", "DYTLOoEKRas"].includes(dataElement)
                  );

                const customMapping = [
                  mapF11(encounter, state.optsMap),
                  mapF13(encounter, state.optsMap),
                  mapF18(encounter, state.encounters),
                  mapF16(encounter),
                  mapF17(encounter),
                  mapF29(encounter, state.optsMap),
                  mapF22(encounter),
                  mapF37(encounter),
                  mapF38(encounter),
                  mapF30F29(encounter, state.allEncounters),
                  mapF32F31(encounter, state.allEncounters),
                  mapF33F34(encounter, state.allEncounters),
                ]
                  .filter(Boolean) // Only include non-empty mappings
                  .flat(); // flattening the array

                const formEvent = {
                  event: events?.find((e) => e.programStage === form.programStage)?.event,
                  program,
                  orgUnit,
                  trackedEntity,
                  enrollment,
                  occurredAt: encounter.encounterDatetime.replace("+0000", ""),
                  programStage: form.programStage,
                  dataValues: [...formDataValues, ...customMapping].filter(
                    (d) => d?.value
                  ),
                };

                const exitFormEvent = buildExitEvent(encounter, {
                  program,
                  orgUnit,
                  trackedEntity,
                  enrollment,
                  events,
                });

                const mappings = [formEvent, exitFormEvent];

                return mappings;
              })
              .flat()
              .filter(Boolean);

            return state;
          });
        adaptor: "@openfn/language-common@2.1.1"
        openfn:
          uuid: c31699da-9417-464f-84de-b3295a49720b
        next:
          create-events:
            disabled: false
            condition: |
              state?.eventsMapping?.length > 0 && !state.errors
            openfn:
              uuid: a314d87c-3497-4036-831a-3227d85b8c6b
      - id: get-encounters
        name: Get Encounters
        expression: >
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }


          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }

          // Fetch patient encounters

          each(
            $.patientUuids,
            get("encounter", { patient: $.data, v: "full" }).then((state) => {
              state.allEncounters ??= [];
              state.allEncounters.push(
                // v2FormsUuids are for mental health forms
                // ...state.data.results.filter(e =>
                //   state.v2FormUuids.includes(e?.form?.uuid)
                // )
                ...state.data.results.filter((e) =>
                  state.formUuids.includes(e?.form?.uuid)
                )
              );

              const patientUuid = state.references.at(-1);
              const filteredEncounters = state.formUuids.map((formUuid) =>
                state.data.results
                  .filter(
                    (e) =>
                      e.auditInfo.dateCreated >= state.cursor &&
                      e?.form?.uuid === formUuid
                  )
                  .sort(
                    (a, b) =>
                      new Date(b.auditInfo.dateCreated) -
                      new Date(a.auditInfo.dateCreated)
                  )
              );

              const encounters = filteredEncounters
                .map((pe) => {
                  const isLatestForm = pe.find((e) => {
                    return state.formMaps[e?.form?.uuid]?.syncType === "latest";
                  });
                  if (isLatestForm) {
                    return [isLatestForm];
                  } else {
                    const allPatientEncounter = pe.filter(
                      (e) => state.formMaps[e?.form?.uuid]?.syncType === "all"
                    );
                    return allPatientEncounter;
                  }
                })
                .flat();

              state.encounters ??= [];
              state.encounters.push(...encounters);

              console.log(
                encounters.length,
                `# of filtered encounters found in OMRS for ${patientUuid}`
              );

              return state;
            })
          );


          fn((state) => {
            const {
              data,
              index,
              response,
              references,
              allResponse,
              patientUuids,
              patients,
              ...next
            } = state;

            if (next.encounters?.length) {
              next.encounters = next.encounters.map((encounter) => {
                const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                  removeNulls(encounter)
                );

                return {
                  uuid,
                  patient: {
                    uuid: patient.uuid,
                    display: patient.display,
                  },
                  obs: obs.map((o) => {
                    return {
                      uuid: o.uuid,
                      concept: o.concept,
                      display: o.display,
                      formFieldPath: o.formFieldPath,
                      value: o.value,
                      person: o.person,
                    };
                  }),
                  form: {
                    uuid: form.uuid,
                    display: form.display,
                    description: form.description,
                    name: form.name,
                  },
                  encounterDatetime,
                };
              });
              console.log(next.encounters.length, "# of new encounters to sync to dhis2");
            } else {
              console.log("No encounters found for cursor: ", next.cursor);
            }
            next.allEncounters = next.allEncounters?.map((encounter) => {
              const { uuid, patient, obs, form, encounterDatetime } = removeLinks(
                removeNulls(encounter)
              );

              return {
                uuid,
                patient: {
                  uuid: patient.uuid,
                  display: patient.display,
                },
                obs: obs.map((o) => {
                  return {
                    uuid: o.uuid,
                    concept: o.concept,
                    display: o.display,
                    formFieldPath: o.formFieldPath,
                    value: o.value,
                    person: o.person,
                  };
                }),
                form: {
                  uuid: form.uuid,
                  display: form.display,
                  description: form.description,
                  name: form.name,
                },
                encounterDatetime,
              };
            });

            return next;
          });
        adaptor: "@openfn/language-openmrs@4.3.0"
        openfn:
          uuid: ea92d31b-95a2-4683-85d5-f591513dbccc
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
        next:
          get-parent-and-child-teis:
            disabled: false
            condition: |
              !state.errors && state.encounters.length > 0
            openfn:
              uuid: 44fda748-0643-46bb-8e89-4b75bec4bdbd
      - id: get-parent-and-child-teis
        name: Get Parent and Child TEIs
        expression: >
          const delay = (ms) => new Promise((resolve) => setTimeout(resolve,
          ms));


          const teiByPatientUuid = (patientUuid, teis) => {
            return teis.find((tei) => {
              const omrsPatientUuid = tei.attributes.find(
                ({ attribute }) => attribute === "AYbfTPYMNJH"
              )?.value;

              return omrsPatientUuid === patientUuid;
            });
          };


          fn((state) => {
            // Group encounters by patient UUID
            state.encountersByPatient = state.encounters.reduce((acc, obj) => {
              const key = obj.patient.uuid;
              if (!acc[key]) {
                acc[key] = [];
              }
              acc[key].push(obj);
              return acc;
            }, {});

            return state;
          });


          get("tracker/trackedEntities", {
            orgUnit: $.orgUnit,
            program: $.program,
            filter: (state) => [
              `AYbfTPYMNJH:IN:${Object.keys(state.encountersByPatient).join(";")}`,
            ],
          });


          fn((state) => {
            state.parentTeis ??= {};
            state.missingParentTeis ??= {};

            Object.keys(state.encountersByPatient).forEach((patientUuid) => {
              const parentTei = teiByPatientUuid(patientUuid, state.data.instances);
              if (parentTei?.trackedEntity) {
                console.log("Parent TEI found:", parentTei.trackedEntity);

                state.parentTeis[patientUuid] = {
                  trackedEntity: parentTei.trackedEntity,
                  attributes: parentTei.attributes,
                  trackedEntityType: parentTei.trackedEntityType,
                  enrollments: parentTei.enrollments,
                };
              } else {
                console.log("Parent TEI Not Found for Patient:", patientUuid);
                state.missingParentTeis[patientUuid] =
                  state.encountersByPatient[patientUuid];
              }
            });

            return state;
          });


          fn((state) => {
            state.ouProgramEncounters = state.encounters.reduce((acc, obj) => {
              const formUuid = obj.form.uuid;
              const patientUuid = obj.patient.uuid;
              const orgUnit = state.formMaps[formUuid].orgUnit;
              const program = state.formMaps[formUuid].programId;
              const key = `${orgUnit}-${program}`;
              if (!acc[key]) {
                acc[key] = {
                  orgUnit,
                  program,
                  patientUuids: [patientUuid],
                };
              }
              if (!acc[key].patientUuids.includes(patientUuid)) {
                acc[key].patientUuids.push(patientUuid);
              }
              return acc;
            }, {});

            return state;
          });


          each(
            (state) => Object.values(state.ouProgramEncounters),
            get("tracker/trackedEntities", (state) => {
              const { orgUnit, program, patientUuids } = state.data;
              return {
                orgUnit,
                program,
                filter: [`AYbfTPYMNJH:IN:${patientUuids.join(";")}`],
                fields: "*",
              };
            })
              .then((state) => {
                state.childTeis ??= {};
                state.encounters.forEach((encounter) => {
                  const patientUuid = encounter.patient.uuid;
                  const program = state.formMaps[encounter.form.uuid].programId;
                  const orgUnit = state.formMaps[encounter.form.uuid].orgUnit;

                  const tei = state.data.instances.find((tei) => {
                    const omrsPatientUuid = tei.attributes.find(
                      (attribute) => attribute.attribute === "AYbfTPYMNJH"
                    )?.value;
                    const teiProgram = tei.programOwners.find(
                      (po) => po.trackedEntity === tei.trackedEntity
                    )?.program;

                    return (
                      omrsPatientUuid === patientUuid &&
                      teiProgram === program &&
                      tei.orgUnit === orgUnit
                    );
                  });

                  const patientOuProgram = `${orgUnit}-${program}-${patientUuid}`;
                  const relationshipType =
                    state.formMaps[encounter.form.uuid]?.relationshipId;

                  if (tei?.trackedEntity) {
                    console.log("Child TEI found:", tei.trackedEntity);
                    state.childTeis[patientOuProgram] = {
                      relationshipType,
                      trackedEntity: tei.trackedEntity,
                      attributes: tei.attributes,
                      trackedEntityType: tei.trackedEntityType,
                      enrollments: tei.enrollments,
                      orgUnit,
                      program,
                    };
                  }

                  if (!tei && !state.childTeis[patientOuProgram]) {
                    console.log("Child TEI not found for patient:", patientUuid);
                    const { attributes, trackedEntityType } =
                      state?.parentTeis[patientUuid];

                    state.childTeis[patientOuProgram] = {
                      relationshipType,
                      trackedEntityType,
                      enrollments: [
                        {
                          orgUnit,
                          program,
                          enrolledAt: new Date().toISOString().split("T")[0],
                          attributes: attributes.filter((attribute) =>
                            [
                              "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                            ].includes(attribute.attribute)
                          ),
                        },
                      ],
                      attributes,
                      orgUnit,
                      program,
                    };
                  }
                });

                return state;
              })
              .then(async (state) => {
                await delay(2000);
                return state;
              })
          );
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 29e87d9d-53c4-47bf-885d-19a70b839120
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          upsert-child-teis:
            disabled: false
            condition: >
              Object.keys(state?.childTeis)?.length > 0 &&
              Object.keys(state?.parentTeis)?.length > 0
            openfn:
              uuid: a07cd9c9-a88e-4854-8186-23a9f98a8103
      - id: get-patients
        name: Get Patients
        expression: >
          function removeLinks(data) {
            if (Array.isArray(data)) {
              return data.map(removeLinks);
            }

            if (typeof data === "object" && data !== null) {
              const { links, ...rest } = data;
              return Object.fromEntries(
                Object.entries(rest).map(([key, value]) => [key, removeLinks(value)])
              );
            }

            return data;
          }


          function removeNulls(data) {
            if (Array.isArray(data)) {
              return data.filter((item) => item !== null).map(removeNulls);
            }

            if (typeof data === "object" && data !== null) {
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (value !== null) {
                  result[key] = removeNulls(value);
                }
              }
              return result;
            }

            return data;
          }


          cursor($.lastRunDateTime || "2025-03-20T06:01:24.000Z");


          cursor("today", {
            key: "lastRunDateTime",
            format: (c) => dateFns.format(new Date(c), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
          });


          searchPatient({ q: $.msfId || "IQ", v: "full", limit: "100" });


          fn((state) => {
            const { cursor, data } = state;
            console.log("Filtering patients since cursor:", cursor);
            console.log("Patient fetched", data.results.length);

            state.patients = data.results
              .filter(({ auditInfo }) => {
                const lastModified = auditInfo?.dateChanged || auditInfo?.dateCreated;
                return lastModified > cursor;
              })
              .map((p) => {
                const { uuid, auditInfo, identifiers, person } = removeLinks(
                  removeNulls(p)
                );
                const { dateCreated } = auditInfo;
                const { age, birthdate, gender, names, addresses, attributes } = person;

                return {
                  uuid,
                  person: {
                    age,
                    birthdate,
                    gender,
                    names,
                    addresses: [addresses.find((a) => a.cityVillage)],
                    attributes,
                  },
                  identifiers,
                  auditInfo: { dateCreated },
                };
              });
            state.searchPatientUuids = state.patients.map((p) => p.uuid);
            console.log("# of patients to sync to dhis2 ::", state.patients.length);

            return state;
          });


          // Fetch all encounters

          http
            .get("/ws/fhir2/R4/Encounter", {
              query: { _count: 100, _lastUpdated: `ge${$.cursor}` },
            })
            .then((state) => {
              const { link, total } = state.data;
              state.nextUrl = link
                .find((l) => l.relation === "next")
                ?.url.replace(/(_count=)\d+/, `$1${total}`)
                .split("/openmrs")[1];

              state.allResponse = state.data;
              return state;
            });

          fnIf(
            $.nextUrl,
            http.get($.nextUrl).then((state) => {
              console.log(`Fetched ${state.data.entry.length} remaining encounters`);
              delete state.allResponse.link;
              state.allResponse.entry.push(...state.data.entry);
              return state;
            })
          );


          fn((state) => {
            console.log(
              "Total # of encounters fetched: ",
              state.allResponse?.entry?.length
            );

            const uuids = [
              ...new Set(
                state.allResponse?.entry?.map((p) =>
                  p.resource?.subject?.reference?.replace("Patient/", "")
                )
              ),
            ];
            state.encounterPatientUuids = [...new Set(uuids)];

            return state;
          });


          fn((state) => {
            const {
              cursor,
              lastRunDateTime,
              patients,
              searchPatientUuids,
              encounterPatientUuids,
            } = state;

            const onlyInSearchPatient = searchPatientUuids.filter(
              (id) => !encounterPatientUuids.includes(id)
            );

            const onlyInR4Encounter = encounterPatientUuids.filter(
              (id) => !searchPatientUuids.includes(id)
            );
            const inbothResults = searchPatientUuids.filter((id) =>
              encounterPatientUuids.includes(id)
            );
            const patientUuids = [
              ...new Set([...searchPatientUuids, ...encounterPatientUuids]),
            ];

            console.log("inbothResults", inbothResults.length);
            console.log("patient-search-array", onlyInSearchPatient.length);
            console.log("r4-encounter-array", onlyInR4Encounter.length);
            console.log("combined uuids", patientUuids.length);

            return { cursor, lastRunDateTime, patients, patientUuids };
          });
        adaptor: "@openfn/language-openmrs@4.3.0"
        openfn:
          uuid: 9cc0cbea-ba1a-4555-83a1-a191944f303e
          project_credential_id: efd2a233-caf8-4346-bc0c-6a25c24e1a08
        next:
          mappings:
            disabled: false
            openfn:
              uuid: 704bb712-f0be-4199-83b8-c84a3da5feb5
      - id: mappings
        name: Mappings
        expression: >
          const isValidUUID = (id) => {
            if (!id || typeof id !== "string") return false;

            const UUID_PATTERN =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            return UUID_PATTERN.test(id);
          };


          collections.get("mosul-metadata-mappings-main").then((state) => {
            state.optsMap = state.data
              .filter((i) => i.key.includes("optsMap-value-"))
              .map((i) => i.value);

            state.identifiers = state.data
              .filter((i) => i.key.includes("identifiers-value-"))
              .map((i) => i.value);
            state.syncedAt = state.data.find((i) => i.key === "syncedAt")?.value;
            state.formMetadata = state.data.find((i) => i.key === "formMetadata")?.value;
            state.placeOflivingMap = state.data.find(
              (i) => i.key === "placeOflivingMap"
            )?.value;
            state.sourceFile = state.data.filter(
              (i) => i.key === "sourceFile"
            )?.[0]?.value;
            state.fileDateModified = state.data.filter(
              (i) => i.key === "fileDateModified"
            )?.[0]?.value;
            state.formMaps = state.data.find((i) => i.key === "formMaps")?.value;

            // TODO: Remove state.optionSetKey, when needed
            // Build from state.formMaps
            state.optionSetKey = state.data.filter(
              (i) => i.key === "optionSetKey"
            )?.[0]?.value;

            delete state.data;
            delete state.references;
            return state;
          });


          fn((state) => {
            const { formMetadata, identifiers, ...rest } = state;

            rest.v2FormUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) &&
                  form["OMRS Form Version"] === "v4-2025"
              )
              .map((form) => form["OMRS form.uuid"]);
            rest.formUuids = formMetadata
              .filter(
                (form) =>
                  isValidUUID(form["OMRS form.uuid"]) && form["Workflow"] === "WF2"
              )
              .map((form) => form["OMRS form.uuid"]);

            rest.patientProgramStage = "vN61drMkGqO";

            rest.orgUnit = "sUpt0j2GmBD";
            // rest.orgUnit = identifiers.find(i => i.type === 'ORG_UNIT')?.[
            //   'dhis2 attribute id'
            // ];
            rest.program = "dWdzxMuKa8Z";
            // rest.program = identifiers.find(i => i.type === 'PROGRAM')?.[
            //   'dhis2 attribute id'
            // ];
            // rest.patientProgramStage = state.formMaps.patient.programStage;

            rest.dhis2PatientNumber = identifiers.find(
              (i) => i.type === "DHIS2_PATIENT_NUMBER"
            )?.["omrs identifierType"]; //DHIS2 ID or DHIS2 Patient Number

            rest.openmrsAutoId = identifiers.find((i) => i.type === "OPENMRS_AUTO_ID")?.[
              "omrs identifierType"
            ]; //MSF ID or OpenMRS Patient Number

            return rest;
          });
        adaptor: "@openfn/language-common@2.1.1"
        openfn:
          uuid: 0a6f5426-9c6d-4214-8e05-55cb9e368e14
          project_credential_id: 90cddfa1-9b77-4625-a812-2a04d061522c
        next:
          upsert-teis:
            disabled: false
            condition: |
              state.patients.length > 0 && !state.errors
            openfn:
              uuid: 5953cda9-d8c3-454a-8a05-aac6c9c07eb5
          get-encounters:
            disabled: false
            condition: |
              !state.errors && state.patients.length === 0
            openfn:
              uuid: 0fd2390e-6faf-4da6-8d4a-220685fe22ae
      - id: trigger
        type: cron
        openfn:
          enabled: false
          uuid: d10691b1-666f-4e0f-8064-40d4ce8fdc32
          cron_expression: 0 0 * * *
        next:
          get-patients:
            disabled: false
            condition: true
            openfn:
              uuid: e5a1e40b-a435-495b-8260-3ddf4e4b6f95
      - id: update-teis
        name: Update TEIs
        expression: |
          // Update TEIs
          create(
            "tracker",
            { trackedEntities: $.teisToUpdate },
            { params: { async: false, importStrategy: "UPDATE" } }
          );

          fn(({ lastRunDateTime }) => ({ lastRunDateTime }));
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 3d50b0ba-7959-4a1b-8468-99ffd140a2ba
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
      - id: upsert-child-teis
        name: Upsert Child TEIs
        expression: >
          create(
            "tracker",
            {
              trackedEntities: (state) => {
                const childTeis = Object.values(state.childTeis).map(
                  ({ relationshipType, ...tei }) => tei
                );
                return childTeis;
              },
            },
            {
              params: {
                atomicMode: "ALL",
                async: false,
              },
            }
          );


          fn((state) => {
            state.upsertedTeis =
              state.data.bundleReport.typeReportMap.TRACKED_ENTITY.objectReports.map(
                (report) => report.uid
              );
            return state;
          });


          each(
            $.upsertedTeis,
            get(`tracker/trackedEntities/${$.data}`, {
              fields: "*",
            }).then((state) => {
              const {
                trackedEntity,
                programOwners,
                enrollments,
                attributes,
                events,
                orgUnit,
              } = state.data || {};

              const program = programOwners.find(
                (po) => po.trackedEntity === trackedEntity && po.orgUnit === orgUnit
              )?.program;

              const patientUuid = attributes.find(
                (a) => a.attribute === "AYbfTPYMNJH"
              ).value;

              const relationshipType = Object.values(state.formMaps).find(
                (form) =>
                  form.programId === program &&
                  form.orgUnit === orgUnit &&
                  form.formName !== "F00-Registration"
              )?.relationshipId;
              state.childTeis ??= {};
              state.childTeis[`${orgUnit}-${program}-${patientUuid}`] = {
                relationshipType,
                trackedEntity,
                events: enrollments?.[0]?.events ?? events,
                enrollment: enrollments?.[0]?.enrollment,
                attributes,
                orgUnit,
                program,
              };

              return state;
            })
          );
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: ba3e1803-acd8-4fe0-849f-6e0f4d120afd
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          create-teis-relationship:
            disabled: false
            openfn:
              uuid: b5de09be-bff1-45fb-8726-ad8e8e02c2ca
      - id: upsert-teis
        name: Upsert TEIs
        expression: >
          function chunkArray(array, size) {
            const chunks = [];
            for (let i = 0; i < array.length; i += size) {
              chunks.push(array.slice(i, i + size));
            }
            return chunks;
          }


          const buildTeiMapping = (omrsPatient, patientTei, mappingConfig) => {
            const genderMap = {
              M: "male",
              O: "unknown",
              F: "female",
              U: "unknown",
            };
            const {
              orgUnit,
              program,
              optsMap,
              formMaps,
              placeOflivingMap,
              patientProgramStage,
              dhis2PatientNumber,
              openmrsAutoId,
            } = mappingConfig;

            const enrolledAt = omrsPatient.auditInfo.dateCreated.substring(0, 10);
            const findIdentifierByUuid = (identifiers, targetUuid) =>
              identifiers.find((i) => i.identifierType.uuid === targetUuid)?.identifier;

            const findAttrValue = (uuid) => {
              return omrsPatient.person.attributes.find(
                (a) => a.attributeType.uuid === uuid
              )?.value;
            };

            const findOptCodeByUuid = (uuid) => {
              const optionKey = `patient-${uuid}`;
              const matchingOptionSet = state.optionSetKey[optionKey];
              return optsMap.find((o) => o["value.uuid - External ID"] === uuid &&
                  o["DHIS2 Option Set UID"] === matchingOptionSet)?.[
                "DHIS2 Option Code"
              ];
            };

            const findOptCode = (attrValue) => {
              if (typeof attrValue === "string") {
                return attrValue
                // return findOptCodeByUuid(attrValue);
              }
              if (typeof attrValue === "object") {
                const { uuid, display } = attrValue;
                const optCodeByDisplay = optsMap.find(
                  (o) =>
                    o["value.uuid - External ID"] === uuid &&
                    o["value.display - Answers"] === display
                )?.["DHIS2 Option Code"];

                // return optCodeByDisplay ?? findOptCodeByUuid(uuid);
                return findOptCodeByUuid(uuid) ?? optCodeByDisplay;

              }
              return null;
            };

            const patientMap = formMaps.patient.dataValueMap;
            const statusAttrMaps = Object.keys(patientMap).map((d) => {
              const attrValue = findAttrValue(patientMap[d]);
              if (!findOptCode(attrValue)) {
                console.log({attrValue})
              }
              return {
                attribute: d,
                value: findOptCode(attrValue),
              };
            });

            const standardAttr = [
              {
                attribute: "fa7uwpCKIwa",
                value: omrsPatient.person?.names[0]?.givenName,
              },
              {
                attribute: "Jt9BhFZkvP2",
                value: omrsPatient.person?.names[0]?.familyName,
              },
              {
                attribute: "P4wdYGkldeG", //DHIS2 ID ==> "Patient Number"
                value:
                  findIdentifierByUuid(omrsPatient.identifiers, dhis2PatientNumber) ||
                  findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId), //map OMRS ID if no DHIS2 id
              },
              {
                attribute: "ZBoxuExmxcZ", //MSF ID ==> "OpenMRS Patient Number"
                value: findIdentifierByUuid(omrsPatient.identifiers, openmrsAutoId),
              },
              {
                attribute: "AYbfTPYMNJH", //"OpenMRS Patient UID"
                value: omrsPatient.uuid,
              },

              {
                attribute: "T1iX2NuPyqS",
                value: omrsPatient.person.age,
              },
              {
                attribute: "WDp4nVor9Z7",
                value: omrsPatient.person.birthdate?.slice(0, 10),
              },
              {
                attribute: "rBtrjV1Mqkz", //Place of living
                value: placeOflivingMap[omrsPatient.person?.addresses[0]?.cityVillage],
              },
            ];

            //filter out attributes that don't have a value from dhis2
            const filteredAttr = standardAttr.filter((a) => a.value);
            const filteredStatusAttr = statusAttrMaps.filter((a) => a.value);

            const payload = {
              program,
              orgUnit,
              attributes: [...filteredAttr, ...filteredStatusAttr],
            };
            // console.log('mapped dhis2 payloads:: ', JSON.stringify(payload, null, 2));
            const enrollments = [
              {
                orgUnit,
                program,
                enrolledAt,
                programStage: patientProgramStage, //'MdTtRixaC1B',
              },
            ];

            if (!patientTei) {
              payload.trackedEntityType = "cHlzCA2MuEF";

              payload.attributes.push({
                attribute: "qptKDiv9uPl",
                value: genderMap[omrsPatient.person.gender],
              });
              console.log("create enrollment");
              payload.enrollments = enrollments;
            }

            if (patientTei) {
              payload.trackedEntity = patientTei.trackedEntity;
              payload.trackedEntityType = patientTei.trackedEntityType;
            }

            return payload;
          };


          const delay = (ms) => new Promise((resolve) => setTimeout(resolve,
          ms));


          each(
            (state) => chunkArray(state.patients, 200),
            get("tracker/trackedEntities", {
              orgUnit: $.orgUnit,
              filter: (state) => [
                `AYbfTPYMNJH:IN:${state.data.map((patient) => patient.uuid).join(";")}`,
              ],
              program: $.program,
              fields: "*",
            }).then((state) => {
              state.foundTrackedEntities ??= [];
              state.foundTrackedEntities.push(...state.data.instances);
              return state;
            })
          );


          fn((state) => {
            const findTeiByUuid = (patientUuid) => {
              return state.foundTrackedEntities.find((tei) => {
                return (
                  tei.attributes.find(
                    (attribute) => attribute.attribute === "AYbfTPYMNJH"
                  )?.value === patientUuid
                );
              });
            };

            state.patientsMapping = state.patients.map((patient) => {
              const patientTei = findTeiByUuid(patient.uuid);
              
              const mapping = buildTeiMapping(patient, patientTei, {
                placeOflivingMap: state.placeOflivingMap,
                orgUnit: state.orgUnit,
                program: state.program,
                patientProgramStage: state.patientProgramStage,
                formMaps: state.formMaps,
                optsMap: state.optsMap,
                dhis2PatientNumber: state.dhis2PatientNumber,
                openmrsAutoId: state.openmrsAutoId,
              });

              // Filter out null attributes or values
              mapping.attributes = mapping.attributes.filter(
              attr => attr.attribute != null && attr.attribute !== '' && 
                      attr.value != null && attr.value !== ''
              );

              return mapping;
          });
            return state;
          });


          //Bulk upsert

          create(
            "tracker",
            { trackedEntities: $.patientsMapping },
            {
              params: {
                atomicMode: "ALL",
                importStrategy: "CREATE_AND_UPDATE",
                async: false,
              },
            }
          );

          fn((state) => {
            const {
              data,
              response,
              references,
              patients,
              patientsUpsert,
              placeOflivingMap,
              identifiers,
              ...next
            } = state;
            next.patientUuids = patients.map((p) => p.uuid);
            return next;
          });
        adaptor: "@openfn/language-dhis2@5.0.1"
        openfn:
          uuid: 5f47a65c-b739-46d7-8fa3-8a722458d4a3
          project_credential_id: 448e46cd-482d-4cb5-88f9-b413cdd7ff3f
        next:
          get-encounters:
            disabled: false
            condition: |
              state.patientUuids.length > 0 && !state.errors
            openfn:
              uuid: 26954f83-daed-4f98-8011-c2c5bc24ecd3
    history: []
    openfn:
      uuid: 648e9d15-3ccf-4751-aa83-94627d6de843
      inserted_at: 2025-09-23T16:10:21Z
      updated_at: 2025-12-16T11:10:50Z
      lock_version: 57
    id: wf2-omrs-dhis2
